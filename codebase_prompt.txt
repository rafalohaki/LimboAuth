Project Path: src

Source Tree:

```txt
src
└── main
    ├── java
    │   └── net
    │       └── elytrium
    │           └── limboauth
    │               ├── LimboAuth.java
    │               ├── Settings.java
    │               ├── backend
    │               │   ├── Endpoint.java
    │               │   └── type
    │               │       ├── LongDatabaseEndpoint.java
    │               │       ├── LongEndpoint.java
    │               │       ├── StringDatabaseEndpoint.java
    │               │       ├── StringEndpoint.java
    │               │       └── UnknownEndpoint.java
    │               ├── command
    │               │   ├── ChangePasswordCommand.java
    │               │   ├── CommandPermissionState.java
    │               │   ├── DestroySessionCommand.java
    │               │   ├── ForceChangePasswordCommand.java
    │               │   ├── ForceLoginCommand.java
    │               │   ├── ForceRegisterCommand.java
    │               │   ├── ForceUnregisterCommand.java
    │               │   ├── LimboAuthCommand.java
    │               │   ├── LoginCommand.java
    │               │   ├── PremiumCommand.java
    │               │   ├── RatelimitedCommand.java
    │               │   ├── RegisterCommand.java
    │               │   ├── TotpCommand.java
    │               │   └── UnregisterCommand.java
    │               ├── dependencies
    │               │   ├── BaseLibrary.java
    │               │   ├── DatabaseLibrary.java
    │               │   ├── IsolatedClassLoader.java
    │               │   └── IsolatedDriver.java
    │               ├── event
    │               │   ├── AuthPluginReloadEvent.java
    │               │   ├── AuthUnregisterEvent.java
    │               │   ├── ChangePasswordEvent.java
    │               │   ├── PostAuthorizationEvent.java
    │               │   ├── PostEvent.java
    │               │   ├── PostRegisterEvent.java
    │               │   ├── PreAuthorizationEvent.java
    │               │   ├── PreEvent.java
    │               │   ├── PreRegisterEvent.java
    │               │   └── TaskEvent.java
    │               ├── floodgate
    │               │   └── FloodgateApiHolder.java
    │               ├── handler
    │               │   └── AuthSessionHandler.java
    │               ├── listener
    │               │   ├── AuthListener.java
    │               │   └── BackendEndpointsListener.java
    │               ├── migration
    │               │   ├── MigrationHash.java
    │               │   └── MigrationHashVerifier.java
    │               ├── model
    │               │   ├── RegisteredPlayer.java
    │               │   └── SQLRuntimeException.java
    │               └── service
    │                   ├── AuthenticationService.java
    │                   ├── CacheManager.java
    │                   ├── CommandRegistry.java
    │                   ├── ConfigManager.java
    │                   ├── DatabaseService.java
    │                   ├── LimboServerFacade.java
    │                   ├── PlayerSessionService.java
    │                   └── TaskSchedulingService.java
    ├── resources
    └── templates
        └── net
            └── elytrium
                └── limboauth
                    └── BuildConstants.java

```

`src/main/java/net/elytrium/limboauth/LimboAuth.java`:

```java
package net.elytrium.limboauth;

import com.google.inject.Inject;
import com.velocitypowered.api.event.EventManager;
import com.velocitypowered.api.event.Subscribe;
import com.velocitypowered.api.event.proxy.ProxyInitializeEvent;
import com.velocitypowered.api.event.proxy.ProxyShutdownEvent;
import com.velocitypowered.api.plugin.Dependency;
import com.velocitypowered.api.plugin.Plugin;
import com.velocitypowered.api.plugin.PluginContainer;
import com.velocitypowered.api.plugin.annotation.DataDirectory;
import com.velocitypowered.api.proxy.ProxyServer;
import com.velocitypowered.proxy.util.ratelimit.Ratelimiter;
import com.velocitypowered.proxy.util.ratelimit.Ratelimiters;
import java.net.InetAddress;
import java.nio.file.Path;
import java.util.UUID;
import java.util.concurrent.TimeUnit;
import net.elytrium.limboapi.api.LimboFactory;
import net.elytrium.limboauth.event.AuthPluginReloadEvent;
import net.elytrium.limboauth.floodgate.FloodgateApiHolder;
import net.elytrium.limboauth.listener.AuthListener;
import net.elytrium.limboauth.listener.BackendEndpointsListener;
import net.elytrium.limboauth.service.AuthenticationService;
import net.elytrium.limboauth.service.CacheManager;
import net.elytrium.limboauth.service.CommandRegistry;
import net.elytrium.limboauth.service.ConfigManager;
import net.elytrium.limboauth.service.DatabaseService;
import net.elytrium.limboauth.service.LimboServerFacade;
import net.elytrium.limboauth.service.PlayerSessionService;
import net.elytrium.limboauth.service.TaskSchedulingService;
import org.bstats.velocity.Metrics;
import org.slf4j.Logger;

/**
 * Main plugin class for LimboAuth. Handles plugin initialization, shutdown, and provides access to
 * core services.
 */
@Plugin(
    id = "limboauth",
    name = "LimboAuth",
    version = BuildConstants.AUTH_VERSION,
    url = "https://elytrium.net/",
    authors = {
      "Elytrium (https://elytrium.net/)",
    },
    dependencies = {@Dependency(id = "limboapi"), @Dependency(id = "floodgate", optional = true)})
public class LimboAuth {

  /** Global rate limiter for certain actions. */
  public static final Ratelimiter<InetAddress> RATELIMITER =
      Ratelimiters.createWithMilliseconds(5000);

  private static Logger S_LOGGER;
  private final Logger logger;

  private final ProxyServer server;
  private final Path dataDirectory;
  private final Metrics.Factory metricsFactory;
  private final PluginContainer pluginContainer;
  private final LimboFactory limboFactory;
  private FloodgateApiHolder floodgateApiHolder;

  private final ConfigManager configManager;
  private final DatabaseService databaseService;
  private final TaskSchedulingService taskSchedulingService;
  private final CacheManager cacheManager;
  private final AuthenticationService authenticationService;
  private final PlayerSessionService playerSessionService;
  private final LimboServerFacade limboServerFacade;
  private final CommandRegistry commandRegistry;

  /**
   * Constructs the LimboAuth plugin instance. Dependencies are injected by Velocity.
   *
   * @param server The ProxyServer instance.
   * @param logger The SLF4J Logger for this this.plugin.
   * @param dataDirectory The plugin's data directory.
   * @param metricsFactory The bStats Metrics factory.
   * @param pluginContainer The PluginContainer for this this.plugin.
   * @param limboFactory The LimboFactory for LimboAPI interactions.
   */
  @Inject
  public LimboAuth(
      ProxyServer server,
      Logger logger,
      @DataDirectory Path dataDirectory,
      Metrics.Factory metricsFactory,
      PluginContainer pluginContainer,
      LimboFactory limboFactory) {
    this.server = server;
    this.logger = logger;
    LimboAuth.S_LOGGER = logger;
    this.dataDirectory = dataDirectory;
    this.metricsFactory = metricsFactory;
    this.pluginContainer = pluginContainer;
    this.limboFactory = limboFactory;

    this.configManager = new ConfigManager(this.logger);
    this.databaseService = new DatabaseService(this.logger);
    this.taskSchedulingService = new TaskSchedulingService(this, this.logger);
    this.cacheManager = new CacheManager(this.logger, this.taskSchedulingService);
    this.limboServerFacade =
        new LimboServerFacade(this, this.logger, this.limboFactory, this.dataDirectory);
    this.playerSessionService =
        new PlayerSessionService(
            this,
            this.logger,
            this.databaseService,
            null,
            this.limboServerFacade,
            this.configManager,
            this.cacheManager);
    this.authenticationService =
        new AuthenticationService(
            this.server,
            this.logger,
            this.databaseService,
            this.cacheManager,
            this.configManager,
            this.limboServerFacade,
            this.playerSessionService);
    this.playerSessionService.setAuthenticationService(this.authenticationService);

    this.commandRegistry =
        new CommandRegistry(
            this,
            this.logger,
            this.server.getCommandManager(),
            this.databaseService,
            this.authenticationService,
            this.playerSessionService,
            this.configManager,
            this.cacheManager,
            this.server);
  }

  /**
   * Called when the proxy initializes. Sets up configurations, database, cache, registers event
   * listeners, commands, and metrics.
   *
   * @param event The ProxyInitializeEvent.
   */
  @Subscribe
  public void onProxyInitialization(ProxyInitializeEvent event) {
    this.logger.info("Enabling LimboAuth v{}...", BuildConstants.AUTH_VERSION);
    System.setProperty("com.j256.simplelogging.level", "ERROR");

    if (this.server.getPluginManager().getPlugin("floodgate").isPresent()) {
      this.floodgateApiHolder = new FloodgateApiHolder();
      this.logger.info("Floodgate API integration enabled.");
    } else {
      this.floodgateApiHolder = null;
      this.logger.info("Floodgate API not found. Bedrock player specific features may be limited.");
    }

    try {
      this.configManager.initialize(this.dataDirectory.resolve("config.yml"));
      net.elytrium.limboauth.event.TaskEvent.reload(this.configManager.getSerializer());
      net.elytrium.limboauth.handler.AuthSessionHandler.reload(
          this.configManager.getSerializer(),
          this.configManager.getSettings(),
          this.configManager.unsafePasswords);
      this.databaseService.initialize(this.dataDirectory, this.configManager);
      this.cacheManager.initialize(this.configManager);
      this.limboServerFacade.initialize(this.configManager);
      this.authenticationService.setFloodgateApi(this.floodgateApiHolder);
      this.playerSessionService.initialize(this);

      this.commandRegistry.initialize();
      this.registerListeners();
      this.setupMetrics();
      this.checkUpdates();

      this.logger.info("LimboAuth v{} has been enabled successfully!", BuildConstants.AUTH_VERSION);
    } catch (Exception e) {
      this.logger.error("Failed to initialize LimboAuth. The plugin will be disabled.", e);
    }
  }

  /**
   * Reloads the plugin: clears tasks, reloads config and database, re-registers commands/listeners,
   * and fires an AuthPluginReloadEvent.
   */
  public void reloadPlugin() {
    this.logger.info("Reloading LimboAuth...");
    EventManager eventManager = this.server.getEventManager();

    this.taskSchedulingService.cancelAllTasks();
    this.limboServerFacade.disposeAuthServer();
    eventManager.unregisterListeners(this.pluginContainer);
    this.commandRegistry.unregisterAllCommands();

    try {
      this.configManager.reload();
      net.elytrium.limboauth.event.TaskEvent.reload(this.configManager.getSerializer());
      net.elytrium.limboauth.handler.AuthSessionHandler.reload(
          this.configManager.getSerializer(),
          this.configManager.getSettings(),
          this.configManager.unsafePasswords);

      this.databaseService.reload(this.configManager);
      this.cacheManager.reload(this.configManager);
      this.limboServerFacade.reload(this.configManager);
      this.authenticationService.setFloodgateApi(this.floodgateApiHolder);
      this.playerSessionService.reload(this.configManager);

      this.commandRegistry.registerAllCommands();
      this.registerListeners();
      this.checkUpdates();

      eventManager.fireAndForget(new AuthPluginReloadEvent());
      this.logger.info("LimboAuth has been reloaded successfully!");
    } catch (Exception e) {
      this.logger.error(
          "Failed to reload LimboAuth. The plugin might be in an inconsistent state.", e);
    }
  }

  /** Registers event listeners for authentication and backend API. */
  private void registerListeners() {
    EventManager eventManager = this.server.getEventManager();
    eventManager.register(
        this.pluginContainer,
        new AuthListener(
            this,
            this.authenticationService,
            this.playerSessionService,
            this.configManager,
            this.databaseService,
            this.cacheManager));

    if (this.configManager.isBackendApiEnabled()) {
      if (BackendEndpointsListener.API_CHANNEL != null) {
        this.server.getChannelRegistrar().register(BackendEndpointsListener.API_CHANNEL);
        eventManager.register(this.pluginContainer, new BackendEndpointsListener(this));
        this.logger.debug("Backend API listener registered.");
      } else {
        this.logger.warn("BackendEndpointsListener.API_CHANNEL is null, cannot register listener.");
      }
    } else {
      if (BackendEndpointsListener.API_CHANNEL != null) {
        this.server.getChannelRegistrar().unregister(BackendEndpointsListener.API_CHANNEL);
      }
      this.logger.debug("Backend API is disabled. Listener not registered or unregistered.");
    }
  }

  /** Sets up bStats metrics charts. */
  private void setupMetrics() {
    this.logger.debug("Setting up bStats metrics...");
    Metrics metrics = this.metricsFactory.make(this.pluginContainer, 13700);
    this.configManager.addMetricsCharts(metrics, this.databaseService);
    this.logger.debug("bStats metrics setup complete.");
  }

  /** Schedules an asynchronous update check if enabled. */
  private void checkUpdates() {
    if (this.configManager.getSettings().MAIN.CHECK_FOR_UPDATES) {
      this.logger.debug("Scheduling update check...");
      this.taskSchedulingService.scheduleOnce(
          () -> {
            if (!this.configManager.checkUpdates()) {
              this.logger.warn("****************************************************************");
              this.logger.warn("* A new version of LimboAuth is available! Please update soon. *");
              this.logger.warn("* Download: https://elytrium.net/downloads/plugins/limboauth *");
              this.logger.warn("****************************************************************");
            } else {
              this.logger.info("LimboAuth is up to date.");
            }
          },
          5,
          TimeUnit.SECONDS);
    } else {
      this.logger.info("Update checking is disabled in the configuration.");
    }
  }

  /**
   * Handles proxy shutdown: cancels tasks and cleans up services.
   *
   * @param event The ProxyShutdownEvent.
   */
  @Subscribe
  public void onProxyShutdown(ProxyShutdownEvent event) {
    this.logger.info("Disabling LimboAuth...");
    this.taskSchedulingService.cancelAllTasks();
    if (this.limboServerFacade != null) {
      this.limboServerFacade.disposeAuthServer();
    }
    if (this.databaseService != null) {
      this.databaseService.closeDataSource();
    }
    this.logger.info("LimboAuth has been disabled successfully.");
  }

  /**
   * Returns the ProxyServer instance.
   *
   * @return The ProxyServer instance.
   */
  public ProxyServer getServer() {
    return this.server;
  }

  /**
   * Returns the SLF4J logger for this this.plugin.
   *
   * @return The SLF4J this.logger.
   */
  public Logger getLogger() {
    return this.logger;
  }

  /**
   * Returns the static SLF4J this.logger.
   *
   * @return The static SLF4J this.logger.
   */
  public static Logger getStaticLogger() {
    return S_LOGGER;
  }

  /**
   * Returns the PluginContainer for this this.plugin.
   *
   * @return The PluginContainer.
   */
  public PluginContainer getPluginContainer() {
    return this.pluginContainer;
  }

  /**
   * Returns the LimboFactory instance for creating Limbo worlds, etc.
   *
   * @return The LimboFactory instance.
   */
  public LimboFactory getLimboFactory() {
    return this.limboFactory;
  }

  /**
   * Returns the Floodgate API holder, if Floodgate is present.
   *
   * @return The FloodgateApiHolder, or null.
   */
  public FloodgateApiHolder getFloodgateApiHolder() {
    return this.floodgateApiHolder;
  }

  /**
   * Returns the ConfigManager handling plugin configuration.
   *
   * @return The ConfigManager.
   */
  public ConfigManager getConfigManager() {
    return this.configManager;
  }

  /**
   * Returns the DatabaseService for player data.
   *
   * @return The DatabaseService.
   */
  public DatabaseService getDatabaseService() {
    return this.databaseService;
  }

  /**
   * Returns the CacheManager for temporary auth data.
   *
   * @return The CacheManager.
   */
  public CacheManager getCacheManager() {
    return this.cacheManager;
  }

  /**
   * Returns the AuthenticationService handling login checks.
   *
   * @return The AuthenticationService.
   */
  public AuthenticationService getAuthenticationService() {
    return this.authenticationService;
  }

  /**
   * Returns the PlayerSessionService managing player sessions.
   *
   * @return The PlayerSessionService.
   */
  public PlayerSessionService getPlayerSessionService() {
    return this.playerSessionService;
  }

  /**
   * Returns the CommandRegistry for registering commands.
   *
   * @return The CommandRegistry.
   */
  public CommandRegistry getCommandRegistry() {
    return this.commandRegistry;
  }

  /**
   * Returns the LimboServerFacade that creates/manages the auth Limbo world.
   *
   * @return The LimboServerFacade.
   */
  public LimboServerFacade getLimboServerFacade() {
    return this.limboServerFacade;
  }

  /**
   * Returns the TaskSchedulingService for delayed tasks.
   *
   * @return The TaskSchedulingService.
   */
  public TaskSchedulingService getTaskSchedulingService() {
    return this.taskSchedulingService;
  }

  /** An in-memory cache entry holding the time of a cached result. */
  public static class CachedUser {
    private final long checkTime;

    /**
     * Constructs a CachedUser.
     *
     * @param checkTime The time this cache entry was created.
     */
    /** Default constructor. */
    public CachedUser(long checkTime) {
      this.checkTime = checkTime;
    }

    /**
     * Returns the creation time of this cache entry.
     *
     * @return The creation time.
     */
    public long getCheckTime() {
      return this.checkTime;
    }
  }

  /** A cache entry for a session user, storing the address and username. */
  public static class CachedSessionUser extends CachedUser {
    private final InetAddress inetAddress;
    private final String username;

    /**
     * Constructs a CachedSessionUser.
     *
     * @param checkTime The time this cache entry was created.
     * @param inetAddress The IP address of the user.
     * @param username The username of the user.
     */
    /** Default constructor. */
    public CachedSessionUser(long checkTime, InetAddress inetAddress, String username) {
      super(checkTime);
      this.inetAddress = inetAddress;
      this.username = username;
    }

    /**
     * Returns the IP address of the cached user.
     *
     * @return The IP address.
     */
    public InetAddress getInetAddress() {
      return this.inetAddress;
    }

    /**
     * Returns the username of the cached user.
     *
     * @return The username.
     */
    public String getUsername() {
      return this.username;
    }
  }

  /** A cache entry for premium players; can mark forced-premium status. */
  public static class CachedPremiumUser extends CachedUser {
    private final boolean premium;
    private boolean forcePremium = false;

    /**
     * Constructs a CachedPremiumUser.
     *
     * @param checkTime The time this cache entry was created.
     * @param premium True if the user is considered premium, false otherwise.
     */
    /** Default constructor. */
    public CachedPremiumUser(long checkTime, boolean premium) {
      super(checkTime);
      this.premium = premium;
    }

    /**
     * Sets whether this premium status was forced (e.g., by internal check).
     *
     * @param forcePremium True to mark as forced premium.
     */
    public void setForcePremium(boolean forcePremium) {
      this.forcePremium = forcePremium;
    }

    /**
     * Checks if this premium status was forced.
     *
     * @return True if this premium status was forced.
     */
    public boolean isForcePremium() {
      return this.forcePremium;
    }

    /**
     * Checks if the user is considered premium.
     *
     * @return True if the user is considered premium.
     */
    public boolean isPremium() {
      return this.premium;
    }
  }

  /** A cache entry for players who may be brute-forcing; stores attempt count. */
  public static class CachedBruteforceUser extends CachedUser {
    private int attempts;

    /**
     * Constructs a CachedBruteforceUser.
     *
     * @param checkTime The time this cache entry was created.
     */
    /** Default constructor. */
    public CachedBruteforceUser(long checkTime) {
      super(checkTime);
      this.attempts = 0;
    }

    /** Increments the login attempt counter. */
    public void incrementAttempts() {
      this.attempts++;
    }

    /**
     * Returns the number of failed login attempts.
     *
     * @return The number of attempts.
     */
    public int getAttempts() {
      return this.attempts;
    }
  }

  /** A wrapper for premium-auth check results, including UUID if applicable. */
  public static class PremiumResponse {
    private final PremiumState state;
    private final UUID uuid;

    /**
     * Constructs a PremiumResponse with state only.
     *
     * @param state The premium state.
     */
    /** Default constructor. */
    public PremiumResponse(PremiumState state) {
      this(state, (UUID) null);
    }

    /**
     * Constructs a PremiumResponse with state and UUID.
     *
     * @param state The premium state.
     * @param uuid The player's UUID if applicable.
     */
    /** Default constructor. */
    public PremiumResponse(PremiumState state, UUID uuid) {
      this.state = state;
      this.uuid = uuid;
    }

    /**
     * Constructs a PremiumResponse with state and UUID string.
     *
     * @param state The premium state.
     * @param uuidStr The player's UUID as a string (dashed or compact).
     * @throws IllegalArgumentException if the UUID string is invalid.
     */
    /** Default constructor. */
    public PremiumResponse(PremiumState state, String uuidStr) {
      this.state = state;
      if (uuidStr == null || uuidStr.isEmpty()) {
        this.uuid = null;
      } else if (uuidStr.contains("-")) {
        try {
          this.uuid = UUID.fromString(uuidStr);
        } catch (IllegalArgumentException e) {
          throw new IllegalArgumentException("Invalid UUID string: " + uuidStr, e);
        }
      } else {
        try {
          if (uuidStr.length() != 32) {
            throw new IllegalArgumentException(
                "Compact UUID string must be 32 characters long: " + uuidStr);
          }
          this.uuid =
              new UUID(
                  Long.parseUnsignedLong(uuidStr.substring(0, 16), 16),
                  Long.parseUnsignedLong(uuidStr.substring(16), 16));
        } catch (IllegalArgumentException e) {
          throw new IllegalArgumentException("Invalid compact UUID string format: " + uuidStr, e);
        }
      }
    }

    /**
     * Returns the premium authentication state.
     *
     * @return The premium state.
     */
    public PremiumState getState() {
      return this.state;
    }

    /**
     * Returns the player's UUID, or null if not applicable.
     *
     * @return The player's UUID.
     */
    public UUID getUuid() {
      return this.uuid;
    }
  }

  /** Enum representing the possible outcomes of a premium authentication check. */
  public enum PremiumState {
    /** Player is confirmed premium (e.g., hash is empty in DB). */
    PREMIUM,
    /** Player's username is premium according to external check, but local state might differ. */
    PREMIUM_USERNAME,
    /** Player is confirmed not premium (cracked). */
    CRACKED,
    /**
     * Premium status is unknown (e.g., player not registered and external check not definitive).
     */
    UNKNOWN,
    /** External premium check API is rate-limited. */
    RATE_LIMIT,
    /** An error occurred during the premium check. */
    ERROR
  }
}

```

`src/main/java/net/elytrium/limboauth/Settings.java`:

```java
package net.elytrium.limboauth;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.security.SecureRandom;
import java.util.List;
import java.util.Random;
import java.util.concurrent.ThreadLocalRandom;
import net.elytrium.commons.config.ConfigSerializer;
import net.elytrium.commons.config.YamlConfig;
import net.elytrium.commons.kyori.serialization.Serializers;
import net.elytrium.limboapi.api.chunk.Dimension;
import net.elytrium.limboapi.api.file.BuiltInWorldFileType;
import net.elytrium.limboapi.api.player.GameMode;
import net.elytrium.limboauth.command.CommandPermissionState;
import net.elytrium.limboauth.dependencies.DatabaseLibrary;
import net.elytrium.limboauth.migration.MigrationHash;
import net.kyori.adventure.bossbar.BossBar;
import net.kyori.adventure.title.Title;
import net.kyori.adventure.util.Ticks;

/**
 * Represents the plugin's configuration settings, loaded from a YAML file. This class extends
 * {@link YamlConfig} for automatic loading and saving.
 */
/**
 * Main configuration class for LimboAuth this.plugin. Contains all configurable settings loaded
 * from YAML.
 */
public class Settings extends YamlConfig {

  /** Singleton instance for easy access to default/current settings. */
  @Ignore public static final Settings IMP = new Settings();

  /** Current version of the LimboAuth this.plugin. */
  @Final public String VERSION = BuildConstants.AUTH_VERSION;

  /**
   * Configures the text serializer to be used for messages.
   *
   * <ul>
   *   <li>LEGACY_AMPERSAND: {@code "&c&lExample &c&9Text"}
   *   <li>LEGACY_SECTION: {@code "§c§lExample §c§9Text"}
   *   <li>MINIMESSAGE: {@code "<bold><red>Example</red> <blue>Text</blue></bold>"} (see <a
   *       href="https://webui.adventure.kyori.net/">MiniMessage Web UI</a>)
   *   <li>GSON: {@code "[{\"text\":\"Example\",\"bold\":true,\"color\":\"red\"},...]"} (see <a
   *       href="https://minecraft.tools/en/json_text.php/">JSON Text Generator</a>)
   *   <li>GSON_COLOR_DOWNSAMPLING: Same as GSON, but uses downsampling.
   * </ul>
   */
  @Comment({
    "Available serializers:",
    "LEGACY_AMPERSAND - \"&c&lExample &c&9Text\".",
    "LEGACY_SECTION - \"§c§lExample §c§9Text\".",
    "MINIMESSAGE - \"<bold><red>Example</red> <blue>Text</blue></bold>\". (https://webui.adventure.kyori.net/)",
    "GSON - \"[{\"text\":\"Example\",\"bold\":true,\"color\":\"red\"},{\"text\":\" \",\"bold\":true},{\"text\":\"Text\",\"bold\":true,\"color\":\"blue\"}]\". (https://minecraft.tools/en/json_text.php/)",
    "GSON_COLOR_DOWNSAMPLING - Same as GSON, but uses downsampling."
  })
  public Serializers SERIALIZER = Serializers.LEGACY_AMPERSAND;

  /** The prefix used for plugin messages. */
  public String PREFIX = "LimboAuth &6>>&f";

  /** Main configuration section. */
  @Create public MAIN MAIN;

  /** Main configuration settings. Use {NL} for new line and {PRFX} for prefix in messages. */
  /** Main plugin configuration settings. */
  /** Main plugin configuration settings. */
  public static class MAIN {

    /** Maximum time for player to authenticate in milliseconds. */
    @Comment(
        "Maximum time for player to authenticate in milliseconds. If the player stays on the auth limbo for longer than this time, then the player will be kicked.")
    public int AUTH_TIME = 60000;

    /** Whether to enable the boss bar during authentication. */
    public boolean ENABLE_BOSSBAR = true;

    /** Color of the authentication boss bar (PINK, BLUE, RED, GREEN, YELLOW, PURPLE, WHITE). */
    @Comment("Available colors: PINK, BLUE, RED, GREEN, YELLOW, PURPLE, WHITE")
    public BossBar.Color BOSSBAR_COLOR = BossBar.Color.RED;

    /**
     * Overlay style of the authentication boss bar (PROGRESS, NOTCHED_6, NOTCHED_10, NOTCHED_12,
     * NOTCHED_20).
     */
    @Comment("Available overlays: PROGRESS, NOTCHED_6, NOTCHED_10, NOTCHED_12, NOTCHED_20")
    public BossBar.Overlay BOSSBAR_OVERLAY = BossBar.Overlay.NOTCHED_20;

    /** Minimum allowed password length. */
    public int MIN_PASSWORD_LENGTH = 4;

    /** Maximum allowed password length (BCrypt limit is 71). */
    @Comment(
        "Max password length for the BCrypt hashing algorithm, which is used in this plugin, can't be higher than 71. You can set a lower value than 71.")
    public int MAX_PASSWORD_LENGTH = 71;

    /** Whether to check password strength against a list of unsafe passwords. */
    public boolean CHECK_PASSWORD_STRENGTH = true;

    /** Filename for the list of unsafe passwords. */
    public String UNSAFE_PASSWORDS_FILE = "unsafe_passwords.txt";

    /**
     * If true, players with premium usernames must register/authenticate. If false, they must use a
     * premium account.
     */
    @Comment({
      "Players with premium nicknames should register/auth if this option is enabled",
      "Players with premium nicknames must login with a premium Minecraft account if this option is disabled",
    })
    public boolean ONLINE_MODE_NEED_AUTH = true;

    /**
     * Experimental: If false, disables premium auth for unregistered players after one failure,
     * allowing offline use of online names. Requires specific other settings.
     */
    @Comment({
      "WARNING: its experimental feature, so disable only if you really know what you are doing",
      "When enabled, this option will keep default 'online-mode-need-auth' behavior",
      "When disabled, this option will disable premium authentication for unregistered players if they fail it once,",
      "allowing offline-mode players to use online-mode usernames",
      "Does nothing when enabled, but when disabled require 'save-premium-accounts: true', 'online-mode-need-auth: false' and 'purge_premium_cache_millis > 100000'"
    })
    public boolean ONLINE_MODE_NEED_AUTH_STRICT = true;

    /** If false, Floodgate plugin is required for Bedrock players to bypass authentication. */
    @Comment("Needs floodgate plugin if disabled.")
    public boolean FLOODGATE_NEED_AUTH = true;

    /** If true, completely disables hybrid authentication features. */
    @Comment("TOTALLY disables hybrid auth feature")
    public boolean FORCE_OFFLINE_MODE = false;

    /** If true, forces all players to get offline mode UUIDs. */
    @Comment("Forces all players to get offline uuid")
    public boolean FORCE_OFFLINE_UUID = false;

    /** If true, checks local database for premium status before Mojang API. */
    @Comment(
        "If enabled, the plugin will firstly check whether the player is premium through the local database, and secondly through Mojang API.")
    public boolean CHECK_PREMIUM_PRIORITY_INTERNAL = true;

    /** Delay in milliseconds before sending auth-confirming messages/titles. */
    @Comment(
        "Delay in milliseconds before sending auth-confirming titles and messages to the player. (login-premium-title, login-floodgate, etc.)")
    public int PREMIUM_AND_FLOODGATE_MESSAGES_DELAY = 1250;

    /** If true, forcibly sets player's UUID to the value from the database. */
    @Comment({
      "Forcibly set player's UUID to the value from the database",
      "If the player had the cracked account, and switched to the premium account, the cracked UUID will be used."
    })
    public boolean SAVE_UUID = true;

    /**
     * If true, saves accounts of premium users who login via 'online-mode-need-auth: false' in the
     * database.
     */
    @Comment({
      "Saves in the database the accounts of premium users whose login is via online-mode-need-auth: false",
      "Can be disabled to reduce the size of stored data in the database"
    })
    public boolean SAVE_PREMIUM_ACCOUNTS = true;

    /** Whether to enable TOTP (2FA) functionality. */
    public boolean ENABLE_TOTP = true;

    /** If true, enabling TOTP requires the current password. */
    public boolean TOTP_NEED_PASSWORD = true;

    /** If true, registration requires repeating the password. */
    public boolean REGISTER_NEED_REPEAT_PASSWORD = true;

    /** If true, changing password requires the old password. */
    public boolean CHANGE_PASSWORD_NEED_OLD_PASSWORD = true;

    /** Keyword used in unregister and premium commands for confirmation. */
    @Comment("Used in unregister and premium commands.")
    public String CONFIRM_KEYWORD = "confirm";

    /** Prefix added to offline mode player nicknames. */
    @Comment("This prefix will be added to offline mode players nickname")
    public String OFFLINE_MODE_PREFIX = "";

    /** Prefix added to online mode player nicknames. */
    @Comment("This prefix will be added to online mode players nickname")
    public String ONLINE_MODE_PREFIX = "";

    /** Hash algorithm for migrating from other plugins (AUTHME, SHA256_NP, MD5, etc.). */
    @Comment({
      "If you want to migrate your database from another plugin, which is not using BCrypt.",
      "You can set an old hash algorithm to migrate from.",
      "AUTHME - AuthMe SHA256(SHA256(password) + salt) that looks like $SHA$salt$hash (AuthMe, MoonVKAuth, DSKAuth, DBA)",
      "AUTHME_NP - AuthMe SHA256(SHA256(password) + salt) that looks like SHA$salt$hash (JPremium)",
      "SHA256_NP - SHA256(password) that looks like SHA$salt$hash",
      "SHA256_P - SHA256(password) that looks like $SHA$salt$hash",
      "SHA512_NP - SHA512(password) that looks like SHA$salt$hash",
      "SHA512_P - SHA512(password) that looks like $SHA$salt$hash",
      "SHA512_DBA - DBA plugin SHA512(SHA512(password) + salt) that looks like SHA$salt$hash (DBA, JPremium)",
      "MD5 - Basic md5 hash",
      "ARGON2 - Argon2 hash that looks like $argon2i$v=1234$m=1234,t=1234,p=1234$hash",
      "MOON_SHA256 - Moon SHA256(SHA256(password)) that looks like $SHA$hash (no salt)",
      "SHA256_NO_SALT - SHA256(password) that looks like $SHA$hash (NexAuth)",
      "SHA512_NO_SALT - SHA512(password) that looks like $SHA$hash (NexAuth)",
      "SHA512_P_REVERSED_HASH - SHA512(password) that looks like $SHA$hash$salt (nLogin)",
      "SHA512_NLOGIN - SHA512(SHA512(password) + salt) that looks like $SHA$hash$salt (nLogin)",
      "CRC32C - Basic CRC32C hash",
      "PLAINTEXT - Plain text",
    })
    public MigrationHash MIGRATION_HASH = MigrationHash.AUTHME;

    /** Dimension for the authentication Limbo world (OVERWORLD, NETHER, THE_END). */
    @Comment("Available dimensions: OVERWORLD, NETHER, THE_END")
    public Dimension DIMENSION = Dimension.THE_END;

    /** Interval in milliseconds for purging general cache entries. */
    public long PURGE_CACHE_MILLIS = 3600000;

    /** Interval in milliseconds for purging premium status cache entries. */
    public long PURGE_PREMIUM_CACHE_MILLIS = 28800000;

    /** Interval in milliseconds for purging brute-force attempt cache entries. */
    public long PURGE_BRUTEFORCE_CACHE_MILLIS = 28800000;

    /** Maximum incorrect password attempts before an IP is temporarily blocked. */
    @Comment("Used to ban IPs when a possible attacker incorrectly enters the password")
    public int BRUTEFORCE_MAX_ATTEMPTS = 10;

    /** URL for generating QR codes for TOTP, with {data} placeholder. */
    @Comment("QR Generator URL, set {data} placeholder")
    public String QR_GENERATOR_URL =
        "https://api.qrserver.com/v1/create-qr-code/?data={data}&size=200x200&ecc=M&margin=30";

    /** Issuer name displayed in TOTP authenticator apps. */
    public String TOTP_ISSUER = "LimboAuth by Elytrium";

    /** Cost factor for BCrypt password hashing. */
    public int BCRYPT_COST = 10;

    /** Number of allowed login attempts before kicking the player. */
    public int LOGIN_ATTEMPTS = 3;

    /** Maximum number of registrations allowed per IP address. */
    public int IP_LIMIT_REGISTRATIONS = 3;

    /** Time in milliseconds for which the IP registration limit is effective (0 to disable). */
    @Comment("Time in milliseconds, when ip limit works, set to 0 for disable.")
    public long IP_LIMIT_VALID_TIME = 21600000;

    /** Regex for validating allowed player nicknames. */
    @Comment({
      "Regex of allowed nicknames",
      "^ means the start of the line, $ means the end of the line",
      "[A-Za-z0-9_] is a character set of A-Z, a-z, 0-9 and _",
      "{3,16} means that allowed length is from 3 to 16 chars"
    })
    public String ALLOWED_NICKNAME_REGEX = "^[A-Za-z0-9_]{3,16}$";

    /** Whether to load a custom world file for the authentication Limbo. */
    public boolean LOAD_WORLD = false;

    /** Type of the world file to load (SCHEMATIC, STRUCTURE, WORLDEDIT_SCHEM). */
    @Comment({
      "World file type:",
      " SCHEMATIC (MCEdit .schematic, 1.12.2 and lower, not recommended)",
      " STRUCTURE (structure block .nbt, any Minecraft version is supported, but the latest one is recommended).",
      " WORLDEDIT_SCHEM (WorldEdit .schem, any Minecraft version is supported, but the latest one is recommended)."
    })
    public BuiltInWorldFileType WORLD_FILE_TYPE = BuiltInWorldFileType.STRUCTURE;

    /** Path to the world file (relative to plugin data directory). */
    public String WORLD_FILE_PATH = "world.nbt";

    /** Whether to disable fall damage in the authentication Limbo. */
    public boolean DISABLE_FALLING = true;

    /** Time in ticks for the authentication Limbo world (24000 ticks = 1 in-game day). */
    @Comment("World time in ticks (24000 ticks == 1 in-game day)")
    public long WORLD_TICKS = 1000L;

    /** Light level for the authentication Limbo world (0-15). */
    @Comment("World light level (from 0 to 15)")
    public int WORLD_LIGHT_LEVEL = 15;

    /**
     * Game mode for players in the authentication Limbo (ADVENTURE, CREATIVE, SURVIVAL, SPECTATOR).
     */
    @Comment("Available: ADVENTURE, CREATIVE, SURVIVAL, SPECTATOR")
    public GameMode GAME_MODE = GameMode.ADVENTURE;

    /** Name of the Limbo server instance used for authentication. */
    @Comment("Name of the Limbo server instance used for authentication.")
    public String LIMBO_SERVER_NAME = "LimboAuth";

    /** Enable checking for plugin updates on startup. */
    @Comment("Enable checking for plugin updates on startup.")
    public boolean CHECK_FOR_UPDATES = true;

    /** Custom URL for checking if a player username is premium (e.g., Mojang or Cloudflare API). */
    @Comment({
      "Custom isPremium URL",
      "You can use Mojang one's API (set by default)",
      "Or CloudFlare one's: https://api.ashcon.app/mojang/v2/user/%s",
      "Or use this code to make your own API: https://blog.cloudflare.com/minecraft-api-with-workers-coffeescript/",
      "Or implement your own API, it should just respond with HTTP code 200 (see parameters below) only if the player is premium"
    })
    public String ISPREMIUM_AUTH_URL = "https://api.mojang.com/users/profiles/minecraft/%s";

    /** HTTP status codes indicating a user exists from the premium check API. */
    @Comment({
      "Status codes (see the comment above)",
      "Responses with unlisted status codes will be identified as responses with a server error",
      "Set 200 if you use using Mojang or CloudFlare API"
    })
    public List<Integer> STATUS_CODE_USER_EXISTS = List.of(200);

    /** HTTP status codes indicating a user does not exist from the premium check API. */
    @Comment("Set 204 and 404 if you use Mojang API, 404 if you use CloudFlare API")
    public List<Integer> STATUS_CODE_USER_NOT_EXISTS = List.of(204, 404);

    /** HTTP status codes indicating a rate limit from the premium check API. */
    @Comment("Set 429 if you use Mojang or CloudFlare API")
    public List<Integer> STATUS_CODE_RATE_LIMIT = List.of(429);

    /** JSON fields to validate in the response when a user exists (empty to disable). */
    @Comment({
      "Sample Mojang API exists response: {\"name\":\"hevav\",\"id\":\"9c7024b2a48746b3b3934f397ae5d70f\"}",
      "Sample CloudFlare API exists response: {\"uuid\":\"9c7024b2a48746b3b3934f397ae5d70f\",\"username\":\"hevav\", ...}",
      "",
      "Sample Mojang API not exists response (sometimes can be empty): {\"path\":\"/users/profiles/minecraft/someletters1234566\",\"errorMessage\":\"Couldn't find any profile with that name\"}",
      "Sample CloudFlare API not exists response: {\"code\":404,\"error\":\"Not Found\",\"reason\":\"No user with the name 'someletters123456' was found\"}",
      "",
      "Responses with an invalid scheme will be identified as responses with a server error",
      "Set this parameter to [], to disable JSON scheme validation"
    })
    public List<String> USER_EXISTS_JSON_VALIDATOR_FIELDS = List.of("name", "id");

    /** JSON field name containing the UUID in the premium check response. */
    public String JSON_UUID_FIELD = "id";

    /** JSON fields to validate in the response when a user does not exist (empty to disable). */
    public List<String> USER_NOT_EXISTS_JSON_VALIDATOR_FIELDS = List.of();

    /**
     * If true, players are treated as premium if Mojang API is rate-limited. If false, treated as
     * cracked.
     */
    @Comment({
      "If Mojang rate-limits your server, we cannot determine if the player is premium or not",
      "This option allows you to choose whether every player will be defined as premium or as cracked while Mojang is rate-limiting the server",
      "True - as premium; False - as cracked"
    })
    public boolean ON_RATE_LIMIT_PREMIUM = true;

    /**
     * If true, players are treated as premium if Mojang API is down. If false, treated as cracked.
     */
    @Comment({
      "If Mojang API is down, we cannot determine if the player is premium or not",
      "This option allows you to choose whether every player will be defined as premium or as cracked while Mojang API is unavailable",
      "True - as premium; False - as cracked"
    })
    public boolean ON_SERVER_ERROR_PREMIUM = true;

    /** Aliases for the register command. */
    public List<String> REGISTER_COMMAND = List.of("/r", "/reg", "/register");

    /** Aliases for the login command. */
    public List<String> LOGIN_COMMAND = List.of("/l", "/log", "/login");

    /** Aliases for the TOTP (2FA) command. */
    public List<String> TOTP_COMMAND = List.of("/2fa", "/totp");

    /** If true, new player registrations are disabled. */
    @Comment("New players will be kicked with registrations-disabled-kick message")
    public boolean DISABLE_REGISTRATIONS = false;

    /** Number of recovery codes generated for TOTP. */
    public int TOTP_RECOVERY_CODES_AMOUNT = 16;

    /** Settings related to the client-side mod integration. */
    @Create public Settings.MAIN.MOD MOD;

    /** Settings for client mod integration. See https://github.com/Elytrium/LimboAuth-ClientMod */
    @Comment({
      "Implement the automatic login using the plugin, the LimboAuth client mod and optionally using a custom launcher",
      "See https://github.com/Elytrium/LimboAuth-ClientMod"
    })
    public static class MOD {
      /** Whether to enable client mod integration features. */
      public boolean ENABLED = true;

      /** If true, players can only log in if they have the client mod installed. */
      @Comment("Should the plugin forbid logging in without a mod")
      public boolean LOGIN_ONLY_BY_MOD = false;

      /**
       * Verification key (MD5 hashed) for client mod communication, must match server hash issuer.
       */
      @Comment(
          "The key must be the same in the plugin config and in the server hash issuer, if you use it")
      @CustomSerializer(serializerClass = MD5KeySerializer.class)
      public byte[] VERIFY_KEY = null;
    }

    /** Coordinates for loading the custom world schematic/structure. */
    @Create public Settings.MAIN.WORLD_COORDS WORLD_COORDS;

    /** World coordinates for schematic/structure placement. */
    public static class WORLD_COORDS {
      /** X-coordinate for world placement. */
      public int X = 0;

      /** Y-coordinate for world placement. */
      public int Y = 0;

      /** Z-coordinate for world placement. */
      public int Z = 0;
    }

    /** Spawn coordinates for players in the authentication Limbo. */
    @Create public MAIN.AUTH_COORDS AUTH_COORDS;

    /** Authentication Limbo spawn coordinates and orientation. */
    public static class AUTH_COORDS {
      /** Spawn X-coordinate. */
      public double X = 0;

      /** Spawn Y-coordinate. */
      public double Y = 0;

      /** Spawn Z-coordinate. */
      public double Z = 0;

      /** Spawn Yaw (horizontal rotation). */
      public double YAW = 0;

      /** Spawn Pitch (vertical rotation). */
      public double PITCH = 0;
    }

    /** Title settings for cracked (non-premium) player authentication. */
    @Create public Settings.MAIN.CRACKED_TITLE_SETTINGS CRACKED_TITLE_SETTINGS;

    /** Title display settings for cracked player authentication. */
    public static class CRACKED_TITLE_SETTINGS {
      /** Fade-in time in ticks. */
      public int FADE_IN = 10;

      /** Stay time in ticks. */
      public int STAY = 70;

      /** Fade-out time in ticks. */
      public int FADE_OUT = 20;

      /** Whether to clear the title after successful login. */
      public boolean CLEAR_AFTER_LOGIN = false;

      /**
       * @return Title.Times object based on these settings.
       */
      public Title.Times toTimes() {
        return Title.Times.times(
            Ticks.duration(this.FADE_IN), Ticks.duration(this.STAY), Ticks.duration(this.FADE_OUT));
      }
    }

    /** Title settings for premium player auto-login. */
    @Create public Settings.MAIN.PREMIUM_TITLE_SETTINGS PREMIUM_TITLE_SETTINGS;

    /** Title display settings for premium player auto-login. */
    public static class PREMIUM_TITLE_SETTINGS {
      /** Fade-in time in ticks. */
      public int FADE_IN = 10;

      /** Stay time in ticks. */
      public int STAY = 70;

      /** Fade-out time in ticks. */
      public int FADE_OUT = 20;

      /**
       * @return Title.Times object based on these settings.
       */
      public Title.Times toTimes() {
        return Title.Times.times(
            Ticks.duration(this.FADE_IN), Ticks.duration(this.STAY), Ticks.duration(this.FADE_OUT));
      }
    }

    /** Settings for the backend API (e.g., for PlaceholderAPI expansion). */
    @Create public Settings.MAIN.BACKEND_API BACKEND_API;

    /** Backend API settings. */
    public static class BACKEND_API {
      /** Whether the backend API should be enabled. Required for PlaceholderAPI expansion. */
      @Comment({
        "Should backend API be enabled?",
        "Required for PlaceholderAPI expansion to work (https://github.com/UserNugget/LimboAuth-Expansion)"
      })
      public boolean ENABLED = false;

      /** Token for authenticating backend API requests. */
      @Comment("Backend API token")
      public String TOKEN = Long.toString(ThreadLocalRandom.current().nextLong(Long.MAX_VALUE), 36);

      /** List of enabled backend API endpoints. */
      @Comment({
        "Available endpoints:",
        " premium_state, hash, totp_token, login_date, reg_date, token_issued_at,",
        " uuid, premium_uuid, ip, login_ip, token_issued_at"
      })
      public List<String> ENABLED_ENDPOINTS =
          List.of(
              "premium_state", "login_date", "reg_date", "uuid", "premium_uuid", "token_issued_at");
    }

    /** Permission states for various plugin commands. */
    @Create public MAIN.COMMAND_PERMISSION_STATE COMMAND_PERMISSION_STATE;

    /**
     * Defines permission states for commands (FALSE, TRUE, PERMISSION). FALSE: Command disallowed.
     * TRUE: Command allowed if player has false permission state (effectively public). PERMISSION:
     * Command allowed if player has true permission state (requires specific permission node).
     */
    @Comment({
      "Available values: FALSE, TRUE, PERMISSION",
      " FALSE - the command will be disallowed",
      " TRUE - the command will be allowed if player has false permission state",
      " PERMISSION - the command will be allowed if player has true permission state"
    })
    public static class COMMAND_PERMISSION_STATE {
      /** Permission for /changepassword: limboauth.commands.changepassword */
      @Comment("Permission: limboauth.commands.changepassword")
      public CommandPermissionState CHANGE_PASSWORD = CommandPermissionState.PERMISSION;

      /** Permission for /destroysession: limboauth.commands.destroysession */
      @Comment("Permission: limboauth.commands.destroysession")
      public CommandPermissionState DESTROY_SESSION = CommandPermissionState.PERMISSION;

      /** Permission for /premium: limboauth.commands.premium */
      @Comment("Permission: limboauth.commands.premium")
      public CommandPermissionState PREMIUM = CommandPermissionState.PERMISSION;

      /** Permission for /totp: limboauth.commands.totp */
      @Comment("Permission: limboauth.commands.totp")
      public CommandPermissionState TOTP = CommandPermissionState.PERMISSION;

      /** Permission for /unregister: limboauth.commands.unregister */
      @Comment("Permission: limboauth.commands.unregister")
      public CommandPermissionState UNREGISTER = CommandPermissionState.PERMISSION;

      /** Permission for /forcechangepassword: limboauth.admin.forcechangepassword */
      @Comment("Permission: limboauth.admin.forcechangepassword")
      public CommandPermissionState FORCE_CHANGE_PASSWORD = CommandPermissionState.PERMISSION;

      /** Permission for /forceregister: limboauth.admin.forceregister */
      @Comment("Permission: limboauth.admin.forceregister")
      public CommandPermissionState FORCE_REGISTER = CommandPermissionState.PERMISSION;

      /** Permission for /forcelogin: limboauth.admin.forcelogin */
      @Comment("Permission: limboauth.admin.forcelogin")
      public CommandPermissionState FORCE_LOGIN = CommandPermissionState.PERMISSION;

      /** Permission for /forceunregister: limboauth.admin.forceunregister */
      @Comment("Permission: limboauth.admin.forceunregister")
      public CommandPermissionState FORCE_UNREGISTER = CommandPermissionState.PERMISSION;

      /** Permission for /limboauth reload: limboauth.admin.reload */
      @Comment("Permission: limboauth.admin.reload")
      public CommandPermissionState RELOAD = CommandPermissionState.PERMISSION;

      /** Permission for /limboauth help: limboauth.admin.help (or general help access) */
      @Comment("Permission: limboauth.admin.help")
      public CommandPermissionState HELP = CommandPermissionState.TRUE;
    }

    /** Localized strings used by the this.plugin. */
    @Create public MAIN.STRINGS STRINGS;

    /**
     * Contains all translatable messages used by the this.plugin. Use {PRFX} for prefix and {NL}
     * for newline. Placeholders like {0}, {1} are replaced by command arguments or context.
     */
    public static class STRINGS {
      public String RELOAD = "{PRFX} &aReloaded successfully!";
      public String ERROR_OCCURRED = "{PRFX} &cAn internal error has occurred!";
      public String RATELIMITED = "{PRFX} &cPlease wait before next usage!";
      public String DATABASE_ERROR_KICK = "{PRFX} &cA database error has occurred!";
      public String NOT_PLAYER = "{PRFX} &cConsole is not allowed to execute this command!";
      public String NOT_REGISTERED =
          "{PRFX} &cYou are not registered or your account is &6PREMIUM!";
      public String CRACKED_COMMAND =
          "{PRFX}{NL}&aYou can not use this command since your account is &6PREMIUM&a!";
      public String WRONG_PASSWORD = "{PRFX} &cPassword is wrong!";
      public String PASSWORD_SAME_AS_OLD =
          "{PRFX} &cYour new password cannot be the same as your old password.";
      public String NICKNAME_INVALID_KICK =
          "{PRFX}{NL}&cYour nickname contains forbidden characters. Please, change your nickname!";
      public String RECONNECT_KICK = "{PRFX}{NL}&cReconnect to the server to verify your account!";

      @Comment("6 hours by default in ip-limit-valid-time")
      public String IP_LIMIT_KICK =
          "{PRFX}{NL}{NL}&cYour IP has reached max registered accounts. If this is an error, restart your router, or wait about 6 hours.";

      public String WRONG_NICKNAME_CASE_KICK =
          "{PRFX}{NL}&cYou should join using username &6{0}&c, not &6{1}&c.";
      public String BOSSBAR = "{PRFX} You have &6{0} &fseconds left to log in.";
      public String TIMES_UP = "{PRFX}{NL}&cAuthorization time is up.";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String LOGIN_PREMIUM =
          "{PRFX} You've been logged in automatically using the premium account!";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String LOGIN_PREMIUM_TITLE = "{PRFX} Welcome!";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String LOGIN_PREMIUM_SUBTITLE = "&aYou have been logged in as premium player!";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String LOGIN_FLOODGATE =
          "{PRFX} You've been logged in automatically using the bedrock account!";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String LOGIN_FLOODGATE_TITLE = "{PRFX} Welcome!";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String LOGIN_FLOODGATE_SUBTITLE = "&aYou have been logged in as bedrock player!";

      public String LOGIN =
          "{PRFX} &aPlease, login using &6/login <password>&a, you have &6{0} &aattempts.";
      public String LOGIN_WRONG_PASSWORD =
          "{PRFX} &cYou've entered the wrong password, you have &6{0} &cattempts left.";
      public String LOGIN_WRONG_PASSWORD_KICK =
          "{PRFX}{NL}&cYou've entered the wrong password numerous times!";
      public String LOGIN_SUCCESSFUL = "{PRFX} &aSuccessfully logged in!";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String LOGIN_TITLE = "&fPlease, login using &6/login <password>&a.";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String LOGIN_SUBTITLE = "&aYou have &6{0} &aattempts.";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String LOGIN_SUCCESSFUL_TITLE = "{PRFX}";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String LOGIN_SUCCESSFUL_SUBTITLE = "&aSuccessfully logged in!";

      @Comment(
          "Or if register-need-repeat-password set to false remove the \"<repeat password>\" part.")
      public String REGISTER =
          "{PRFX} Please, register using &6/register <password> <repeat password>";

      public String REGISTER_DIFFERENT_PASSWORDS =
          "{PRFX} &cThe entered passwords differ from each other!";
      public String REGISTER_PASSWORD_TOO_SHORT =
          "{PRFX} &cYou entered a too short password, use a different one!";
      public String REGISTER_PASSWORD_TOO_LONG =
          "{PRFX} &cYou entered a too long password, use a different one!";
      public String REGISTER_PASSWORD_UNSAFE =
          "{PRFX} &cYour password is unsafe, use a different one!";
      public String REGISTER_SUCCESSFUL = "{PRFX} &aSuccessfully registered!";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String REGISTER_TITLE = "{PRFX}";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String REGISTER_SUBTITLE =
          "&aPlease, register using &6/register <password> <repeat password>";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String REGISTER_SUCCESSFUL_TITLE = "{PRFX}";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String REGISTER_SUCCESSFUL_SUBTITLE = "&aSuccessfully registered!";

      public String UNREGISTER_SUCCESSFUL = "{PRFX}{NL}&aSuccessfully unregistered!";
      public String UNREGISTER_USAGE = "{PRFX} Usage: &6/unregister <current password> confirm";
      public String PREMIUM_SUCCESSFUL =
          "{PRFX}{NL}&aSuccessfully changed account state to &6PREMIUM&a!";
      public String ALREADY_PREMIUM = "{PRFX} &cYour account is already &6PREMIUM&c!";
      public String NOT_PREMIUM = "{PRFX} &cYour account is not &6PREMIUM&c!";
      public String PREMIUM_USAGE = "{PRFX} Usage: &6/premium <current password> confirm";
      public String EVENT_CANCELLED = "{PRFX} Authorization event was cancelled";
      public String FORCE_UNREGISTER_SUCCESSFUL = "{PRFX} &6{0} &asuccessfully unregistered!";
      public String FORCE_UNREGISTER_KICK =
          "{PRFX}{NL}&aYou have been unregistered by an administrator!";
      public String FORCE_UNREGISTER_NOT_SUCCESSFUL =
          "{PRFX} &cUnable to unregister &6{0}&c. Most likely this player has never been on this this.server.";
      public String FORCE_UNREGISTER_USAGE = "{PRFX} Usage: &6/forceunregister <nickname>";
      public String REGISTRATIONS_DISABLED_KICK = "{PRFX} Registrations are currently disabled.";
      public String CHANGE_PASSWORD_SUCCESSFUL = "{PRFX} &aSuccessfully changed password!";

      @Comment(
          "Or if change-password-need-old-pass set to false remove the \"<old password>\" part.")
      public String CHANGE_PASSWORD_USAGE =
          "{PRFX} Usage: &6/changepassword <old password> <new password>";

      public String FORCE_CHANGE_PASSWORD_SUCCESSFUL =
          "{PRFX} &aSuccessfully changed password for player &6{0}&a!";
      public String FORCE_CHANGE_PASSWORD_MESSAGE =
          "{PRFX} &aYour password has been changed to &6{0} &aby an administator!";
      public String FORCE_CHANGE_PASSWORD_NOT_SUCCESSFUL =
          "{PRFX} &cUnable to change password for &6{0}&c. Most likely this player has never been on this this.server.";
      public String FORCE_CHANGE_PASSWORD_NOT_REGISTERED =
          "{PRFX} &cPlayer &6{0}&c is not registered.";
      public String PLAYER_IS_PREMIUM_NO_PASS_CHANGE =
          "{PRFX} &cPlayer &6{0}&c is a premium account and does not use a password here.";
      public String FORCE_CHANGE_PASSWORD_USAGE =
          "{PRFX} Usage: &6/forcechangepassword <nickname> <new password>";
      public String FORCE_REGISTER_USAGE = "{PRFX} Usage: &6/forceregister <nickname> <password>";
      public String FORCE_REGISTER_INCORRECT_NICKNAME =
          "{PRFX} &cNickname contains forbidden characters.";
      public String FORCE_REGISTER_TAKEN_NICKNAME = "{PRFX} &cThis nickname is already taken.";
      public String FORCE_REGISTER_SUCCESSFUL = "{PRFX} &aSuccessfully registered player &6{0}&a!";
      public String FORCE_REGISTER_NOT_SUCCESSFUL = "{PRFX} &cUnable to register player &6{0}&c.";
      public String FORCE_LOGIN_USAGE = "{PRFX} Usage: &6/forcelogin <nickname>";
      public String FORCE_LOGIN_SUCCESSFUL = "{PRFX} &aSuccessfully authenticated &6{0}&a!";
      public String FORCE_LOGIN_UNKNOWN_PLAYER =
          "{PRFX} &cUnable to find authenticating player with username &6{0}&a!";
      public String TOTP = "{PRFX} Please, enter your 2FA key using &6/2fa <key>";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String TOTP_TITLE = "{PRFX}";

      /** Can be empty. */
      @Comment(value = "Can be empty.", at = Comment.At.SAME_LINE)
      public String TOTP_SUBTITLE = "&aEnter your 2FA key using &6/2fa <key>";

      public String TOTP_SUCCESSFUL = "{PRFX} &aSuccessfully enabled 2FA!";
      public String TOTP_DISABLED = "{PRFX} &aSuccessfully disabled 2FA!";
      public String TOTP_NOT_ENABLED =
          "{PRFX} &cTwo-factor authentication is not enabled for your account.";

      @Comment("Or if totp-need-pass set to false remove the \"<current password>\" part.")
      public String TOTP_USAGE =
          "{PRFX} Usage: &6/2fa enable <current password>&f or &6/2fa disable <totp key>&f.";

      public String TOTP_WRONG = "{PRFX} &cWrong 2FA key!";
      public String TOTP_ALREADY_ENABLED =
          "{PRFX} &c2FA is already enabled. Disable it using &6/2fa disable <key>&c.";
      public String TOTP_QR = "{PRFX} Click here to open 2FA QR code in browser.";
      public String TOTP_TOKEN = "{PRFX} &aYour 2FA token &7(Click to copy)&a: &6{0}";
      public String TOTP_RECOVERY = "{PRFX} &aYour recovery codes &7(Click to copy)&a: &6{0}";
      public String DESTROY_SESSION_SUCCESSFUL =
          "{PRFX} &eYour session is now destroyed, you'll need to log in again after reconnecting.";
      public String MOD_SESSION_EXPIRED = "{PRFX} Your session has expired, log in again.";
      public String MOJANG_API_RATE_LIMITED =
          "{PRFX} &cMojang API is currently rate limited. Please try again later.";
      public String MOJANG_API_ERROR =
          "{PRFX} &cCould not verify premium status due to an API error.";
    }
  }

  /** Database configuration section. */
  @Create public DATABASE DATABASE;

  /** Database connection settings. */
  @Comment("Database settings")
  /** Database configuration settings. */
  /** Database configuration settings. */
  public static class DATABASE {
    /** Database type (mariadb, mysql, postgresql, sqlite, h2). */
    @Comment("Database type: mariadb, mysql, postgresql, sqlite or h2.")
    public DatabaseLibrary STORAGE_TYPE = DatabaseLibrary.H2;

    /** Hostname and port for network-based databases (e.g., 127.0.0.1:3306). */
    @Comment("Settings for Network-based database (like MySQL, PostgreSQL): ")
    public String HOSTNAME = "127.0.0.1:3306";

    /** Username for database connection. */
    public String USER = "user";

    /** Password for database connection. */
    public String PASSWORD = "password";

    /** Name of the database/schema. */
    public String DATABASE = "limboauth";

    /** Additional JDBC connection parameters (e.g., ?autoReconnect=true). */
    public String CONNECTION_PARAMETERS = "?autoReconnect=true&initialTimeout=1&useSSL=false";
  }

  /**
   * Custom serializer for MD5 hashing a string key, used for client mod verification. Generates a
   * random string if the original value is empty.
   */
  public static class MD5KeySerializer extends ConfigSerializer<byte[], String> {

    private final MessageDigest md5;
    private final Random random;
    private String originalValue;

    /**
     * Constructs the MD5KeySerializer.
     *
     * @throws NoSuchAlgorithmException if MD5 algorithm is not available.
     */
    @SuppressFBWarnings("CT_CONSTRUCTOR_THROW")
    public MD5KeySerializer() throws NoSuchAlgorithmException {
      super(byte[].class, String.class);
      this.md5 = MessageDigest.getInstance("MD5");
      this.random = new SecureRandom();
    }

    @Override
    public String serialize(byte[] from) {
      if (this.originalValue == null || this.originalValue.isEmpty()) {
        this.originalValue = generateRandomString(24);
      }
      return this.originalValue;
    }

    @Override
    public byte[] deserialize(String from) {
      this.originalValue = from;
      return this.md5.digest(from.getBytes(StandardCharsets.UTF_8));
    }

    private String generateRandomString(int length) {
      String chars = "AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz1234567890";
      StringBuilder builder = new StringBuilder();
      for (int i = 0; i < length; i++) {
        builder.append(chars.charAt(this.random.nextInt(chars.length())));
      }
      return builder.toString();
    }
  }
}

```

`src/main/java/net/elytrium/limboauth/backend/Endpoint.java`:

```java
package net.elytrium.limboauth.backend;

import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteArrayDataOutput;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.service.ConfigManager;

/**
 * Abstract base class for backend API endpoints. Handles common serialization logic for endpoint
 * requests and responses.
 */
public abstract class Endpoint {

  /** The main LimboAuth plugin instance. */
  protected final LimboAuth plugin;

  /** The endpoint type identifier. */
  protected String type;

  /** The username for this endpoint request. */
  protected String
      username; // Uczyniono protected dla łatwiejszego dostępu w podklasach lub listenerze

  /**
   * Constructs an Endpoint.
   *
   * @param plugin The main LimboAuth plugin instance.
   */
  /** Default constructor. */
  public Endpoint(LimboAuth plugin) {
    this.plugin = plugin;
  }

  /**
   * Constructs an Endpoint with a specific type and username.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param type The type identifier of this endpoint.
   * @param username The username this endpoint pertains to.
   */
  /** Default constructor. */
  public Endpoint(LimboAuth plugin, String type, String username) {
    this.plugin = plugin;
    this.type = type;
    this.username = username;
  }

  /**
   * Sets the username for this endpoint. Used by {@link
   * net.elytrium.limboauth.listener.BackendEndpointsListener} after initial parsing of the request.
   *
   * @param username The username.
   */
  public void setUsername(String username) {
    this.username = username;
  }

  /**
   * Writes the endpoint data to the provided output stream. This includes common header information
   * like type, version, token, and username, followed by endpoint-specific content written by
   * {@link #writeContents(ByteArrayDataOutput)}.
   *
   * @param output The output stream to write to.
   */
  public void write(ByteArrayDataOutput output) {
    ConfigManager configManager = this.plugin.getConfigManager(); // Pobierz ConfigManager
    output.writeUTF(this.type);
    // Użyj configManager do dostępu do settings
    if (!this.type.equals("available_endpoints")
        && !configManager.getSettings().MAIN.BACKEND_API.ENABLED_ENDPOINTS.contains(this.type)) {
      output.writeInt(-1); // Endpoint not enabled
      output.writeUTF(this.username != null ? this.username : ""); // Ensure username is not null
      return;
    }

    output.writeInt(1); // Version of the data structure
    output.writeUTF(configManager.getSettings().MAIN.BACKEND_API.TOKEN);
    output.writeUTF(this.username != null ? this.username : ""); // Ensure username is not null
    this.writeContents(output);
  }

  /**
   * Reads endpoint-specific data from the provided input stream. The common header (type, username)
   * is typically read by the listener before this method is called. This method should be
   * implemented by subclasses if they expect additional data in the request.
   *
   * @param input The input stream to read from.
   */
  public void read(ByteArrayDataInput input) {
    // Wersja i nazwa użytkownika są już odczytane przez BackendEndpointsListener
    // Ta metoda powinna czytać tylko *dodatkowe* dane, jeśli endpoint ich oczekuje.
    // Dla większości obecnych endpointów, ta metoda będzie pusta lub będzie rzucać
    // UnsupportedOperationException,
    // ponieważ wszystkie potrzebne dane (username) są już ustawione.
    // Jeśli jakiś endpoint potrzebuje więcej danych z plugin message, zaimplementuje to tutaj.
    this.readContents(input);
  }

  /**
   * Abstract method for subclasses to write their specific content to the output stream.
   *
   * @param output The output stream to write to.
   */
  public abstract void writeContents(ByteArrayDataOutput output);

  /**
   * Abstract method for subclasses to read their specific content from the input stream.
   *
   * @param input The input stream to read from.
   */
  public abstract void readContents(ByteArrayDataInput input); // Do odczytu dodatkowych danych
}

```

`src/main/java/net/elytrium/limboauth/backend/type/LongDatabaseEndpoint.java`:

```java
package net.elytrium.limboauth.backend.type;

import java.util.function.Function;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.service.DatabaseService;
import org.slf4j.Logger;

/**
 * An endpoint that retrieves a long value from the database for a specific player. The value is
 * determined by the provided dataExtractor function.
 */
public class LongDatabaseEndpoint extends LongEndpoint {
  private final DatabaseService databaseService;
  private final Logger logger;

  /**
   * Constructs a LongDatabaseEndpoint. It fetches player data from the database and applies the
   * dataExtractor to get the long value. If the player is not found or an error occurs, {@link
   * Long#MIN_VALUE} is set.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param type The type identifier of this endpoint.
   * @param username The username of the player to fetch data for.
   * @param dataExtractor A function to extract the long value from a {@link RegisteredPlayer}
   *     object.
   */
  public LongDatabaseEndpoint(
      LimboAuth plugin,
      String type,
      String username,
      Function<RegisteredPlayer, Long> dataExtractor) {
    super(plugin, type, username, 0L); // Wywołaj konstruktor klasy bazowej
    this.databaseService = this.plugin.getDatabaseService();
    this.logger = this.plugin.getLogger();

    RegisteredPlayer player =
        this.databaseService.findPlayerByLowercaseNickname(username.toLowerCase());
    if (player == null) {
      this.setValue(Long.MIN_VALUE); // Użyj settera z klasy bazowej
      this.logger.debug("LongDatabaseEndpoint: Player {} not found for type {}.", username, type);
    } else {
      try {
        this.setValue(dataExtractor.apply(player)); // Użyj settera z klasy bazowej
      } catch (Exception e) {
        this.logger.error(
            "LongDatabaseEndpoint: Error extracting data for player {} type {}:",
            username,
            type,
            e);
        this.setValue(Long.MIN_VALUE); // Użyj settera z klasy bazowej
      }
    }
  }
}

```

`src/main/java/net/elytrium/limboauth/backend/type/LongEndpoint.java`:

```java
package net.elytrium.limboauth.backend.type;

import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteArrayDataOutput;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.backend.Endpoint;

/**
 * An endpoint that represents a long value. This can be used for predefined long values or as a
 * base for database-driven long values.
 */
public class LongEndpoint extends Endpoint {

  /** The long value stored by this endpoint. */
  protected long value; // Zmieniono na protected

  /**
   * Constructs a LongEndpoint with a predefined value.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param type The type identifier of this endpoint.
   * @param username The username this endpoint pertains to.
   * @param value The long value for this endpoint.
   */
  /** Default constructor. */
  public LongEndpoint(LimboAuth plugin, String type, String username, long value) {
    super(plugin, type, username);
    this.value = value;
  }

  /**
   * Writes the long value to the output stream.
   *
   * @param output The output stream to write to.
   */
  @Override
  public void writeContents(ByteArrayDataOutput output) {
    output.writeLong(this.value);
  }

  /**
   * Reads content for the LongEndpoint. For basic LongEndpoints, this is typically empty as the
   * value is set at construction.
   *
   * @param input The input stream to read from.
   */
  @Override
  public void readContents(ByteArrayDataInput input) {
    // Zwykle puste dla LongEndpoint, chyba że dane są przekazywane dodatkowo.
    // Jeśli `function` byłoby używane, to tutaj: this.value = this.function.apply(this.username);
    // Ale w obecnej strukturze, wartość jest ustawiana przez konstruktor lub LongDatabaseEndpoint.
  }

  /**
   * Sets the long value for this endpoint.
   *
   * @param value The new long value.
   */
  protected void setValue(long value) {
    this.value = value;
  }

  /**
   * Returns a string representation of the LongEndpoint.
   *
   * @return A string representation including username and value.
   */
  @Override
  public String toString() {
    return "LongEndpoint{" + "username='" + this.username + '\'' + ", value=" + this.value + '}';
  }
}

```

`src/main/java/net/elytrium/limboauth/backend/type/StringDatabaseEndpoint.java`:

```java
package net.elytrium.limboauth.backend.type;

import java.util.function.Function;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.service.DatabaseService;
import org.slf4j.Logger;

/**
 * An endpoint that retrieves a string value from the database for a specific player. The value is
 * determined by the provided dataExtractor function.
 */
public class StringDatabaseEndpoint extends StringEndpoint {
  private final DatabaseService databaseService;
  private final Logger logger;

  /**
   * Constructs a StringDatabaseEndpoint. It fetches player data from the database and applies the
   * dataExtractor to get the string value. If the player is not found or an error occurs, an empty
   * string is set.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param type The type identifier of this endpoint.
   * @param username The username of the player to fetch data for.
   * @param dataExtractor A function to extract the string value from a {@link RegisteredPlayer}
   *     object.
   */
  public StringDatabaseEndpoint(
      LimboAuth plugin,
      String type,
      String username,
      Function<RegisteredPlayer, String> dataExtractor) {
    super(plugin, type, username, ""); // Wywołaj konstruktor klasy bazowej
    this.databaseService = this.plugin.getDatabaseService();
    this.logger = this.plugin.getLogger();

    RegisteredPlayer player =
        this.databaseService.findPlayerByLowercaseNickname(username.toLowerCase());
    if (player == null) {
      this.setValue(""); // Użyj settera z klasy bazowej
      this.logger.debug("StringDatabaseEndpoint: Player {} not found for type {}.", username, type);
    } else {
      try {
        this.setValue(dataExtractor.apply(player)); // Użyj settera z klasy bazowej
      } catch (Exception e) {
        this.logger.error(
            "StringDatabaseEndpoint: Error extracting data for player {} type {}:",
            username,
            type,
            e);
        this.setValue(""); // Użyj settera z klasy bazowej
      }
    }
  }
}

```

`src/main/java/net/elytrium/limboauth/backend/type/StringEndpoint.java`:

```java
package net.elytrium.limboauth.backend.type;

import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteArrayDataOutput;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.backend.Endpoint;

/**
 * Represents an endpoint that handles a string value. This class can be used directly for
 * predefined string values or as a base for endpoints that fetch string data from other sources
 * (e.g., database).
 */
public class StringEndpoint extends Endpoint {

  protected String value; // Zmieniono na protected

  // Usunięto nieużywane pole 'function'

  /**
   * Constructs a StringEndpoint with a predefined value.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param type The type identifier of this endpoint.
   * @param username The username this endpoint pertains to.
   * @param value The string value for this endpoint.
   */
  /** Default constructor. */
  public StringEndpoint(LimboAuth plugin, String type, String username, String value) {
    super(plugin, type, username);
    this.value = value;
  }

  /**
   * Writes the string value to the output stream. Ensures that a null value is written as an empty
   * string.
   *
   * @param output The output stream to write to.
   */
  @Override
  public void writeContents(ByteArrayDataOutput output) {
    output.writeUTF(this.value != null ? this.value : ""); // Upewnij się, że nie jest null
  }

  /**
   * Reads content for the StringEndpoint. For basic StringEndpoints, this is typically empty as the
   * value is set at construction or by a subclass like {@link StringDatabaseEndpoint}.
   *
   * @param input The input stream to read from.
   */
  @Override
  public void readContents(ByteArrayDataInput input) {
    // Podobnie jak w LongEndpoint, wartość jest ustawiana przez konstruktor lub
    // StringDatabaseEndpoint.
  }

  /**
   * Sets the string value for this endpoint.
   *
   * @param value The new string value.
   */
  protected void setValue(String value) {
    this.value = value;
  }

  /**
   * Returns a string representation of the StringEndpoint.
   *
   * @return A string representation including username and value.
   */
  @Override
  public String toString() {
    return "StringEndpoint{" + "username='" + this.username + '\'' + ", value=" + this.value + '}';
  }
}

```

`src/main/java/net/elytrium/limboauth/backend/type/UnknownEndpoint.java`:

```java
package net.elytrium.limboauth.backend.type;

import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteArrayDataOutput;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.backend.Endpoint;

/**
 * Represents an endpoint that is not recognized or supported by the backend API. This class is used
 * to send a specific error code back to the requester indicating an unknown endpoint type.
 */
public class UnknownEndpoint extends Endpoint {

  private String type;

  /**
   * Constructs an UnknownEndpoint without a specific type. This constructor is typically used when
   * the type cannot be determined.
   *
   * @param plugin The main LimboAuth plugin instance.
   */
  /** Default constructor. */
  public UnknownEndpoint(LimboAuth plugin) {
    super(plugin);
  }

  /**
   * Constructs an UnknownEndpoint with a specific type.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param type The type identifier of the unknown endpoint.
   */
  /** Default constructor. */
  public UnknownEndpoint(LimboAuth plugin, String type) {
    super(plugin);
    this.type = type;
  }

  /**
   * Writes a response indicating an unknown endpoint. The response includes the original type
   * requested and an error code (-2).
   *
   * @param output The output stream to write to.
   */
  @Override
  public void write(ByteArrayDataOutput output) {
    output.writeUTF(this.type != null ? this.type : "unknown"); // Ensure type is not null
    output.writeInt(-2); // Error code for unknown endpoint
  }

  /**
   * Reading is not supported for UnknownEndpoint as it's a response-only type.
   *
   * @param input The input stream (unused).
   * @throws UnsupportedOperationException always.
   */
  @Override
  public void read(ByteArrayDataInput input) {
    throw new UnsupportedOperationException("Cannot read data for an UnknownEndpoint.");
  }

  /**
   * Writing specific contents is not supported for UnknownEndpoint. The main {@link
   * #write(ByteArrayDataOutput)} method handles the entire response.
   *
   * @param output The output stream (unused).
   * @throws UnsupportedOperationException always.
   */
  @Override
  public void writeContents(ByteArrayDataOutput output) {
    throw new UnsupportedOperationException(
        "UnknownEndpoint does not have specific contents to write.");
  }

  /**
   * Reading specific contents is not supported for UnknownEndpoint.
   *
   * @param input The input stream (unused).
   * @throws UnsupportedOperationException always.
   */
  @Override
  public void readContents(ByteArrayDataInput input) {
    throw new UnsupportedOperationException(
        "UnknownEndpoint does not have specific contents to read.");
  }

  /**
   * Returns a string representation of the UnknownEndpoint.
   *
   * @return A string representation including the type.
   */
  @Override
  public String toString() {
    return "UnknownEndpoint{" + "type='" + (this.type != null ? this.type : "unknown") + '\'' + '}';
  }
}

```

`src/main/java/net/elytrium/limboauth/command/ChangePasswordCommand.java`:

```java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import com.velocitypowered.api.proxy.Player;
import java.util.Locale;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.event.ChangePasswordEvent;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.model.SQLRuntimeException;
import net.elytrium.limboauth.service.AuthenticationService;
import net.elytrium.limboauth.service.CacheManager;
import net.elytrium.limboauth.service.ConfigManager;
import net.elytrium.limboauth.service.DatabaseService;
import net.kyori.adventure.text.Component;
import org.slf4j.Logger;

/**
 * Command for players to change their own password. Handles checks for registration, current
 * password (if configured), new password validity, and updates the database and cache.
 */
public class ChangePasswordCommand extends RatelimitedCommand {

  private final LimboAuth plugin; // For event firing and logger
  private final Logger logger;
  private final DatabaseService databaseService;
  private final AuthenticationService authenticationService;
  private final CacheManager cacheManager;
  // ConfigManager is available via super.configManager

  private final boolean needOldPassConfigValue;

  /**
   * Constructs the ChangePasswordCommand.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param databaseService Service for database interactions.
   * @param authenticationService Service for authentication logic.
   * @param cacheManager Service for managing caches.
   * @param configManager Service for accessing configuration.
   */
  public ChangePasswordCommand(
      LimboAuth plugin,
      DatabaseService databaseService,
      AuthenticationService authenticationService,
      CacheManager cacheManager,
      ConfigManager configManager) {
    super(configManager);
    this.plugin = plugin;
    this.logger = this.plugin.getLogger();
    this.databaseService = databaseService;
    this.authenticationService = authenticationService;
    this.cacheManager = cacheManager;
    this.needOldPassConfigValue =
        this.configManager.getSettings().MAIN.CHANGE_PASSWORD_NEED_OLD_PASSWORD;
  }

  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    if (!(source instanceof Player)) {
      source.sendMessage(
          configManager
              .getSerializer()
              .deserialize(configManager.getSettings().MAIN.STRINGS.NOT_PLAYER));
      return;
    }

    Player commandPlayer = (Player) source;
    Settings currentSettings = this.configManager.getSettings();
    Serializer currentSerializer = this.configManager.getSerializer();

    final Component notRegisteredMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.NOT_REGISTERED);
    final Component wrongPasswordMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.WRONG_PASSWORD);
    final Component successfulMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.CHANGE_PASSWORD_SUCCESSFUL);
    final Component errorOccurredMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.ERROR_OCCURRED);
    final Component usageMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.CHANGE_PASSWORD_USAGE);
    final Component crackedCommandMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.CRACKED_COMMAND);
    final Component passTooShortMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTER_PASSWORD_TOO_SHORT);
    final Component passTooLongMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTER_PASSWORD_TOO_LONG);
    final Component passUnsafeMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTER_PASSWORD_UNSAFE);
    // Assuming PASSWORD_SAME_AS_OLD is added to Settings.java -> MAIN.STRINGS
    final Component passSameAsOldMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.PASSWORD_SAME_AS_OLD);

    String usernameLowercase = commandPlayer.getUsername().toLowerCase(Locale.ROOT);
    RegisteredPlayer registeredPlayer =
        this.databaseService.findPlayerByLowercaseNickname(usernameLowercase);

    if (registeredPlayer == null) {
      source.sendMessage(notRegisteredMsg);
      return;
    }

    if (registeredPlayer.getHash().isEmpty()) { // Premium accounts cannot use this
      source.sendMessage(crackedCommandMsg);
      return;
    }

    boolean effectivelyNeedOldPass = this.needOldPassConfigValue;
    int expectedArgs = effectivelyNeedOldPass ? 2 : 1;

    if (args.length < expectedArgs) {
      source.sendMessage(usageMsg);
      return;
    }

    String oldPasswordAttempt = effectivelyNeedOldPass ? args[0] : null;
    String newPassword = effectivelyNeedOldPass ? args[1] : args[0];

    if (effectivelyNeedOldPass) {
      if (oldPasswordAttempt == null
          || !authenticationService.checkPassword(oldPasswordAttempt, registeredPlayer)) {
        source.sendMessage(wrongPasswordMsg);
        return;
      }
      if (oldPasswordAttempt.equals(newPassword)) {
        source.sendMessage(passSameAsOldMsg);
        return;
      }
    }

    if (newPassword.length() < currentSettings.MAIN.MIN_PASSWORD_LENGTH) {
      source.sendMessage(passTooShortMsg);
      return;
    }
    if (newPassword.length() > currentSettings.MAIN.MAX_PASSWORD_LENGTH) {
      source.sendMessage(passTooLongMsg);
      return;
    }
    if (currentSettings.MAIN.CHECK_PASSWORD_STRENGTH
        && this.configManager.unsafePasswords.contains(newPassword)) {
      source.sendMessage(passUnsafeMsg);
      return;
    }

    try {
      final String oldActualHash = registeredPlayer.getHash();
      registeredPlayer.setPassword(newPassword); // Hashes and updates tokenIssuedAt
      this.databaseService.updatePlayer(registeredPlayer);

      this.cacheManager.removeAuthUserFromCache(commandPlayer.getUsername());

      this.plugin
          .getServer()
          .getEventManager()
          .fireAndForget(
              new ChangePasswordEvent(
                  registeredPlayer,
                  oldPasswordAttempt,
                  oldActualHash,
                  newPassword,
                  registeredPlayer.getHash()));

      source.sendMessage(successfulMsg);
    } catch (SQLRuntimeException e) {
      this.logger.error("SQL error changing password for {}:", commandPlayer.getUsername(), e);
      source.sendMessage(errorOccurredMsg);
    } catch (Exception e) {
      this.logger.error(
          "Unexpected error changing password for {}:", commandPlayer.getUsername(), e);
      source.sendMessage(errorOccurredMsg);
    }
  }

  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    return super.configManager
        .getCommandPermissionState()
        .CHANGE_PASSWORD
        .hasPermission(invocation.source(), "limboauth.commands.changepassword");
  }
}

```

`src/main/java/net/elytrium/limboauth/command/CommandPermissionState.java`:

```java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.permission.PermissionSubject;
import com.velocitypowered.api.permission.Tristate;
import java.util.function.BiFunction;

/**
 * Enum representing the permission state for a command. This determines how command access is
 * checked based on configuration and player permissions.
 */
public enum CommandPermissionState {
  /** Command is always disallowed. */
  FALSE((source, permission) -> false),
  /**
   * Command is allowed if the player does not have the permission set to false (effectively
   * public).
   */
  TRUE((source, permission) -> source.getPermissionValue(permission) != Tristate.FALSE),
  /** Command is allowed only if the player explicitly has the specified permission. */
  PERMISSION(PermissionSubject::hasPermission);

  private final BiFunction<PermissionSubject, String, Boolean> hasPermissionFunction;

  CommandPermissionState(BiFunction<PermissionSubject, String, Boolean> hasPermissionFunction) {
    this.hasPermissionFunction = hasPermissionFunction;
  }

  /**
   * Checks if the given {@link PermissionSubject} has permission according to this state.
   *
   * @param permissionSubject The subject (e.g., player or console) to check.
   * @param permission The permission string to check against if state is {@code PERMISSION}.
   * @return {@code true} if the subject has permission, {@code false} otherwise.
   */
  public boolean hasPermission(PermissionSubject permissionSubject, String permission) {
    return this.hasPermissionFunction.apply(permissionSubject, permission);
  }
}

```

`src/main/java/net/elytrium/limboauth/command/DestroySessionCommand.java`:

```java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import com.velocitypowered.api.proxy.Player;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.service.CacheManager;
import net.elytrium.limboauth.service.ConfigManager;
import net.kyori.adventure.text.Component;

/**
 * Command for players to destroy their current authenticated session. This forces them to log in
 * again upon their next connection or action requiring authentication.
 */
public class DestroySessionCommand extends RatelimitedCommand {

  private final CacheManager cacheManager;

  // ConfigManager is available via super.configManager

  /**
   * Constructs the DestroySessionCommand.
   *
   * @param plugin The main LimboAuth plugin instance (can be used for plugin-specific features if
   *     needed).
   * @param cacheManager Service for managing caches, used here to remove the session.
   * @param configManager Service for accessing configuration, used for messages and permissions.
   */
  public DestroySessionCommand(
      LimboAuth plugin, CacheManager cacheManager, ConfigManager configManager) {
    super(configManager); // Pass ConfigManager to the superclass
    this.cacheManager = cacheManager;
  }

  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    if (!(source instanceof Player)) {
      source.sendMessage(
          configManager
              .getSerializer()
              .deserialize(this.configManager.getSettings().MAIN.STRINGS.NOT_PLAYER));
      return;
    }

    Player player = (Player) source;
    this.cacheManager.removeAuthUserFromCache(player.getUsername());
    player.sendMessage(
        configManager
            .getSerializer()
            .deserialize(this.configManager.getSettings().MAIN.STRINGS.DESTROY_SESSION_SUCCESSFUL));
  }

  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    // Access configManager from the superclass
    return super.configManager
        .getSettings()
        .MAIN
        .COMMAND_PERMISSION_STATE
        .DESTROY_SESSION
        .hasPermission(invocation.source(), "limboauth.commands.destroysession");
  }
}

```

`src/main/java/net/elytrium/limboauth/command/ForceChangePasswordCommand.java`:

```java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import com.velocitypowered.api.proxy.ProxyServer;
import java.text.MessageFormat;
import java.util.List;
import java.util.Locale;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.commons.velocity.commands.SuggestUtils;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.event.ChangePasswordEvent;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.model.SQLRuntimeException;
import net.elytrium.limboauth.service.*;
import net.kyori.adventure.text.Component;
import org.slf4j.Logger;

/**
 * Admin command to forcibly change a player's password. Handles checks for player registration,
 * updates database, invalidates session, and notifies the target player if online.
 */
public class ForceChangePasswordCommand extends RatelimitedCommand {

  private final LimboAuth plugin; // For event manager & logger
  private final Logger logger;
  private final ProxyServer server; // For player suggestions and messaging
  private final DatabaseService databaseService;
  private final CacheManager cacheManager;

  // ConfigManager is available via super.configManager

  /**
   * Constructs the ForceChangePasswordCommand.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param server The ProxyServer instance.
   * @param configManager Service for accessing configuration.
   * @param databaseService Service for database interactions.
   * @param cacheManager Service for managing caches.
   */
  public ForceChangePasswordCommand(
      LimboAuth plugin,
      ProxyServer server,
      ConfigManager configManager,
      DatabaseService databaseService,
      CacheManager cacheManager) {
    super(configManager);
    this.plugin = plugin;
    this.logger = this.plugin.getLogger();
    this.server = server;
    this.databaseService = databaseService;
    this.cacheManager = cacheManager;
  }

  @Override
  public List<String> suggest(SimpleCommand.Invocation invocation) {
    return SuggestUtils.suggestPlayers(this.server, invocation.arguments(), 0);
  }

  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    Settings currentSettings = this.configManager.getSettings();
    Serializer currentSerializer = this.configManager.getSerializer();

    final Component usageMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.FORCE_CHANGE_PASSWORD_USAGE);

    if (args.length != 2) {
      source.sendMessage(usageMsg);
      return;
    }

    String targetNickname = args[0];
    String targetNicknameLowercased = targetNickname.toLowerCase(Locale.ROOT);
    String newPassword = args[1];

    final Component notRegisteredMsg =
        currentSerializer.deserialize(
            MessageFormat.format(
                currentSettings.MAIN.STRINGS.FORCE_CHANGE_PASSWORD_NOT_REGISTERED, targetNickname));
    final Component notSuccessfulMsg =
        currentSerializer.deserialize(
            MessageFormat.format(
                currentSettings.MAIN.STRINGS.FORCE_CHANGE_PASSWORD_NOT_SUCCESSFUL, targetNickname));
    final Component successfulMsg =
        currentSerializer.deserialize(
            MessageFormat.format(
                currentSettings.MAIN.STRINGS.FORCE_CHANGE_PASSWORD_SUCCESSFUL, targetNickname));
    final Component messageToPlayer =
        currentSerializer.deserialize(
            MessageFormat.format(
                currentSettings.MAIN.STRINGS.FORCE_CHANGE_PASSWORD_MESSAGE, newPassword));

    try {
      RegisteredPlayer registeredPlayer =
          this.databaseService.findPlayerByLowercaseNickname(targetNicknameLowercased);

      if (registeredPlayer == null) {
        source.sendMessage(notRegisteredMsg);
        return;
      }
      if (registeredPlayer.getHash().isEmpty() && !currentSettings.MAIN.ONLINE_MODE_NEED_AUTH) {
        source.sendMessage(
            currentSerializer.deserialize(
                MessageFormat.format(
                    currentSettings.MAIN.STRINGS.PLAYER_IS_PREMIUM_NO_PASS_CHANGE,
                    targetNickname)));
        return;
      }

      final String oldHash = registeredPlayer.getHash();
      registeredPlayer.setPassword(newPassword); // This handles hashing
      this.databaseService.updatePlayer(registeredPlayer);

      this.cacheManager.removeAuthUserFromCache(targetNickname); // Invalidate session

      this.server
          .getPlayer(targetNickname)
          .ifPresent(player -> player.sendMessage(messageToPlayer));

      this.plugin
          .getServer()
          .getEventManager()
          .fireAndForget(
              new ChangePasswordEvent(
                  registeredPlayer, null, oldHash, newPassword, registeredPlayer.getHash()));

      source.sendMessage(successfulMsg);

    } catch (SQLRuntimeException e) {
      this.logger.error("SQL error forcing password change for {}:", targetNickname, e);
      source.sendMessage(notSuccessfulMsg);
    } catch (Exception e) {
      this.logger.error("Unexpected error forcing password change for {}:", targetNickname, e);
      source.sendMessage(notSuccessfulMsg);
    }
  }

  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    return super.configManager
        .getSettings()
        .MAIN
        .COMMAND_PERMISSION_STATE
        .FORCE_CHANGE_PASSWORD
        .hasPermission(invocation.source(), "limboauth.admin.forcechangepassword");
  }
}

```

`src/main/java/net/elytrium/limboauth/command/ForceLoginCommand.java`:

```java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import java.text.MessageFormat;
import java.util.List;
import java.util.stream.Collectors;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.handler.AuthSessionHandler;
import net.elytrium.limboauth.service.ConfigManager;
import net.elytrium.limboauth.service.PlayerSessionService;
import net.kyori.adventure.text.Component;
import org.slf4j.Logger;

/**
 * Admin command to forcibly log in a player who is currently in the authentication process. This
 * bypasses the normal password/2FA checks for that player.
 */
public class ForceLoginCommand extends RatelimitedCommand {

  private final PlayerSessionService playerSessionService;
  private final LimboAuth plugin;
  private final Logger logger;

  /**
   * Constructs the ForceLoginCommand.
   *
   * @param plugin The main LimboAuth plugin instance, used for logger access.
   * @param playerSessionService Service for managing player authentication sessions.
   * @param configManager Service for accessing configuration.
   */
  public ForceLoginCommand(
      LimboAuth plugin, PlayerSessionService playerSessionService, ConfigManager configManager) {
    super(configManager);
    this.plugin = plugin;
    this.playerSessionService = playerSessionService;
    this.logger = this.plugin.getLogger();
  }

  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    Settings currentSettings = this.configManager.getSettings();
    Serializer currentSerializer = this.configManager.getSerializer();

    final Component usageMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.FORCE_LOGIN_USAGE);
    final String unknownPlayerFormat = currentSettings.MAIN.STRINGS.FORCE_LOGIN_UNKNOWN_PLAYER;
    final String successfulFormat = currentSettings.MAIN.STRINGS.FORCE_LOGIN_SUCCESSFUL;
    final Component errorOccurredMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.ERROR_OCCURRED);

    if (args.length != 1) {
      source.sendMessage(usageMsg);
      return;
    }

    String nickname = args[0];
    AuthSessionHandler handler = this.playerSessionService.getAuthenticatingPlayer(nickname);

    if (handler == null) {
      source.sendMessage(
          currentSerializer.deserialize(MessageFormat.format(unknownPlayerFormat, nickname)));
      return;
    }

    try {
      // Poprzednio było finishLogin(), ale triggerSuccessfulLoginSequence() jest bardziej
      // odpowiednie,
      // bo obsługuje eventy i inne kroki finalizacji logowania.
      handler.triggerSuccessfulLoginSequence();
      source.sendMessage(
          currentSerializer.deserialize(MessageFormat.format(successfulFormat, nickname)));
    } catch (Exception e) {
      this.logger.error("Error during force login for {}:", nickname, e);
      source.sendMessage(errorOccurredMsg);
    }
  }

  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    return this.configManager
        .getCommandPermissionState()
        .FORCE_LOGIN
        .hasPermission(invocation.source(), "limboauth.admin.forcelogin");
  }

  @Override
  public List<String> suggest(SimpleCommand.Invocation invocation) {
    if (invocation.arguments().length > 1) {
      return super.suggest(invocation);
    }
    String currentArg =
        invocation.arguments().length == 0 ? "" : invocation.arguments()[0].toLowerCase();
    return this.playerSessionService.getAuthenticatingPlayers().keySet().stream()
        .filter(username -> username.toLowerCase().startsWith(currentArg))
        .collect(Collectors.toList());
  }
}

```

`src/main/java/net/elytrium/limboauth/command/ForceRegisterCommand.java`:

```java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import java.text.MessageFormat;
import java.util.Locale;
import java.util.regex.Pattern;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.model.SQLRuntimeException;
import net.elytrium.limboauth.service.ConfigManager;
import net.elytrium.limboauth.service.DatabaseService;
import net.kyori.adventure.text.Component;
import org.slf4j.Logger;

/**
 * Admin command to forcibly register a new player account. Handles nickname validation, password
 * validation, and database creation.
 */
public class ForceRegisterCommand extends RatelimitedCommand {

  private final DatabaseService databaseService;
  private final LimboAuth plugin;
  // Usunięto pole nicknameValidationPattern, będziemy pobierać z ConfigManager
  private final Logger logger;

  /**
   * Constructs the ForceRegisterCommand.
   *
   * @param plugin The main LimboAuth plugin instance, used for logger access.
   * @param databaseService Service for database interactions.
   * @param configManager Service for accessing configuration.
   */
  public ForceRegisterCommand(
      LimboAuth plugin, DatabaseService databaseService, ConfigManager configManager) {
    super(configManager);
    this.plugin = plugin;
    this.databaseService = databaseService;
    this.logger = this.plugin.getLogger();
  }

  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    Settings currentSettings = this.configManager.getSettings();
    Serializer currentSerializer = this.configManager.getSerializer();
    Pattern nicknamePattern =
        this.configManager.getNicknameValidationPattern(); // Pobierz pattern z ConfigManager

    final Component usageMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.FORCE_REGISTER_USAGE);
    final Component incorrectNicknameMsg =
        currentSerializer.deserialize(
            currentSettings.MAIN.STRINGS.FORCE_REGISTER_INCORRECT_NICKNAME);
    final Component takenNicknameMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.FORCE_REGISTER_TAKEN_NICKNAME);
    final String successfulFormat = currentSettings.MAIN.STRINGS.FORCE_REGISTER_SUCCESSFUL;
    final String notSuccessfulFormat = currentSettings.MAIN.STRINGS.FORCE_REGISTER_NOT_SUCCESSFUL;
    final Component errorOccurredMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.ERROR_OCCURRED);

    if (args.length != 2) {
      source.sendMessage(usageMsg);
      return;
    }

    String nickname = args[0];
    String password = args[1];

    if (!nicknamePattern.matcher(nickname).matches()) { // Użyj pobranego patternu
      source.sendMessage(incorrectNicknameMsg);
      return;
    }

    String lowercaseNickname = nickname.toLowerCase(Locale.ROOT);
    if (databaseService.findPlayerByLowercaseNickname(lowercaseNickname) != null) {
      source.sendMessage(takenNicknameMsg);
      return;
    }

    if (password.length() < currentSettings.MAIN.MIN_PASSWORD_LENGTH) {
      source.sendMessage(
          currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTER_PASSWORD_TOO_SHORT));
      return;
    }
    if (password.length() > currentSettings.MAIN.MAX_PASSWORD_LENGTH) {
      source.sendMessage(
          currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTER_PASSWORD_TOO_LONG));
      return;
    }
    // Użyj publicznego pola unsafePasswords z ConfigManager
    if (currentSettings.MAIN.CHECK_PASSWORD_STRENGTH
        && this.configManager.unsafePasswords.contains(password)) {
      source.sendMessage(
          currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTER_PASSWORD_UNSAFE));
      return;
    }

    try {
      RegisteredPlayer player = new RegisteredPlayer(nickname, "", "");
      player.setPassword(password);
      this.databaseService.createPlayer(player);
      source.sendMessage(
          currentSerializer.deserialize(MessageFormat.format(successfulFormat, nickname)));
    } catch (SQLRuntimeException e) {
      this.logger.error("SQL error during force register for {}:", nickname, e);
      source.sendMessage(
          currentSerializer.deserialize(MessageFormat.format(notSuccessfulFormat, nickname)));
    } catch (Exception e) {
      this.logger.error("Unexpected error during force register for {}:", nickname, e);
      source.sendMessage(errorOccurredMsg);
    }
  }

  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    return this.configManager
        .getCommandPermissionState()
        .FORCE_REGISTER
        .hasPermission(invocation.source(), "limboauth.admin.forceregister");
  }
}

```

`src/main/java/net/elytrium/limboauth/command/ForceUnregisterCommand.java`:

```java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import com.velocitypowered.api.proxy.ProxyServer;
import java.text.MessageFormat;
import java.util.List;
import java.util.Locale;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.commons.velocity.commands.SuggestUtils;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.event.AuthUnregisterEvent;
import net.elytrium.limboauth.model.SQLRuntimeException;
import net.elytrium.limboauth.service.CacheManager;
import net.elytrium.limboauth.service.ConfigManager;
import net.elytrium.limboauth.service.DatabaseService;
import net.kyori.adventure.text.Component;
import org.slf4j.Logger;

/**
 * Admin command to forcibly unregister a player's account. Deletes the player's data from the
 * database, invalidates their session, and kicks them if they are online.
 */
public class ForceUnregisterCommand extends RatelimitedCommand {

  private final LimboAuth plugin; // Dla EventManager
  private final ProxyServer server;
  private final DatabaseService databaseService;
  private final CacheManager cacheManager;
  private final Logger logger;

  /**
   * Constructs the ForceUnregisterCommand.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param server The ProxyServer instance.
   * @param databaseService Service for database interactions.
   * @param cacheManager Service for managing caches.
   * @param configManager Service for accessing configuration.
   */
  public ForceUnregisterCommand(
      LimboAuth plugin,
      ProxyServer server,
      DatabaseService databaseService,
      CacheManager cacheManager,
      ConfigManager configManager) {
    super(configManager);
    this.plugin = plugin;
    this.server = server;
    this.databaseService = databaseService;
    this.cacheManager = cacheManager;
    this.logger = this.plugin.getLogger();
  }

  @Override
  public List<String> suggest(SimpleCommand.Invocation invocation) {
    return SuggestUtils.suggestPlayers(this.server, invocation.arguments(), 0);
  }

  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    Settings currentSettings = this.configManager.getSettings();
    Serializer currentSerializer = this.configManager.getSerializer();

    final Component usageMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.FORCE_UNREGISTER_USAGE);
    final Component kickMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.FORCE_UNREGISTER_KICK);
    final String successfulFormat = currentSettings.MAIN.STRINGS.FORCE_UNREGISTER_SUCCESSFUL;
    final String notSuccessfulFormat = currentSettings.MAIN.STRINGS.FORCE_UNREGISTER_NOT_SUCCESSFUL;

    if (args.length != 1) {
      source.sendMessage(usageMsg);
      return;
    }

    String playerNick = args[0];
    String usernameLowercased = playerNick.toLowerCase(Locale.ROOT);

    try {
      if (databaseService.findPlayerByLowercaseNickname(usernameLowercased) == null) {
        source.sendMessage(
            currentSerializer.deserialize(
                MessageFormat.format(notSuccessfulFormat, playerNick)
                    + " (Player not found in database)"));
        return;
      }

      this.plugin.getServer().getEventManager().fireAndForget(new AuthUnregisterEvent(playerNick));
      this.databaseService.deletePlayerByLowercaseNickname(usernameLowercased);
      this.cacheManager.removeAuthUserFromCache(playerNick);
      this.server.getPlayer(playerNick).ifPresent(player -> player.disconnect(kickMsg));
      source.sendMessage(
          currentSerializer.deserialize(MessageFormat.format(successfulFormat, playerNick)));
    } catch (SQLRuntimeException e) {
      this.logger.error("SQL error during force unregister for {}:", playerNick, e);
      source.sendMessage(
          currentSerializer.deserialize(MessageFormat.format(notSuccessfulFormat, playerNick)));
    } catch (Exception e) {
      this.logger.error("Unexpected error during force unregister for {}:", playerNick, e);
      source.sendMessage(
          currentSerializer.deserialize(MessageFormat.format(notSuccessfulFormat, playerNick)));
    }
  }

  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    return this.configManager
        .getCommandPermissionState()
        .FORCE_UNREGISTER
        .hasPermission(invocation.source(), "limboauth.admin.forceunregister");
  }
}

```

`src/main/java/net/elytrium/limboauth/command/LimboAuthCommand.java`:

```java
package net.elytrium.limboauth.command;

import com.google.common.collect.ImmutableList;
import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import java.util.Arrays;
import java.util.List;
import java.util.Locale;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.service.ConfigManager;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.format.NamedTextColor;

/**
 * Implements the base /limboauth command for administrative actions. This command handles
 * subcommands like "reload" and provides help information.
 */
public class LimboAuthCommand extends RatelimitedCommand {

  private static final List<Component> HELP_MESSAGE =
      List.of(
          Component.text("This server is using LimboAuth and LimboAPI.", NamedTextColor.YELLOW),
          Component.text("(C) 2021 - 2025 Elytrium", NamedTextColor.YELLOW),
          Component.text("https://elytrium.net/github/", NamedTextColor.GREEN),
          Component.empty());

  private static final Component AVAILABLE_SUBCOMMANDS_MESSAGE =
      Component.text("Available subcommands:", NamedTextColor.WHITE);
  private static final Component NO_AVAILABLE_SUBCOMMANDS_MESSAGE =
      Component.text("There is no available subcommands for you.", NamedTextColor.WHITE);

  private final LimboAuth plugin;

  /**
   * Constructs the LimboAuthCommand.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param configManager Service for accessing configuration, used for permissions.
   */
  /** Default constructor. */
  public LimboAuthCommand(LimboAuth plugin, ConfigManager configManager) {
    super(configManager);
    this.plugin = plugin;
  }

  /**
   * Suggests subcommand names for tab completion. Filters suggestions based on the user's
   * permissions for each subcommand.
   *
   * @param invocation The command invocation context.
   * @return A list of suggested subcommand strings.
   */
  @Override
  public List<String> suggest(SimpleCommand.Invocation invocation) {
    CommandSource source = invocation.source();
    String[] args = invocation.arguments();

    if (args.length == 0 || args.length == 1) {
      String currentArg = args.length == 0 ? "" : args[0].toLowerCase(Locale.ROOT);
      return Arrays.stream(Subcommand.values())
          .filter(sub -> sub.hasPermission(source, this.configManager))
          .map(Subcommand::getCommand)
          .filter(cmdName -> cmdName.startsWith(currentArg))
          .toList();
    }
    return ImmutableList.of();
  }

  /**
   * Executes the /limboauth command or its subcommands. If no arguments are provided, or if an
   * unknown subcommand is given, it displays help information.
   *
   * @param source The source of the command.
   * @param args The arguments provided with the command.
   * @param ratelimitedMessageComponent The component to display if rate-limited (unused directly
   *     here).
   */
  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    if (args.length == 0) {
      this.showHelp(source);
      return;
    }

    String subCommandStr = args[0].toUpperCase(Locale.ROOT);
    try {
      Subcommand subcommand = Subcommand.valueOf(subCommandStr);
      if (!subcommand.hasPermission(source, this.configManager)) {
        this.showHelp(source);
        return;
      }
      subcommand.executor.execute(this.plugin, source, Arrays.copyOfRange(args, 1, args.length));
    } catch (IllegalArgumentException e) {
      this.showHelp(source); // Unknown subcommand
    }
  }

  /**
   * Shows the help and available subcommands to the sender.
   *
   * @param source The command source to send help to.
   */
  private void showHelp(CommandSource source) {
    HELP_MESSAGE.forEach(source::sendMessage);
    List<Subcommand> available =
        Arrays.stream(Subcommand.values())
            .filter(cmd -> cmd.hasPermission(source, this.configManager))
            .toList();
    if (!available.isEmpty()) {
      source.sendMessage(AVAILABLE_SUBCOMMANDS_MESSAGE);
      for (Subcommand cmd : available) {
        source.sendMessage(Component.text(cmd.getCommand(), NamedTextColor.AQUA));
      }
    } else {
      source.sendMessage(NO_AVAILABLE_SUBCOMMANDS_MESSAGE);
    }
  }

  /**
   * Checks if the command source has permission to execute the base /limboauth command. Permission
   * is granted if the source has the "help" permission or permission for any of the defined
   * subcommands.
   *
   * @param invocation The command invocation context.
   * @return {@code true} if the source has permission, {@code false} otherwise.
   */
  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    return this.configManager
            .getCommandPermissionState()
            .HELP
            .hasPermission(invocation.source(), "limboauth.commands.help")
        || Arrays.stream(Subcommand.values())
            .anyMatch(sc -> sc.hasPermission(invocation.source(), this.configManager));
  }

  /**
   * Enum defining the available subcommands for /limboauth. Each subcommand has an associated
   * executor and permission check logic.
   */
  private enum Subcommand {
    RELOAD(
        "reload",
        "limboauth.admin.reload",
        (pluginInstance, source, subArgs) -> {
          if (pluginInstance
              .getConfigManager()
              .getCommandPermissionState()
              .RELOAD
              .hasPermission(source, "limboauth.admin.reload")) {
            pluginInstance.reloadPlugin();
            source.sendMessage(
                pluginInstance
                    .getConfigManager()
                    .getSerializer()
                    .deserialize(
                        pluginInstance.getConfigManager().getSettings().MAIN.STRINGS.RELOAD));
          } else {
            source.sendMessage(
                Component.text(
                    "You do not have permission to use this subcommand.", NamedTextColor.RED));
          }
        });

    private final String command;
    private final String permissionNode;
    private final SubcommandExecutor executor;

    /**
     * Constructs a Subcommand.
     *
     * @param command The command string (e.g., "reload").
     * @param permissionNode The permission node required for this subcommand.
     * @param executor The logic to execute for this subcommand.
     */
    Subcommand(String command, String permissionNode, SubcommandExecutor executor) {
      this.command = command;
      this.permissionNode = permissionNode;
      this.executor = executor;
    }

    /**
     * Gets the command string.
     *
     * @return The command string.
     */
    public String getCommand() {
      return this.command;
    }

    /**
     * Checks if the source has permission for this subcommand based on its configured permission
     * state.
     *
     * @param source The command source.
     * @param cm The ConfigManager to get the permission state.
     * @return True if permitted, false otherwise.
     */
    public boolean hasPermission(CommandSource source, ConfigManager cm) {
      Settings.MAIN.COMMAND_PERMISSION_STATE states =
          cm.getSettings().MAIN.COMMAND_PERMISSION_STATE;
      CommandPermissionState specificState;
      switch (this.command.toLowerCase(Locale.ROOT)) {
        case "reload":
          specificState = states.RELOAD;
          break;
        default:
          return source.hasPermission(this.permissionNode);
      }
      return specificState.hasPermission(source, this.permissionNode);
    }
  }

  /** Functional interface for executing a subcommand. */
  @FunctionalInterface
  private interface SubcommandExecutor {
    /**
     * Executes the subcommand logic.
     *
     * @param plugin The main LimboAuth plugin instance.
     * @param source The command source.
     * @param args The arguments for the subcommand.
     */
    void execute(LimboAuth plugin, CommandSource source, String[] args);
  }
}

```

`src/main/java/net/elytrium/limboauth/command/LoginCommand.java`:

```java
// File: LimboAuth/src/main/java/net/elytrium/limboauth/command/LoginCommand.java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import com.velocitypowered.api.proxy.Player;
import java.text.MessageFormat;
import java.util.Locale;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.handler.AuthSessionHandler;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.service.AuthenticationService;
import net.elytrium.limboauth.service.ConfigManager;
import net.elytrium.limboauth.service.PlayerSessionService;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.title.Title;
import org.slf4j.Logger;

/**
 * Command for players to log into their account. Handles password verification and TOTP if enabled.
 */
public class LoginCommand extends RatelimitedCommand {

  private final LimboAuth plugin;
  private final Logger logger;
  private final AuthenticationService authenticationService;
  private final PlayerSessionService playerSessionService;

  public LoginCommand(
      LimboAuth plugin,
      AuthenticationService authenticationService,
      PlayerSessionService playerSessionService,
      ConfigManager configManager) {
    super(configManager);
    this.plugin = plugin;
    this.logger = this.plugin.getLogger();
    this.authenticationService = authenticationService;
    this.playerSessionService = playerSessionService;
  }

  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    if (!(source instanceof Player)) {
      source.sendMessage(
          configManager
              .getSerializer()
              .deserialize(this.configManager.getSettings().MAIN.STRINGS.NOT_PLAYER));
      return;
    }

    Player player = (Player) source;
    Settings currentSettings = this.configManager.getSettings();
    Serializer currentSerializer = this.configManager.getSerializer();

    AuthSessionHandler handler =
        this.playerSessionService.getAuthenticatingPlayer(player.getUsername());
    if (handler == null) {
      player.sendMessage(
          currentSerializer.deserialize(currentSettings.MAIN.STRINGS.ERROR_OCCURRED));
      this.logger.warn(
          "Player {} tried to use /login but no AuthSessionHandler was found.",
          player.getUsername());
      return;
    }

    if (args.length == 0) {
      int attemptsLeft = currentSettings.MAIN.LOGIN_ATTEMPTS - handler.getLoginAttempts();
      source.sendMessage(
          currentSerializer.deserialize(
              MessageFormat.format(currentSettings.MAIN.STRINGS.LOGIN, attemptsLeft)));
      return;
    }

    String passwordOrCode = args[0];
    String usernameLowercase = player.getUsername().toLowerCase(Locale.ROOT);

    try {
      RegisteredPlayer registeredPlayer =
          this.plugin.getDatabaseService().findPlayerByLowercaseNickname(usernameLowercase);

      if (registeredPlayer == null) {
        source.sendMessage(
            currentSerializer.deserialize(currentSettings.MAIN.STRINGS.NOT_REGISTERED));
        return;
      }

      if (registeredPlayer.getHash().isEmpty()) {
        source.sendMessage(
            currentSerializer.deserialize(currentSettings.MAIN.STRINGS.CRACKED_COMMAND));
        return;
      }

      if (handler.isSessionExpired()) {
        player.disconnect(currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TIMES_UP));
        return;
      }

      // If password not yet authenticated, this input is the password
      if (!handler.isAuthenticated()) {
        if (!authenticationService.checkPassword(passwordOrCode, registeredPlayer)) {
          handler.incrementLoginAttempts();
          int attemptsLeft = currentSettings.MAIN.LOGIN_ATTEMPTS - handler.getLoginAttempts();

          if (attemptsLeft <= 0) {
            this.plugin
                .getCacheManager()
                .incrementBruteforceAttempts(player.getRemoteAddress().getAddress());
            player.disconnect(
                currentSerializer.deserialize(
                    currentSettings.MAIN.STRINGS.LOGIN_WRONG_PASSWORD_KICK));
          } else {
            source.sendMessage(
                currentSerializer.deserialize(
                    MessageFormat.format(
                        currentSettings.MAIN.STRINGS.LOGIN_WRONG_PASSWORD, attemptsLeft)));
          }
          return;
        }
        // Password correct
        handler.setAuthenticated(true);
        this.playerSessionService.resetLoginAttempts(
            player.getUsername()); // Reset attempts on correct password

        // If TOTP is enabled and required, prompt for it
        if (currentSettings.MAIN.ENABLE_TOTP
            && registeredPlayer.getTotpToken() != null
            && !registeredPlayer.getTotpToken().isEmpty()) {
          // If command was just /login , now prompt for TOTP
          if (args.length == 1) {
            player.sendMessage(currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP));
            if (currentSettings.MAIN.STRINGS.TOTP_TITLE != null
                && !currentSettings.MAIN.STRINGS.TOTP_TITLE.isEmpty()) {
              Component mainTitle =
                  currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_TITLE);
              Component subTitle =
                  currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_SUBTITLE);
              Title.Times times =
                  currentSettings.MAIN.PREMIUM_TITLE_SETTINGS
                      .toTimes(); // Or a specific TOTP_TITLE_SETTINGS
              player.showTitle(Title.title(mainTitle, subTitle, times));
            }
            return; // Wait for player to send TOTP code with /login
          }
          // If command was /login , and TOTP is enabled, then args[1] is TOTP code
          String totpCode = args[1];
          if (AuthSessionHandler.TOTP_CODE_VERIFIER.isValidCode(
              registeredPlayer.getTotpToken(), totpCode)) {
            this.logger.info(
                "Player {} successfully authenticated with password and TOTP.",
                player.getUsername());
            handler.triggerSuccessfulLoginSequence();
          } else {
            handler.setAuthenticated(false); // Reset password auth status because TOTP failed
            handler.incrementLoginAttempts();
            int attemptsLeft = currentSettings.MAIN.LOGIN_ATTEMPTS - handler.getLoginAttempts();
            if (attemptsLeft <= 0) {
              player.disconnect(
                  currentSerializer.deserialize(
                      currentSettings.MAIN.STRINGS.LOGIN_WRONG_PASSWORD_KICK));
            } else {
              player.sendMessage(
                  currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_WRONG));
            }
          }
        } else {
          // No TOTP, login successful
          this.logger.info(
              "Player {} successfully authenticated with password.", player.getUsername());
          handler.triggerSuccessfulLoginSequence();
        }
      } else { // Password already authenticated, this input must be a TOTP code
        if (currentSettings.MAIN.ENABLE_TOTP
            && registeredPlayer.getTotpToken() != null
            && !registeredPlayer.getTotpToken().isEmpty()) {
          if (AuthSessionHandler.TOTP_CODE_VERIFIER.isValidCode(
              registeredPlayer.getTotpToken(), passwordOrCode)) {
            this.logger.info(
                "Player {} successfully authenticated with TOTP.", player.getUsername());
            handler.triggerSuccessfulLoginSequence();
          } else {
            handler.incrementLoginAttempts();
            int attemptsLeft = currentSettings.MAIN.LOGIN_ATTEMPTS - handler.getLoginAttempts();
            if (attemptsLeft <= 0) {
              player.disconnect(
                  currentSerializer.deserialize(
                      currentSettings.MAIN.STRINGS.LOGIN_WRONG_PASSWORD_KICK));
            } else {
              player.sendMessage(
                  currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_WRONG));
              player.sendMessage(
                  currentSerializer.deserialize(
                      currentSettings.MAIN.STRINGS.TOTP)); // Re-prompt for TOTP
              if (currentSettings.MAIN.STRINGS.TOTP_TITLE != null
                  && !currentSettings.MAIN.STRINGS.TOTP_TITLE.isEmpty()) {
                Component mainTitle =
                    currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_TITLE);
                Component subTitle =
                    currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_SUBTITLE);
                Title.Times times = currentSettings.MAIN.PREMIUM_TITLE_SETTINGS.toTimes();
                player.showTitle(Title.title(mainTitle, subTitle, times));
              }
            }
          }
        } else {
          // Should not happen: password authenticated but TOTP not enabled/setup, yet received more
          // input
          this.logger.warn(
              "Player {} sent additional input after password authentication, but TOTP is not active.",
              player.getUsername());
          handler.triggerSuccessfulLoginSequence(); // Proceed as if login was complete
        }
      }

    } catch (Exception e) {
      this.logger.error("Error during login for {}:", player.getUsername(), e);
      source.sendMessage(
          currentSerializer.deserialize(currentSettings.MAIN.STRINGS.ERROR_OCCURRED));
    }
  }

  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    return true; // Login is generally public
  }
}

```

`src/main/java/net/elytrium/limboauth/command/PremiumCommand.java`:

```java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import com.velocitypowered.api.proxy.Player;
import java.util.Locale;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.model.SQLRuntimeException;
import net.elytrium.limboauth.service.AuthenticationService;
import net.elytrium.limboauth.service.CacheManager;
import net.elytrium.limboauth.service.ConfigManager;
import net.elytrium.limboauth.service.DatabaseService;
import net.kyori.adventure.text.Component;
import org.slf4j.Logger;

/**
 * Command for players to mark their account as "premium". This typically involves verifying their
 * username against Mojang's API and, if successful, clearing their password hash in the database,
 * effectively making their account online-mode only for this server's authentication system.
 */
public class PremiumCommand extends RatelimitedCommand {

  private final Logger logger;
  private final DatabaseService databaseService;
  private final AuthenticationService authenticationService;
  private final CacheManager cacheManager;
  private final LimboAuth plugin; // For disconnecting player

  /**
   * Constructs the PremiumCommand.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param databaseService Service for database interactions.
   * @param authenticationService Service for authentication logic, including premium checks.
   * @param cacheManager Service for managing caches.
   * @param configManager Service for accessing configuration.
   */
  public PremiumCommand(
      LimboAuth plugin,
      DatabaseService databaseService,
      AuthenticationService authenticationService,
      CacheManager cacheManager,
      ConfigManager configManager) {
    super(configManager);
    this.plugin = plugin;
    this.logger = this.plugin.getLogger();
    this.databaseService = databaseService;
    this.authenticationService = authenticationService;
    this.cacheManager = cacheManager;
  }

  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    if (!(source instanceof Player)) {
      source.sendMessage(
          configManager
              .getSerializer()
              .deserialize(configManager.getSettings().MAIN.STRINGS.NOT_PLAYER));
      return;
    }

    Player commandPlayer = (Player) source;
    Settings currentSettings = this.configManager.getSettings();
    Serializer currentSerializer = this.configManager.getSerializer();

    final String confirmKeyword = currentSettings.MAIN.CONFIRM_KEYWORD;
    final Component notRegisteredMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.NOT_REGISTERED);
    final Component alreadyPremiumMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.ALREADY_PREMIUM);
    final Component successfulMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.PREMIUM_SUCCESSFUL);
    final Component errorOccurredMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.ERROR_OCCURRED);
    final Component notPremiumOnlineMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.NOT_PREMIUM);
    final Component wrongPasswordMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.WRONG_PASSWORD);
    final Component usageMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.PREMIUM_USAGE);

    if (args.length != 2 || !confirmKeyword.equalsIgnoreCase(args[1])) {
      source.sendMessage(usageMsg);
      return;
    }

    String usernameLowercase = commandPlayer.getUsername().toLowerCase(Locale.ROOT);
    RegisteredPlayer registeredPlayer =
        this.databaseService.findPlayerByLowercaseNickname(usernameLowercase);

    if (registeredPlayer == null) {
      source.sendMessage(notRegisteredMsg);
      return;
    }
    if (registeredPlayer.getHash().isEmpty()) { // Already marked as premium (no password hash)
      source.sendMessage(alreadyPremiumMsg);
      return;
    }

    if (!authenticationService.checkPassword(args[0], registeredPlayer)) {
      source.sendMessage(wrongPasswordMsg);
      return;
    }

    // Check with external Mojang API if the username is actually premium
    LimboAuth.PremiumResponse premiumCheck =
        this.authenticationService.isPremiumExternal(commandPlayer.getUsername());

    if (premiumCheck.getState() == LimboAuth.PremiumState.PREMIUM_USERNAME) {
      try {
        registeredPlayer.setHash(""); // Clear password to mark as premium
        if (premiumCheck.getUuid() != null) { // Save the Mojang UUID
          registeredPlayer.setPremiumUuid(premiumCheck.getUuid());
          if (currentSettings.MAIN.SAVE_UUID) { // If SAVE_UUID, also set the main UUID
            registeredPlayer.setUuid(premiumCheck.getUuid().toString());
          }
        }
        this.databaseService.updatePlayer(registeredPlayer);
        this.cacheManager.removeAuthUserFromCache(
            commandPlayer.getUsername()); // Invalidate session
        commandPlayer.disconnect(successfulMsg); // Disconnect to force re-login with premium status
      } catch (SQLRuntimeException e) {
        this.logger.error("SQL error converting {} to premium:", usernameLowercase, e);
        source.sendMessage(errorOccurredMsg);
      }
    } else {
      // Handle other states like CRACKED, UNKNOWN, RATE_LIMIT, ERROR
      source.sendMessage(notPremiumOnlineMsg);
      if (premiumCheck.getState() == LimboAuth.PremiumState.RATE_LIMIT) {
        source.sendMessage(
            currentSerializer.deserialize(currentSettings.MAIN.STRINGS.MOJANG_API_RATE_LIMITED));
      } else if (premiumCheck.getState() == LimboAuth.PremiumState.ERROR) {
        source.sendMessage(
            currentSerializer.deserialize(currentSettings.MAIN.STRINGS.MOJANG_API_ERROR));
      }
    }
  }

  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    return super.configManager
        .getCommandPermissionState()
        .PREMIUM
        .hasPermission(invocation.source(), "limboauth.commands.premium");
  }
}

```

`src/main/java/net/elytrium/limboauth/command/RatelimitedCommand.java`:

```java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import com.velocitypowered.api.proxy.Player;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.service.ConfigManager;
import net.kyori.adventure.text.Component;

/**
 * Abstract base class for commands that should be rate-limited. It uses a global {@link
 * LimboAuth#RATELIMITER} for IP-based rate limiting.
 */
public abstract class RatelimitedCommand implements SimpleCommand {

  /** Configuration manager for accessing settings and permissions. */
  protected final ConfigManager configManager; // Accessible by subclasses

  /**
   * Constructs a RatelimitedCommand.
   *
   * @param configManager The configuration manager for accessing settings like rate limit messages.
   */
  /** Default constructor. */
  public RatelimitedCommand(ConfigManager configManager) {
    this.configManager = configManager;
  }

  @Override
  public final void execute(SimpleCommand.Invocation invocation) {
    CommandSource source = invocation.source();
    // Fetch the message dynamically using the injected ConfigManager each time
    Component ratelimitedMessageText =
        this.configManager
            .getSerializer()
            .deserialize(configManager.getSettings().MAIN.STRINGS.RATELIMITED);

    if (source instanceof Player) {
      // Access the static RATELIMITER from LimboAuth.
      if (!LimboAuth.RATELIMITER.attempt(((Player) source).getRemoteAddress().getAddress())) {
        source.sendMessage(ratelimitedMessageText);
        return;
      }
    }
    // Pass the fetched ratelimitedMessage to the subclass execute method
    this.execute(source, invocation.arguments(), ratelimitedMessageText);
  }

  /**
   * Executes the command logic if not rate-limited. Subclasses must implement this method to define
   * their specific command behavior.
   *
   * @param source The command source.
   * @param args The command arguments.
   * @param ratelimitedMessageComponent The component message for rate limiting, passed for context
   *     or potential use.
   */
  protected abstract void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent);
}

```

`src/main/java/net/elytrium/limboauth/command/RegisterCommand.java`:

```java
// File: LimboAuth/src/main/java/net/elytrium/limboauth/command/RegisterCommand.java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import com.velocitypowered.api.proxy.Player;
import java.util.Locale;
import java.util.function.Consumer;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.event.PostRegisterEvent;
import net.elytrium.limboauth.event.PreRegisterEvent;
import net.elytrium.limboauth.event.TaskEvent;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.model.SQLRuntimeException;
import net.elytrium.limboauth.service.AuthenticationService;
import net.elytrium.limboauth.service.CacheManager;
import net.elytrium.limboauth.service.ConfigManager;
import net.elytrium.limboauth.service.DatabaseService;
import net.kyori.adventure.text.Component;
import org.slf4j.Logger;

/**
 * Command for players to register a new account. Handles password validation, database creation,
 * and automatic login.
 */
public class RegisterCommand extends RatelimitedCommand {

  private final LimboAuth plugin;
  private final Logger logger;
  private final DatabaseService databaseService;
  private final AuthenticationService authenticationService;
  private final CacheManager cacheManager;

  public RegisterCommand(
      LimboAuth plugin,
      DatabaseService databaseService,
      AuthenticationService authenticationService,
      CacheManager cacheManager,
      ConfigManager configManager) {
    super(configManager);
    this.plugin = plugin;
    this.logger = this.plugin.getLogger();
    this.databaseService = databaseService;
    this.authenticationService = authenticationService;
    this.cacheManager = cacheManager;
  }

  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    if (!(source instanceof Player)) {
      source.sendMessage(
          configManager
              .getSerializer()
              .deserialize(this.configManager.getSettings().MAIN.STRINGS.NOT_PLAYER));
      return;
    }

    Player player = (Player) source;
    Settings currentSettings = this.configManager.getSettings();
    Serializer currentSerializer = this.configManager.getSerializer();

    if (currentSettings.MAIN.DISABLE_REGISTRATIONS) {
      player.disconnect(
          currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTRATIONS_DISABLED_KICK));
      return;
    }

    String usernameLowercase = player.getUsername().toLowerCase(Locale.ROOT);
    RegisteredPlayer existingPlayer =
        this.databaseService.findPlayerByLowercaseNickname(usernameLowercase);

    if (existingPlayer != null) {
      source.sendMessage(
          currentSerializer.deserialize(currentSettings.MAIN.STRINGS.NOT_REGISTERED));
      return;
    }

    boolean needRepeatPassword = currentSettings.MAIN.REGISTER_NEED_REPEAT_PASSWORD;
    int expectedArgs = needRepeatPassword ? 2 : 1;

    String usageMessageString = currentSettings.MAIN.STRINGS.REGISTER;

    if (args.length < expectedArgs) {
      source.sendMessage(currentSerializer.deserialize(usageMessageString));
      return;
    }

    String password = args[0];
    if (needRepeatPassword && !password.equals(args[1])) {
      source.sendMessage(
          currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTER_DIFFERENT_PASSWORDS));
      return;
    }

    if (password.length() < currentSettings.MAIN.MIN_PASSWORD_LENGTH) {
      source.sendMessage(
          currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTER_PASSWORD_TOO_SHORT));
      return;
    }

    if (password.length() > currentSettings.MAIN.MAX_PASSWORD_LENGTH) {
      source.sendMessage(
          currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTER_PASSWORD_TOO_LONG));
      return;
    }

    if (currentSettings.MAIN.CHECK_PASSWORD_STRENGTH
        && this.configManager.unsafePasswords.contains(password)) {
      source.sendMessage(
          currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTER_PASSWORD_UNSAFE));
      return;
    }

    Consumer<TaskEvent> eventConsumer =
        (event) -> {
          if (event.getResult() == TaskEvent.Result.CANCEL) {
            player.disconnect(event.getReason());
            return;
          }
          if (event.getResult() != TaskEvent.Result.BYPASS) {
            try {
              RegisteredPlayer newPlayer = new RegisteredPlayer(player);
              newPlayer.setPassword(password);
              newPlayer.setIP(player.getRemoteAddress().getAddress().getHostAddress());
              newPlayer.setRegDate(System.currentTimeMillis());
              newPlayer.setLoginIp(player.getRemoteAddress().getAddress().getHostAddress());
              newPlayer.setLoginDate(System.currentTimeMillis());

              this.databaseService.createPlayer(newPlayer);
              this.cacheManager.cacheAuthUser(player);

              this.plugin
                  .getServer()
                  .getEventManager()
                  .fireAndForget(new PostRegisterEvent(taskEvent -> {}, null, newPlayer, password));

              player.sendMessage(
                  currentSerializer.deserialize(currentSettings.MAIN.STRINGS.REGISTER_SUCCESSFUL));
              this.logger.info("Player {} registered successfully.", player.getUsername());

              this.authenticationService.updateLoginData(player);
              this.plugin.getLimboFactory().passLoginLimbo(player);

            } catch (SQLRuntimeException e) {
              this.logger.error("SQL error during registration for {}:", player.getUsername(), e);
              player.sendMessage(
                  currentSerializer.deserialize(currentSettings.MAIN.STRINGS.ERROR_OCCURRED));
            } catch (Exception e) {
              this.logger.error(
                  "Unexpected error during registration for {}:", player.getUsername(), e);
              player.sendMessage(
                  currentSerializer.deserialize(currentSettings.MAIN.STRINGS.ERROR_OCCURRED));
            }
          } else {
            this.logger.info(
                "Registration for player {} was bypassed by an event handler.",
                player.getUsername());
            this.authenticationService.updateLoginData(player);
            this.plugin.getLimboFactory().passLoginLimbo(player);
          }
        };

    PreRegisterEvent preEvent =
        new PreRegisterEvent(eventConsumer, TaskEvent.Result.NORMAL, player);
    // FIX APPLIED HERE: Removed createExecutor
    this.plugin.getServer().getEventManager().fire(preEvent).thenAcceptAsync(eventConsumer);
  }

  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    return this.configManager
        .getCommandPermissionState()
        .HELP
        .hasPermission(invocation.source(), "limboauth.commands.register");
  }
}

```

`src/main/java/net/elytrium/limboauth/command/TotpCommand.java`:

```java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import com.velocitypowered.api.proxy.Player;
import dev.samstevens.totp.qr.QrData;
import dev.samstevens.totp.recovery.RecoveryCodeGenerator;
import dev.samstevens.totp.secret.DefaultSecretGenerator;
import dev.samstevens.totp.secret.SecretGenerator;
import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.text.MessageFormat;
import java.util.Locale;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.handler.AuthSessionHandler;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.model.SQLRuntimeException;
import net.elytrium.limboauth.service.AuthenticationService;
import net.elytrium.limboauth.service.ConfigManager;
import net.elytrium.limboauth.service.DatabaseService;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.event.ClickEvent;
import org.slf4j.Logger;

/**
 * Command for managing Two-Factor Authentication (TOTP) for player accounts. Allows enabling TOTP
 * with QR code/secret display and disabling TOTP with a valid code.
 */
public class TotpCommand extends RatelimitedCommand {

  private final Logger logger;
  private final DatabaseService databaseService;
  private final AuthenticationService authenticationService;
  private final LimboAuth plugin;
  // ConfigManager is available via super.configManager

  private final SecretGenerator secretGenerator = new DefaultSecretGenerator();
  private final RecoveryCodeGenerator codesGenerator = new RecoveryCodeGenerator();

  /**
   * Constructs the TotpCommand.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param databaseService Service for database interactions.
   * @param authenticationService Service for authentication logic.
   * @param configManager Service for accessing configuration.
   */
  public TotpCommand(
      LimboAuth plugin,
      DatabaseService databaseService,
      AuthenticationService authenticationService,
      ConfigManager configManager) {
    super(configManager);
    this.plugin = plugin;
    this.logger = this.plugin.getLogger();
    this.databaseService = databaseService;
    this.authenticationService = authenticationService;
  }

  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    if (!(source instanceof Player)) {
      source.sendMessage(
          configManager
              .getSerializer()
              .deserialize(configManager.getSettings().MAIN.STRINGS.NOT_PLAYER));
      return;
    }

    Player commandPlayer = (Player) source;
    Settings currentSettings = this.configManager.getSettings();
    Serializer currentSerializer = this.configManager.getSerializer();

    final Component usageMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_USAGE);
    final Component notRegisteredMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.NOT_REGISTERED);
    final Component wrongPasswordMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.WRONG_PASSWORD);
    final Component alreadyEnabledMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_ALREADY_ENABLED);
    final Component errorOccurredMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.ERROR_OCCURRED);
    final Component successfulEnableMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_SUCCESSFUL);
    final Component qrMsg = currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_QR);
    final String tokenMsgFormat = currentSettings.MAIN.STRINGS.TOTP_TOKEN;
    final String recoveryMsgFormat = currentSettings.MAIN.STRINGS.TOTP_RECOVERY;
    final Component disabledMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_DISABLED);
    final Component wrongCodeMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.TOTP_WRONG);
    final Component crackedCommandMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.CRACKED_COMMAND);

    if (args.length == 0) {
      source.sendMessage(usageMsg);
      return;
    }

    String usernameLowercase = commandPlayer.getUsername().toLowerCase(Locale.ROOT);
    RegisteredPlayer registeredPlayer =
        this.databaseService.findPlayerByLowercaseNickname(usernameLowercase);

    if (args[0].equalsIgnoreCase("enable")) {
      boolean needsPasswordCheck = currentSettings.MAIN.TOTP_NEED_PASSWORD;
      if ((needsPasswordCheck && args.length != 2) || (!needsPasswordCheck && args.length != 1)) {
        source.sendMessage(usageMsg);
        return;
      }

      if (registeredPlayer == null) {
        source.sendMessage(notRegisteredMsg);
        return;
      }
      if (registeredPlayer
          .getHash()
          .isEmpty()) { // Premium accounts generally don't use TOTP this way
        source.sendMessage(crackedCommandMsg);
        return;
      }
      if (needsPasswordCheck && !authenticationService.checkPassword(args[1], registeredPlayer)) {
        source.sendMessage(wrongPasswordMsg);
        return;
      }
      if (registeredPlayer.getTotpToken() != null && !registeredPlayer.getTotpToken().isEmpty()) {
        source.sendMessage(alreadyEnabledMsg);
        return;
      }

      String secret = this.secretGenerator.generate();
      try {
        registeredPlayer.setTotpToken(secret);
        this.databaseService.updatePlayer(registeredPlayer);

        source.sendMessage(successfulEnableMsg);
        QrData data =
            new QrData.Builder()
                .label(commandPlayer.getUsername())
                .secret(secret)
                .issuer(currentSettings.MAIN.TOTP_ISSUER)
                .build();
        String qrUrl =
            currentSettings.MAIN.QR_GENERATOR_URL.replace(
                "{data}", URLEncoder.encode(data.getUri(), StandardCharsets.UTF_8));
        source.sendMessage(qrMsg.clickEvent(ClickEvent.openUrl(qrUrl)));

        source.sendMessage(
            currentSerializer
                .deserialize(MessageFormat.format(tokenMsgFormat, secret))
                .clickEvent(ClickEvent.copyToClipboard(secret)));
        String codes =
            String.join(
                ", ",
                this.codesGenerator.generateCodes(currentSettings.MAIN.TOTP_RECOVERY_CODES_AMOUNT));
        source.sendMessage(
            currentSerializer
                .deserialize(MessageFormat.format(recoveryMsgFormat, codes))
                .clickEvent(ClickEvent.copyToClipboard(codes)));

      } catch (SQLRuntimeException e) {
        this.logger.error("SQL error enabling TOTP for {}:", usernameLowercase, e);
        source.sendMessage(errorOccurredMsg);
      } catch (Exception e) {
        this.logger.error("Unexpected error enabling TOTP for {}:", usernameLowercase, e);
        source.sendMessage(errorOccurredMsg);
      }

    } else if (args[0].equalsIgnoreCase("disable")) {
      if (args.length != 2) { // Always needs <key>
        source.sendMessage(usageMsg);
        return;
      }
      if (registeredPlayer == null) {
        source.sendMessage(notRegisteredMsg);
        return;
      }
      if (registeredPlayer.getTotpToken() == null || registeredPlayer.getTotpToken().isEmpty()) {
        source.sendMessage(
            currentSerializer.deserialize(
                currentSettings.MAIN.STRINGS.TOTP_NOT_ENABLED)); // Add this string
        return;
      }

      if (AuthSessionHandler.TOTP_CODE_VERIFIER.isValidCode(
          registeredPlayer.getTotpToken(), args[1])) {
        try {
          registeredPlayer.setTotpToken("");
          this.databaseService.updatePlayer(registeredPlayer);
          source.sendMessage(disabledMsg);
        } catch (SQLRuntimeException e) {
          this.logger.error("SQL error disabling TOTP for {}:", usernameLowercase, e);
          source.sendMessage(errorOccurredMsg);
        }
      } else {
        source.sendMessage(wrongCodeMsg);
      }
    } else {
      source.sendMessage(usageMsg);
    }
  }

  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    return super.configManager
        .getCommandPermissionState()
        .TOTP
        .hasPermission(invocation.source(), "limboauth.commands.totp");
  }
}

```

`src/main/java/net/elytrium/limboauth/command/UnregisterCommand.java`:

```java
package net.elytrium.limboauth.command;

import com.velocitypowered.api.command.CommandSource;
import com.velocitypowered.api.command.SimpleCommand;
import com.velocitypowered.api.proxy.Player;
import java.util.Locale;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.event.AuthUnregisterEvent;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.model.SQLRuntimeException;
import net.elytrium.limboauth.service.AuthenticationService;
import net.elytrium.limboauth.service.CacheManager;
import net.elytrium.limboauth.service.ConfigManager;
import net.elytrium.limboauth.service.DatabaseService;
import net.kyori.adventure.text.Component;
import org.slf4j.Logger;

/**
 * Command for players to unregister their own account. Requires password confirmation and handles
 * database deletion, cache invalidation, and disconnecting the player.
 */
public class UnregisterCommand extends RatelimitedCommand {

  private final LimboAuth plugin;
  private final Logger logger;
  private final DatabaseService databaseService;
  private final AuthenticationService authenticationService;
  private final CacheManager cacheManager;

  /**
   * Constructs the UnregisterCommand.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param databaseService Service for database interactions.
   * @param authenticationService Service for authentication logic.
   * @param cacheManager Service for managing caches.
   * @param configManager Service for accessing configuration.
   */
  public UnregisterCommand(
      LimboAuth plugin,
      DatabaseService databaseService,
      AuthenticationService authenticationService,
      CacheManager cacheManager,
      ConfigManager configManager) {
    super(configManager);
    this.plugin = plugin;
    this.logger = this.plugin.getLogger();
    this.databaseService = databaseService;
    this.authenticationService = authenticationService;
    this.cacheManager = cacheManager;
  }

  @Override
  protected void execute(
      CommandSource source, String[] args, Component ratelimitedMessageComponent) {
    if (!(source instanceof Player)) {
      source.sendMessage(
          configManager
              .getSerializer()
              .deserialize(configManager.getSettings().MAIN.STRINGS.NOT_PLAYER));
      return;
    }

    Player commandPlayer = (Player) source;
    Settings currentSettings = this.configManager.getSettings();
    Serializer currentSerializer = this.configManager.getSerializer();

    final String confirmKeyword = currentSettings.MAIN.CONFIRM_KEYWORD;
    final Component usageMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.UNREGISTER_USAGE);
    final Component notRegisteredMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.NOT_REGISTERED);
    final Component crackedCommandMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.CRACKED_COMMAND);
    final Component wrongPasswordMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.WRONG_PASSWORD);
    final Component successfulMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.UNREGISTER_SUCCESSFUL);
    final Component errorOccurredMsg =
        currentSerializer.deserialize(currentSettings.MAIN.STRINGS.ERROR_OCCURRED);

    if (args.length != 2 || !confirmKeyword.equalsIgnoreCase(args[1])) {
      source.sendMessage(usageMsg);
      return;
    }

    String username = commandPlayer.getUsername();
    String usernameLowercase = username.toLowerCase(Locale.ROOT);
    RegisteredPlayer registeredPlayer =
        this.databaseService.findPlayerByLowercaseNickname(usernameLowercase);

    if (registeredPlayer == null) {
      source.sendMessage(notRegisteredMsg);
      return;
    }
    if (registeredPlayer.getHash().isEmpty()) {
      source.sendMessage(crackedCommandMsg);
      return;
    }

    if (!authenticationService.checkPassword(args[0], registeredPlayer)) {
      source.sendMessage(wrongPasswordMsg);
      return;
    }

    try {
      this.plugin.getServer().getEventManager().fireAndForget(new AuthUnregisterEvent(username));
      this.databaseService.deletePlayerByLowercaseNickname(usernameLowercase);
      this.cacheManager.removeAuthUserFromCache(username);
      commandPlayer.disconnect(successfulMsg);
    } catch (SQLRuntimeException e) {
      this.logger.error("SQL error during unregister for {}:", usernameLowercase, e);
      source.sendMessage(errorOccurredMsg);
    } catch (Exception e) {
      this.logger.error("Unexpected error during unregister for {}:", usernameLowercase, e);
      source.sendMessage(errorOccurredMsg);
    }
  }

  @Override
  public boolean hasPermission(SimpleCommand.Invocation invocation) {
    return this.configManager
        .getCommandPermissionState()
        .UNREGISTER
        .hasPermission(invocation.source(), "limboauth.commands.unregister");
  }
}

```

`src/main/java/net/elytrium/limboauth/dependencies/BaseLibrary.java`:

```java
package net.elytrium.limboauth.dependencies;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;

/**
 * Enum representing external library dependencies required by the this.plugin. It handles the
 * downloading and providing of URLs for these libraries.
 */
public enum BaseLibrary {
  H2_V1("com.h2database", "h2", "1.4.200"),
  H2_V2("com.h2database", "h2", "2.3.232"),
  MYSQL("com.mysql", "mysql-connector-j", "8.0.33"),
  MARIADB("org.mariadb.jdbc", "mariadb-java-client", "3.1.4"),
  POSTGRESQL("org.postgresql", "postgresql", "42.5.1"),
  SQLITE("org.xerial", "sqlite-jdbc", "3.40.0.0");

  private final Path filenamePath;
  private final URL mavenRepoURL;

  BaseLibrary(String groupId, String artifactId, String version) {
    String mavenPath =
        String.format(
            "%s/%s/%s/%s-%s.jar",
            groupId.replace(".", "/"), artifactId, version, artifactId, version);

    this.filenamePath = Path.of("libraries/" + mavenPath);

    try {
      this.mavenRepoURL = new URL("https://repo1.maven.org/maven2/" + mavenPath);
    } catch (MalformedURLException e) {
      throw new IllegalArgumentException(e);
    }
  }

  /**
   * Retrieves the URL for this library, downloading it from Maven Central if not already present.
   *
   * @return The URL to the local JAR file of the library.
   * @throws MalformedURLException if the generated file path results in a malformed URL.
   * @throws IllegalArgumentException if an IOException occurs during download or file creation.
   */
  @SuppressFBWarnings("NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE")
  public URL getClassLoaderURL() throws MalformedURLException {
    if (!Files.exists(this.filenamePath)) {
      try {
        try (InputStream in = this.mavenRepoURL.openStream()) {
          Files.createDirectories(this.filenamePath.getParent());
          Files.copy(in, Files.createFile(this.filenamePath), StandardCopyOption.REPLACE_EXISTING);
        }
      } catch (IOException e) {
        throw new IllegalArgumentException(e);
      }
    }

    return this.filenamePath.toUri().toURL();
  }
}

```

`src/main/java/net/elytrium/limboauth/dependencies/DatabaseLibrary.java`:

```java
package net.elytrium.limboauth.dependencies;

import com.j256.ormlite.jdbc.JdbcPooledConnectionSource;
import com.j256.ormlite.jdbc.db.DatabaseTypeUtils;
import com.j256.ormlite.support.ConnectionSource;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.Method;
import java.net.URISyntaxException;
import java.net.URL;
import java.nio.file.Files;
import java.nio.file.Path;
import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverManager;
import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.Locale;
import java.util.Properties;

/**
 * Enum representing the supported database types and their connection logic. It manages JDBC driver
 * loading, connection string generation, and ORMLite connection source setup.
 */
public enum DatabaseLibrary {
  /** H2 Database legacy version 1. */
  H2_LEGACY_V1(
      BaseLibrary.H2_V1,
      (classLoader, dir, jdbc, user, password) ->
          fromDriver(classLoader.loadClass("org.h2.Driver"), jdbc, null, null, false),
      (dir, hostname, database) -> "jdbc:h2:" + dir + "/limboauth"),
  /** H2 Database current version. */
  H2(
      BaseLibrary.H2_V2,
      (classLoader, dir, jdbc, user, password) -> {
        Connection modernConnection =
            fromDriver(classLoader.loadClass("org.h2.Driver"), jdbc, null, null, true);

        Path legacyDatabase = dir.resolve("limboauth.mv.db");
        if (Files.exists(legacyDatabase)) {
          Path dumpFile = dir.resolve("limboauth.dump.sql");
          try (Connection legacyConnection =
              H2_LEGACY_V1.connect(dir, null, null, user, password)) {
            try (PreparedStatement migrateStatement =
                legacyConnection.prepareStatement(
                    "SCRIPT TO ?")) { // FIXED: Removed single quotes from placeholder
              migrateStatement.setString(1, dumpFile.toString());
              migrateStatement.execute();
            }
          }

          try (PreparedStatement migrateStatement =
              modernConnection.prepareStatement(
                  "RUNSCRIPT FROM ?")) { // FIXED: Removed single quotes from placeholder
            migrateStatement.setString(1, dumpFile.toString());
            migrateStatement.execute();
          }

          Files.delete(dumpFile);
          Files.move(legacyDatabase, dir.resolve("limboauth-v1-backup.mv.db"));
        }

        return modernConnection;
      },
      (dir, hostname, database) -> "jdbc:h2:" + dir + "/limboauth-v2"),
  /** MySQL database support. */
  MYSQL(
      BaseLibrary.MYSQL,
      (classLoader, dir, jdbc, user, password) ->
          fromDriver(
              classLoader.loadClass("com.mysql.cj.jdbc.NonRegisteringDriver"),
              jdbc,
              user,
              password,
              true),
      (dir, hostname, database) -> "jdbc:mysql://" + hostname + "/" + database),
  /** MariaDB database support. */
  MARIADB(
      BaseLibrary.MARIADB,
      (classLoader, dir, jdbc, user, password) ->
          fromDriver(classLoader.loadClass("org.mariadb.jdbc.Driver"), jdbc, user, password, true),
      (dir, hostname, database) -> "jdbc:mariadb://" + hostname + "/" + database),
  /** PostgreSQL database support. */
  POSTGRESQL(
      BaseLibrary.POSTGRESQL,
      (classLoader, dir, jdbc, user, password) ->
          fromDriver(classLoader.loadClass("org.postgresql.Driver"), jdbc, user, password, true),
      (dir, hostname, database) -> "jdbc:postgresql://" + hostname + "/" + database),
  /** SQLite database support. */
  SQLITE(
      BaseLibrary.SQLITE,
      (classLoader, dir, jdbc, user, password) ->
          fromDriver(classLoader.loadClass("org.sqlite.JDBC"), jdbc, user, password, true),
      (dir, hostname, database) -> "jdbc:sqlite:" + dir + "/limboauth.db");

  private final BaseLibrary baseLibrary;
  private final DatabaseConnector connector;
  private final DatabaseStringGetter stringGetter;
  private final IsolatedDriver driver =
      new IsolatedDriver("jdbc:limboauth_" + this.name().toLowerCase(Locale.ROOT) + ":");

  DatabaseLibrary(
      BaseLibrary baseLibrary, DatabaseConnector connector, DatabaseStringGetter stringGetter) {
    this.baseLibrary = baseLibrary;
    this.connector = connector;
    this.stringGetter = stringGetter;
  }

  /**
   * Establishes a database connection using a specific class loader.
   *
   * @param classLoader The class loader to use for loading the JDBC driver.
   * @param dir The data directory, used for file-based databases like H2 and SQLite.
   * @param hostname The hostname for network-based databases.
   * @param database The database name/schema.
   * @param user The database username.
   * @param password The database password.
   * @return A {@link Connection} to the database.
   * @throws ReflectiveOperationException If there's an issue loading or instantiating the driver.
   * @throws SQLException If a database access error occurs.
   * @throws IOException If an I/O error occurs (e.g., downloading driver or accessing files).
   */
  public Connection connect(
      ClassLoader classLoader,
      Path dir,
      String hostname,
      String database,
      String user,
      String password)
      throws ReflectiveOperationException, SQLException, IOException {
    return this.connect(
        classLoader, dir, this.stringGetter.getJdbcString(dir, hostname, database), user, password);
  }

  /**
   * Establishes a database connection using an isolated class loader for the driver.
   *
   * @param dir The data directory.
   * @param hostname The hostname.
   * @param database The database name.
   * @param user The username.
   * @param password The password.
   * @return A {@link Connection} to the database.
   * @throws ReflectiveOperationException If driver loading fails.
   * @throws SQLException If database access fails.
   * @throws IOException If an I/O error occurs.
   */
  public Connection connect(
      Path dir, String hostname, String database, String user, String password)
      throws ReflectiveOperationException, SQLException, IOException {
    return this.connect(
        dir, this.stringGetter.getJdbcString(dir, hostname, database), user, password);
  }

  /**
   * Establishes a database connection using a specific class loader and JDBC URL.
   *
   * @param classLoader The class loader.
   * @param dir The data directory.
   * @param jdbc The JDBC connection string.
   * @param user The username.
   * @param password The password.
   * @return A {@link Connection} to the database.
   * @throws ReflectiveOperationException If driver loading fails.
   * @throws SQLException If database access fails.
   * @throws IOException If an I/O error occurs.
   */
  /**
   * Establishes database connection.
   *
   * @param classLoader Class loader for JDBC driver
   * @param dir Data directory path
   * @param jdbc JDBC connection string
   * @param user Database username
   * @param password Database password
   * @return Database connection
   * @throws SQLException if connection fails
   */
  Connection connect(ClassLoader classLoader, Path dir, String jdbc, String user, String password)
      throws ReflectiveOperationException, SQLException, IOException {
    return this.connector.connect(classLoader, dir, jdbc, user, password);
  }

  /**
   * Establishes a database connection using an isolated class loader and JDBC URL.
   *
   * @param dir The data directory.
   * @param jdbc The JDBC connection string.
   * @param user The username.
   * @param password The password.
   * @return A {@link Connection} to the database.
   * @throws IOException If an I/O error occurs.
   * @throws ReflectiveOperationException If driver loading fails.
   * @throws SQLException If database access fails.
   */
  public Connection connect(Path dir, String jdbc, String user, String password)
      throws IOException, ReflectiveOperationException, SQLException {
    return this.connector.connect(
        new IsolatedClassLoader(new URL[] {this.baseLibrary.getClassLoaderURL()}),
        dir,
        jdbc,
        user,
        password);
  }

  /**
   * Creates an ORMLite {@link ConnectionSource} for this database type. This involves loading the
   * driver in an isolated class loader if not already done and registering an {@link
   * IsolatedDriver} wrapper.
   *
   * @param dir The data directory.
   * @param hostname The hostname.
   * @param database The database name.
   * @param user The username.
   * @param password The password.
   * @return A {@link ConnectionSource} for ORMLite.
   * @throws ReflectiveOperationException If driver loading/instantiation fails.
   * @throws IOException If an I/O error occurs.
   * @throws SQLException If database access fails.
   * @throws URISyntaxException If the JDBC URL is invalid.
   */
  public ConnectionSource connectToORM(
      Path dir, String hostname, String database, String user, String password)
      throws ReflectiveOperationException, IOException, SQLException, URISyntaxException {
    if (this.driver.getOriginal() == null) {
      IsolatedClassLoader classLoader =
          new IsolatedClassLoader(new URL[] {this.baseLibrary.getClassLoaderURL()});
      Class<?> driverClass =
          classLoader.loadClass(
              switch (this) {
                case H2_LEGACY_V1, H2 -> "org.h2.Driver";
                case MYSQL -> "com.mysql.cj.jdbc.NonRegisteringDriver";
                case MARIADB -> "org.mariadb.jdbc.Driver";
                case POSTGRESQL -> "org.postgresql.Driver";
                case SQLITE -> "org.sqlite.JDBC";
              });

      this.driver.setOriginal((Driver) driverClass.getConstructor().newInstance());
      DriverManager.registerDriver(this.driver);
    }

    String jdbc = this.stringGetter.getJdbcString(dir, hostname, database);
    boolean h2 = this.baseLibrary == BaseLibrary.H2_V1 || this.baseLibrary == BaseLibrary.H2_V2;
    return new JdbcPooledConnectionSource(
        this.driver.getInitializer() + jdbc,
        h2 ? null : user,
        h2 ? null : password,
        DatabaseTypeUtils.createDatabaseType(jdbc));
  }

  private static Connection fromDriver(
      Class<?> connectionClass, String jdbc, String user, String password, boolean register)
      throws ReflectiveOperationException, SQLException {
    Constructor<?> legacyConstructor = connectionClass.getConstructor();

    Properties info = new Properties();
    if (user != null) {
      info.put("user", user);
    }

    if (password != null) {
      info.put("password", password);
    }

    Object driver = legacyConstructor.newInstance();

    DriverManager.deregisterDriver((Driver) driver);
    if (register) {
      DriverManager.registerDriver((Driver) driver);
    }

    Method connect = connectionClass.getDeclaredMethod("connect", String.class, Properties.class);
    connect.setAccessible(true);
    return (Connection) connect.invoke(driver, jdbc, info);
  }

  /** Functional interface for database connection logic. */
  public interface DatabaseConnector {
    /**
     * Establishes database connection.
     *
     * @param classLoader Class loader for JDBC driver
     * @param dir Data directory path
     * @param jdbc JDBC connection string
     * @param user Database username
     * @param password Database password
     * @return Database connection
     * @throws SQLException if connection fails
     */
    Connection connect(ClassLoader classLoader, Path dir, String jdbc, String user, String password)
        throws ReflectiveOperationException, SQLException, IOException;
  }

  /** Functional interface for generating JDBC connection strings. */
  public interface DatabaseStringGetter {
    /**
     * Generates JDBC connection string.
     *
     * @param dir Data directory path
     * @param hostname Database hostname
     * @param database Database name
     * @return JDBC connection string
     */
    String getJdbcString(Path dir, String hostname, String database);
  }
}

```

`src/main/java/net/elytrium/limboauth/dependencies/IsolatedClassLoader.java`:

```java
package net.elytrium.limboauth.dependencies;

import java.net.URL;
import java.net.URLClassLoader;

/**
 * A custom {@link URLClassLoader} designed to load classes in isolation. It prioritizes loading
 * from its own URLs before delegating to the parent classloader, effectively isolating the loaded
 * classes from the main application's classpath. This is particularly useful for managing different
 * versions of libraries or JDBC drivers.
 */
public class IsolatedClassLoader extends URLClassLoader {

  /**
   * Constructs an IsolatedClassLoader with the specified URLs and a parent classloader set to the
   * system classloader's parent (usually the bootstrap classloader), promoting isolation.
   *
   * @param urls The URLs from which to load classes and resources.
   */
  /** Default constructor. */
  public IsolatedClassLoader(URL[] urls) {
    super(urls, ClassLoader.getSystemClassLoader().getParent());
  }

  static {
    // Enables parallel class loading capabilities if supported by the JVM.
    ClassLoader.registerAsParallelCapable();
  }
}

```

`src/main/java/net/elytrium/limboauth/dependencies/IsolatedDriver.java`:

```java
package net.elytrium.limboauth.dependencies;

import java.sql.Connection;
import java.sql.Driver;
import java.sql.DriverPropertyInfo;
import java.sql.SQLException;
import java.sql.SQLFeatureNotSupportedException;
import java.util.Properties;
import java.util.logging.Logger;

/**
 * A wrapper around a standard JDBC {@link Driver} that allows it to be registered with a custom URL
 * prefix. This enables the use of multiple versions or types of JDBC drivers that might otherwise
 * conflict if registered directly with {@link java.sql.DriverManager}. The {@code IsolatedDriver}
 * delegates calls to the "original" driver after stripping its custom URL prefix.
 */
public class IsolatedDriver implements Driver {

  private final String initializer;
  private Driver original;

  /**
   * Constructs an IsolatedDriver with a specific URL initializer prefix.
   *
   * @param initializer The custom URL prefix (e.g., "jdbc:limboauth_h2:"). Connection URLs starting
   *     with this prefix will be handled by this driver.
   */
  /** Default constructor. */
  public IsolatedDriver(String initializer) {
    this.initializer = initializer;
  }

  /**
   * Gets the URL initializer prefix for this driver.
   *
   * @return The initializer string.
   */
  public String getInitializer() {
    return this.initializer;
  }

  /**
   * Gets the original, wrapped JDBC driver.
   *
   * @return The original {@link Driver} instance.
   */
  public Driver getOriginal() {
    return this.original;
  }

  /**
   * Sets the original JDBC driver to be wrapped.
   *
   * @param driver The {@link Driver} to wrap.
   */
  public void setOriginal(Driver driver) {
    this.original = driver;
  }

  @Override
  public Connection connect(String url, Properties info) throws SQLException {
    if (url.startsWith(this.initializer)) {
      return this.original.connect(url.substring(this.initializer.length()), info);
    }
    return null;
  }

  @Override
  public boolean acceptsURL(String url) throws SQLException {
    if (url.startsWith(this.initializer)) {
      if (this.original == null) {
        return false;
      }
      return this.original.acceptsURL(url.substring(this.initializer.length()));
    }
    return false;
  }

  @Override
  public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) throws SQLException {
    if (url.startsWith(this.initializer)) {
      return this.original.getPropertyInfo(url.substring(this.initializer.length()), info);
    }
    return new DriverPropertyInfo[0];
  }

  @Override
  public int getMajorVersion() {
    return this.original.getMajorVersion();
  }

  @Override
  public int getMinorVersion() {
    return this.original.getMinorVersion();
  }

  @Override
  public boolean jdbcCompliant() {
    return this.original.jdbcCompliant();
  }

  @Override
  public Logger getParentLogger() throws SQLFeatureNotSupportedException {
    return this.original.getParentLogger();
  }
}

```

`src/main/java/net/elytrium/limboauth/event/AuthPluginReloadEvent.java`:

```java
package net.elytrium.limboauth.event;

/**
 * Event fired when the LimboAuth plugin is reloaded. This event allows other plugins to react to
 * configuration changes and update their internal state accordingly.
 */
public class AuthPluginReloadEvent {

  /** Default constructor for AuthPluginReloadEvent. Creates a new instance of the reload event. */
  public AuthPluginReloadEvent() {
    // Default constructor
  }
}

```

`src/main/java/net/elytrium/limboauth/event/AuthUnregisterEvent.java`:

```java
package net.elytrium.limboauth.event;

/**
 * Event fired when a player is unregistered from the LimboAuth system. This event occurs before the
 * player's data is actually removed from the database. It can be used to perform actions related to
 * a player's unregistration, such as cleaning up data in other systems or logging the event.
 */
public class AuthUnregisterEvent {

  private final String nickname;

  /**
   * Constructs an AuthUnregisterEvent.
   *
   * @param nickname The nickname of the player being unregistered.
   */
  /** Default constructor. */
  public AuthUnregisterEvent(String nickname) {
    this.nickname = nickname;
  }

  /**
   * Gets the nickname of the player being unregistered.
   *
   * @return The player's nickname.
   */
  public String getNickname() {
    return this.nickname;
  }
}

```

`src/main/java/net/elytrium/limboauth/event/ChangePasswordEvent.java`:

```java
package net.elytrium.limboauth.event;

import net.elytrium.limboauth.model.RegisteredPlayer;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 * Event fired when a player's password has been changed. This event provides information about the
 * player, their old password (if provided by the user, e.g. not a force-change), the old password
 * hash, the new password (plaintext, for logging/auditing if necessary), and the new password hash.
 *
 * <p>Caution: The new password is provided in plaintext. Handle this event and its data with care,
 * especially regarding logging or storing the plaintext password.
 */
public class ChangePasswordEvent {

  private final RegisteredPlayer playerInfo;
  @Nullable private final String oldPassword;
  private final String oldHash;
  private final String newPassword;
  private final String newHash;

  /**
   * Constructs a ChangePasswordEvent.
   *
   * @param playerInfo The {@link RegisteredPlayer} information for whom the password was changed.
   * @param oldPassword The old password in plaintext, if it was provided during the change process
   *     (e.g., not a forced change). May be {@code null}.
   * @param oldHash The old hashed password.
   * @param newPassword The new password in plaintext. Handle with care.
   * @param newHash The new hashed password.
   */
  public ChangePasswordEvent(
      RegisteredPlayer playerInfo,
      @Nullable String oldPassword,
      String oldHash,
      String newPassword,
      String newHash) {
    this.playerInfo = playerInfo;
    this.oldPassword = oldPassword;
    this.oldHash = oldHash;
    this.newPassword = newPassword;
    this.newHash = newHash;
  }

  /**
   * Gets the {@link RegisteredPlayer} information for the player whose password was changed.
   *
   * @return The player's registered information.
   */
  public RegisteredPlayer getPlayerInfo() {
    return this.playerInfo;
  }

  /**
   * Gets the old password in plaintext, if it was provided by the user during the change. This will
   * be {@code null} if the password change was forced by an administrator or if the old password
   * was not required/checked.
   *
   * @return The old plaintext password, or {@code null}.
   */
  @Nullable public String getOldPassword() {
    return this.oldPassword;
  }

  /**
   * Gets the old hashed password.
   *
   * @return The old password hash.
   */
  public String getOldHash() {
    return this.oldHash;
  }

  /**
   * Gets the new password in plaintext.
   *
   * <p><strong>Caution:</strong> Handle this with care. Avoid logging or storing plaintext
   * passwords.
   *
   * @return The new plaintext password.
   */
  public String getNewPassword() {
    return this.newPassword;
  }

  /**
   * Gets the new hashed password.
   *
   * @return The new password hash.
   */
  public String getNewHash() {
    return this.newHash;
  }
}

```

`src/main/java/net/elytrium/limboauth/event/PostAuthorizationEvent.java`:

```java
package net.elytrium.limboauth.event;

import java.util.function.Consumer;
import net.elytrium.limboapi.api.player.LimboPlayer;
import net.elytrium.limboauth.model.RegisteredPlayer;

/**
 * Event fired after a player has successfully completed the authorization (login) process. This
 * event occurs after password checks and any other login-specific validations (like 2FA if
 * applicable) have passed.
 *
 * <p>This is an asynchronous event. Handlers can perform actions that might take time, such as
 * database lookups or external API calls. The main authentication flow will wait for this event to
 * complete (or be cancelled) before proceeding. The player is typically still in the Limbo world
 * when this event is fired.
 */
public class PostAuthorizationEvent extends PostEvent {

  /**
   * Constructs a PostAuthorizationEvent.
   *
   * @param onComplete A consumer to be called when this event's processing is finished or
   *     cancelled.
   * @param player The {@link LimboPlayer} who has been authorized.
   * @param playerInfo The {@link RegisteredPlayer} data for the authorized player.
   * @param password The password used for authorization (if applicable, handle with care).
   */
  public PostAuthorizationEvent(
      Consumer<TaskEvent> onComplete,
      LimboPlayer player,
      RegisteredPlayer playerInfo,
      String password) {
    super(onComplete, player, playerInfo, password);
  }
}

```

`src/main/java/net/elytrium/limboauth/event/PostEvent.java`:

```java
package net.elytrium.limboauth.event;

import java.util.function.Consumer;
import net.elytrium.limboapi.api.player.LimboPlayer;
import net.elytrium.limboauth.model.RegisteredPlayer;

/**
 * Abstract base class for "post" authentication events, which are fired after a primary
 * authentication action (like registration or login) has occurred and potentially after the
 * player's data has been persisted or updated.
 *
 * <p>These events are typically asynchronous and allow for further actions or modifications before
 * the player is fully passed through to the main server network.
 */
public abstract class PostEvent extends TaskEvent {

  private final LimboPlayer player;
  private final RegisteredPlayer playerInfo;
  private final String password;

  /**
   * Constructs a PostEvent.
   *
   * @param onComplete A consumer called when this event's processing is done or cancelled.
   * @param player The {@link LimboPlayer} involved in the event.
   * @param playerInfo The {@link RegisteredPlayer} data associated with the player.
   * @param password The password used in the preceding action (handle with care).
   */
  protected PostEvent(
      Consumer<TaskEvent> onComplete,
      LimboPlayer player,
      RegisteredPlayer playerInfo,
      String password) {
    super(onComplete);

    this.player = player;
    this.playerInfo = playerInfo;
    this.password = password;
  }

  /**
   * Constructs a PostEvent with an initial result.
   *
   * @param onComplete A consumer called when this event's processing is done or cancelled.
   * @param result The initial {@link Result} of this event.
   * @param player The {@link LimboPlayer} involved in the event.
   * @param playerInfo The {@link RegisteredPlayer} data associated with the player.
   * @param password The password used in the preceding action (handle with care).
   */
  protected PostEvent(
      Consumer<TaskEvent> onComplete,
      Result result,
      LimboPlayer player,
      RegisteredPlayer playerInfo,
      String password) {
    super(onComplete, result);

    this.player = player;
    this.playerInfo = playerInfo;
    this.password = password;
  }

  /**
   * Gets the {@link LimboPlayer} associated with this event.
   *
   * @return The LimboPlayer.
   */
  public LimboPlayer getPlayer() {
    return this.player;
  }

  /**
   * Gets the {@link RegisteredPlayer} data for the player involved in this event.
   *
   * @return The registered player information.
   */
  public RegisteredPlayer getPlayerInfo() {
    return this.playerInfo;
  }

  /**
   * Gets the password that was used in the authentication action preceding this event.
   *
   * <p><strong>Caution:</strong> This is a plaintext password. Handle with extreme care and avoid
   * logging or storing it unnecessarily.
   *
   * @return The plaintext password, or an empty string/null if not applicable.
   */
  public String getPassword() {
    return this.password;
  }
}

```

`src/main/java/net/elytrium/limboauth/event/PostRegisterEvent.java`:

```java
package net.elytrium.limboauth.event;

import java.util.function.Consumer;
import net.elytrium.limboapi.api.player.LimboPlayer;
import net.elytrium.limboauth.model.RegisteredPlayer;

/**
 * Event fired after a player has successfully completed the registration process and their data has
 * been saved to the database.
 *
 * <p>This is an asynchronous event. Handlers can perform actions that might take time, such as
 * database lookups or external API calls. The main authentication flow will wait for this event to
 * complete (or be cancelled) before proceeding. The player is typically still in the Limbo world
 * when this event is fired.
 */
public class PostRegisterEvent extends PostEvent {

  /**
   * Constructs a PostRegisterEvent.
   *
   * @param onComplete A consumer to be called when this event's processing is finished or
   *     cancelled.
   * @param player The {@link LimboPlayer} who has been registered.
   * @param playerInfo The {@link RegisteredPlayer} data for the newly registered player.
   * @param password The password used for registration (handle with care).
   */
  public PostRegisterEvent(
      Consumer<TaskEvent> onComplete,
      LimboPlayer player,
      RegisteredPlayer playerInfo,
      String password) {
    super(onComplete, player, playerInfo, password);
  }
}

```

`src/main/java/net/elytrium/limboauth/event/PreAuthorizationEvent.java`:

```java
package net.elytrium.limboauth.event;

import com.velocitypowered.api.proxy.Player;
import java.util.function.Consumer;
import net.elytrium.limboauth.model.RegisteredPlayer;

/**
 * Event fired before a player attempts to authorize (log in). This event occurs after the system
 * has identified that the player is registered but before any password or 2FA checks are performed.
 *
 * <p>This is an asynchronous event. Handlers can perform actions that might take time, such as
 * database lookups or external API calls. The main authentication flow will wait for this event to
 * complete (or be cancelled) before proceeding with login checks. Handlers can cancel this event to
 * prevent the player from attempting to log in, or modify its result to bypass standard login
 * procedures.
 */
public class PreAuthorizationEvent extends PreEvent {

  private final RegisteredPlayer playerInfo;

  /**
   * Constructs a PreAuthorizationEvent.
   *
   * @param onComplete A consumer to be called when this event's processing is finished or
   *     cancelled.
   * @param result The initial {@link Result} of this event.
   * @param player The {@link Player} attempting to authorize.
   * @param playerInfo The {@link RegisteredPlayer} data for the player.
   */
  public PreAuthorizationEvent(
      Consumer<TaskEvent> onComplete, Result result, Player player, RegisteredPlayer playerInfo) {
    super(onComplete, result, player);

    this.playerInfo = playerInfo;
  }

  /**
   * Gets the {@link RegisteredPlayer} data for the player attempting to authorize.
   *
   * @return The registered player information.
   */
  public RegisteredPlayer getPlayerInfo() {
    return this.playerInfo;
  }
}

```

`src/main/java/net/elytrium/limboauth/event/PreEvent.java`:

```java
package net.elytrium.limboauth.event;

import com.velocitypowered.api.proxy.Player;
import java.util.function.Consumer;

/**
 * Abstract base class for "pre" authentication events, which are fired before a primary
 * authentication action (like registration or login) is fully processed.
 *
 * <p>These events are typically asynchronous and allow for cancellation or modification of the
 * authentication flow before it proceeds to more intensive checks or database operations.
 */
public abstract class PreEvent extends TaskEvent {

  private final Player player;

  /**
   * Constructs a PreEvent.
   *
   * @param onComplete A consumer called when this event's processing is done or cancelled.
   * @param result The initial {@link Result} of this event.
   * @param player The {@link Player} involved in the event.
   */
  protected PreEvent(Consumer<TaskEvent> onComplete, Result result, Player player) {
    super(onComplete, result);

    this.player = player;
  }

  /**
   * Gets the {@link Player} associated with this event.
   *
   * @return The Velocity Player.
   */
  public Player getPlayer() {
    return this.player;
  }
}

```

`src/main/java/net/elytrium/limboauth/event/PreRegisterEvent.java`:

```java
package net.elytrium.limboauth.event;

import com.velocitypowered.api.proxy.Player;
import java.util.function.Consumer;

/**
 * Event fired before a new player attempts to register. This event occurs after initial checks
 * (like nickname validation) but before the player is prompted for a password or their data is
 * saved to the database.
 *
 * <p>This is an asynchronous event. Handlers can perform actions that might take time, such as
 * checking against an external whitelist or performing additional validation. The main registration
 * flow will wait for this event to complete (or be cancelled) before proceeding. Handlers can
 * cancel this event to prevent the player from attempting to register, or modify its result to
 * bypass standard registration procedures.
 */
public class PreRegisterEvent extends PreEvent {

  /**
   * Constructs a PreRegisterEvent.
   *
   * @param onComplete A consumer to be called when this event's processing is finished or
   *     cancelled.
   * @param result The initial {@link Result} of this event.
   * @param player The {@link Player} attempting to register.
   */
  /** Default constructor. */
  public PreRegisterEvent(Consumer<TaskEvent> onComplete, Result result, Player player) {
    super(onComplete, result, player);
  }
}

```

`src/main/java/net/elytrium/limboauth/event/TaskEvent.java`:

```java
package net.elytrium.limboauth.event;

import java.util.function.Consumer;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.limboauth.Settings;
import net.kyori.adventure.text.Component;
import org.jetbrains.annotations.NotNull;

/**
 * Abstract base class for LimboAuth events that represent a task or a stage in an authentication
 * flow, which can be completed, cancelled, or indicate a bypass.
 *
 * <p>These events are often asynchronous, allowing handlers to perform operations without blocking
 * the main server thread. The {@link #complete(Result)} or {@link #cancel(Component)} methods
 * should be called by handlers to signal the outcome of their processing.
 */
public abstract class TaskEvent {

  private static Component DEFAULT_REASON;

  private final Consumer<TaskEvent> onComplete;
  private Result result = Result.NORMAL;
  private Component reason; // Initialized with DEFAULT_REASON

  /**
   * Constructs a TaskEvent with a normal initial result and a callback for completion.
   *
   * @param onComplete A consumer to be called when this event's processing is finished or
   *     cancelled.
   */
  /** Default constructor. */
  public TaskEvent(Consumer<TaskEvent> onComplete) {
    this.onComplete = onComplete;
    this.reason = DEFAULT_REASON; // Initialize with the static default
  }

  /**
   * Constructs a TaskEvent with a specified initial result and a callback for completion.
   *
   * @param onComplete A consumer to be called when this event's processing is finished or
   *     cancelled.
   * @param result The initial {@link Result} of this event.
   */
  /** Default constructor. */
  public TaskEvent(Consumer<TaskEvent> onComplete, Result result) {
    this.onComplete = onComplete;
    this.result = result;
    this.reason = DEFAULT_REASON; // Initialize with the static default
  }

  /**
   * Marks this event as completed with the specified result. If the event was in a {@link
   * Result#WAIT} state, this will trigger the {@code onComplete} callback.
   *
   * @param result The final {@link Result} of the event processing. Cannot be null.
   */
  public void complete(@NotNull Result result) {
    if (this.result == Result.WAIT) {
      this.result = result;
      if (this.onComplete != null) {
        this.onComplete.accept(this);
      }
    }
  }

  /**
   * Marks this event as cancelled with a specific reason and completes it. If the event was in a
   * {@link Result#WAIT} state, this will set the result to {@link Result#CANCEL}, store the reason,
   * and trigger the {@code onComplete} callback.
   *
   * @param reason The {@link Component} explaining why the event was cancelled. Cannot be null.
   */
  public void completeAndCancel(@NotNull Component reason) {
    if (this.result == Result.WAIT) {
      this.cancel(reason);
      if (this.onComplete != null) {
        this.onComplete.accept(this);
      }
    }
  }

  /**
   * Cancels this event, setting its result to {@link Result#CANCEL} and providing a reason.
   *
   * @param reason The {@link Component} explaining why the event is being cancelled. Cannot be
   *     null.
   */
  public void cancel(@NotNull Component reason) {
    this.result = Result.CANCEL;
    this.reason = reason;
  }

  /**
   * Sets the result of this event.
   *
   * @param result The new {@link Result}. Cannot be null.
   */
  public void setResult(@NotNull Result result) {
    this.result = result;
  }

  /**
   * Gets the current result of this event.
   *
   * @return The current {@link Result}.
   */
  public Result getResult() {
    return this.result;
  }

  /**
   * Gets the reason for cancellation, if this event was cancelled.
   *
   * @return The cancellation reason {@link Component}, or the default reason if not explicitly set.
   */
  public Component getReason() {
    return this.reason;
  }

  /**
   * Reloads static resources for TaskEvents, specifically the default cancellation reason message.
   * This should be called when the plugin's configuration (and thus, its serializer) is reloaded.
   *
   * @param serializer The serializer instance from ConfigManager, used to deserialize the default
   *     reason string.
   */
  public static void reload(Serializer serializer) {
    DEFAULT_REASON = serializer.deserialize(Settings.IMP.MAIN.STRINGS.EVENT_CANCELLED);
  }

  /** Enum representing the possible outcomes or states of a {@link TaskEvent}. */
  public enum Result {
    /** The event/task was cancelled. */
    CANCEL,
    /** The event/task indicates that the standard flow should be bypassed. */
    BYPASS,
    /** The event/task should proceed normally. */
    NORMAL,
    /** The event/task is waiting for an asynchronous operation to complete. */
    WAIT
  }
}

```

`src/main/java/net/elytrium/limboauth/floodgate/FloodgateApiHolder.java`:

```java
package net.elytrium.limboauth.floodgate;

import java.util.UUID;
import org.geysermc.floodgate.api.FloodgateApi;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A holder class for the Floodgate API instance. This class safely initializes and provides access
 * to the Floodgate API, handling cases where Floodgate might not be present or an error occurs
 * during initialization.
 */
public class FloodgateApiHolder {

  private static final Logger LOGGER = LoggerFactory.getLogger(FloodgateApiHolder.class);
  private final FloodgateApi floodgateApi;

  /**
   * Constructs a FloodgateApiHolder and initializes the Floodgate API instance. Logs information
   * about the initialization status.
   */
  /** Default constructor. */
  public FloodgateApiHolder() {
    FloodgateApi apiInstance = null;
    try {
      apiInstance = FloodgateApi.getInstance();
      if (apiInstance != null) {
        LOGGER.info("FloodgateApi initialized successfully via getInstance().");
      } else {
        LOGGER.warn(
            "FloodgateApi.getInstance() returned null. Floodgate integration may not work.");
      }
    } catch (Exception e) {
      LOGGER.error(
          "Error obtaining FloodgateApi instance. Floodgate integration will be disabled.", e);
    } catch (NoClassDefFoundError e) {
      LOGGER.warn(
          "FloodgateApi class not found. Floodgate integration will be disabled. This is expected if Floodgate is not installed.");
    }
    this.floodgateApi = apiInstance;
  }

  /**
   * Checks if a player with the given UUID is a Floodgate (Bedrock) player.
   *
   * @param uuid The UUID of the player to check.
   * @return {@code true} if the player is a Floodgate player, {@code false} otherwise or if
   *     Floodgate API is unavailable.
   */
  public boolean isFloodgatePlayer(UUID uuid) {
    if (floodgateApi == null) {
      return false;
    }
    try {
      return floodgateApi.isFloodgatePlayer(uuid);
    } catch (Exception e) {
      LOGGER.error("Error checking if player {} is Floodgate player: {}", uuid, e.getMessage());
      return false;
    }
  }

  /**
   * Gets the length of the prefix used for Floodgate player usernames.
   *
   * @return The length of the Floodgate player prefix, or 0 if Floodgate API is unavailable or an
   *     error occurs.
   */
  public int getPrefixLength() {
    if (floodgateApi == null) {
      return 0;
    }
    try {
      return floodgateApi.getPlayerPrefix().length();
    } catch (Exception e) {
      LOGGER.error("Error getting Floodgate prefix length: {}", e.getMessage());
      return 0;
    }
  }

  /**
   * Gets the prefix string used for Floodgate player usernames.
   *
   * @return The Floodgate player prefix string, or an empty string if Floodgate API is unavailable
   *     or an error occurs.
   */
  public String getPlayerPrefix() {
    if (floodgateApi == null) {
      return "";
    }
    try {
      return floodgateApi.getPlayerPrefix();
    } catch (Exception e) {
      LOGGER.error("Error getting Floodgate player prefix: {}", e.getMessage());
      return "";
    }
  }

  /**
   * Gets the raw FloodgateApi instance.
   *
   * @return The {@link FloodgateApi} instance, or {@code null} if it's not available.
   */
  public FloodgateApi getApi() {
    return floodgateApi;
  }
}

```

`src/main/java/net/elytrium/limboauth/handler/AuthSessionHandler.java`:

```java
// File: LimboAuth/src/main/java/net/elytrium/limboauth/handler/AuthSessionHandler.java
package net.elytrium.limboauth.handler;

import com.velocitypowered.api.proxy.Player;
import com.velocitypowered.api.scheduler.ScheduledTask;
import com.velocitypowered.api.scheduler.TaskStatus;
import dev.samstevens.totp.code.CodeVerifier;
import dev.samstevens.totp.code.DefaultCodeGenerator;
import dev.samstevens.totp.code.DefaultCodeVerifier;
import dev.samstevens.totp.time.SystemTimeProvider;
import java.text.MessageFormat;
import java.util.Set;
import java.util.concurrent.TimeUnit;
import java.util.function.Consumer;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.limboapi.api.Limbo;
import net.elytrium.limboapi.api.LimboSessionHandler;
import net.elytrium.limboapi.api.player.LimboPlayer;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.event.PostAuthorizationEvent;
import net.elytrium.limboauth.event.PreAuthorizationEvent;
import net.elytrium.limboauth.event.TaskEvent;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.service.PlayerSessionService;
import net.kyori.adventure.bossbar.BossBar;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.title.Title;
import org.slf4j.Logger;

/** Handles authentication sessions for players in the Limbo world. */
public class AuthSessionHandler implements LimboSessionHandler {

  /**
   * Code verifier for TOTP (Time-based One-Time Password) authentication. Uses default code
   * generator and system time provider.
   */
  /**
   * TOTP code verifier instance for two-factor authentication. Uses default code generator with
   * system time provider for validating time-based one-time passwords.
   */
  public static final CodeVerifier TOTP_CODE_VERIFIER =
      new DefaultCodeVerifier(new DefaultCodeGenerator(), new SystemTimeProvider());

  private static Serializer serializer;
  private static Settings.MAIN settingsFramework;
  private static Set<String> unsafePasswordsFramework;

  private final LimboAuth plugin;
  private final Logger logger;
  private final Player player; // Velocity player
  private final PlayerSessionService playerSessionService;

  private LimboPlayer limboPlayer; // LimboAPI player
  private boolean passwordAuthenticated = false;
  private int loginAttempts = 0;
  private ScheduledTask timeoutTask;
  private BossBar activeBossBar;
  private ScheduledTask bossBarUpdateScheduleTask;

  /**
   * Constructs an AuthSessionHandler for a player.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param player The player being authenticated.
   * @param playerSessionService The service managing player sessions.
   */
  /**
   * Constructs a new AuthSessionHandler for the specified player.
   *
   * @param plugin The main LimboAuth plugin instance
   * @param player The player who needs to be authenticated
   * @param playerSessionService The service managing player sessions
   */
  public AuthSessionHandler(
      LimboAuth plugin, Player player, PlayerSessionService playerSessionService) {
    this.plugin = plugin;
    this.logger = this.plugin.getLogger();
    this.player = player;
    this.playerSessionService = playerSessionService;
  }

  /**
   * Reloads static configuration for AuthSessionHandler.
   *
   * @param newSerializer The new message serializer
   * @param newSettings The updated plugin settings
   * @param newUnsafePasswords Set of unsafe passwords
   */
  public static void reload(
      Serializer newSerializer, Settings newSettings, Set<String> newUnsafePasswords) {
    AuthSessionHandler.serializer = newSerializer;
    AuthSessionHandler.settingsFramework = newSettings.MAIN;
    AuthSessionHandler.unsafePasswordsFramework = newUnsafePasswords;
  }

  @Override
  public void onSpawn(Limbo server, LimboPlayer limboPlayer) {
    this.limboPlayer = limboPlayer;
    this.loginAttempts = 0;

    this.logger.debug(
        "Player {} spawned in authentication Limbo (AuthSessionHandler.onSpawn)",
        player.getUsername());

    setupAuthenticationTimeout();
    setupBossBar();

    if (playerSessionService.needsRegistration(player.getUsername())) {
      sendRegistrationPrompt();
    } else {
      sendLoginPrompt();
    }
  }

  private void setupAuthenticationTimeout() {
    if (timeoutTask != null
        && timeoutTask.status() != TaskStatus.CANCELLED
        && timeoutTask.status() != TaskStatus.FINISHED) {
      timeoutTask.cancel();
    }
    timeoutTask =
        this.plugin
            .getTaskSchedulingService()
            .scheduleOnce(
                () -> {
                  if (player.isActive() && limboPlayer != null) {
                    Component timeoutMessage =
                        serializer.deserialize(settingsFramework.STRINGS.TIMES_UP);
                    limboPlayer.disconnect(); // Disconnect LimboPlayer first
                    player.disconnect(timeoutMessage); // Then Velocity Player
                    this.playerSessionService.removeAuthenticatingPlayer(player.getUsername());
                  }
                },
                settingsFramework.AUTH_TIME,
                TimeUnit.MILLISECONDS);
  }

  private void setupBossBar() {
    if (!settingsFramework.ENABLE_BOSSBAR) {
      return;
    }
    if (activeBossBar != null) {
      player.hideBossBar(activeBossBar);
    }
    if (bossBarUpdateScheduleTask != null
        && bossBarUpdateScheduleTask.status() != TaskStatus.CANCELLED
        && bossBarUpdateScheduleTask.status() != TaskStatus.FINISHED) {
      bossBarUpdateScheduleTask.cancel();
    }

    activeBossBar =
        BossBar.bossBar(
            Component.empty(),
            1.0f,
            settingsFramework.BOSSBAR_COLOR,
            settingsFramework.BOSSBAR_OVERLAY);
    player.showBossBar(activeBossBar);
    startBossBarUpdates();
  }

  private void startBossBarUpdates() {
    final long totalAuthTimeSeconds = settingsFramework.AUTH_TIME / 1000;
    final long[] secondsRemaining = {totalAuthTimeSeconds};

    bossBarUpdateScheduleTask =
        this.plugin
            .getTaskSchedulingService()
            .scheduleRepeatingTask(
                () -> {
                  if (activeBossBar == null || !player.isActive() || limboPlayer == null) {
                    if (bossBarUpdateScheduleTask != null) bossBarUpdateScheduleTask.cancel();
                    if (activeBossBar != null) player.hideBossBar(activeBossBar);
                    activeBossBar = null;
                    return;
                  }

                  if (secondsRemaining[0] < 0) {
                    if (bossBarUpdateScheduleTask != null) bossBarUpdateScheduleTask.cancel();
                    if (activeBossBar != null) player.hideBossBar(activeBossBar);
                    activeBossBar = null;
                    // Optionally, trigger timeout logic here if not handled by timeoutTask
                    return;
                  }

                  String bossBarText =
                      MessageFormat.format(settingsFramework.STRINGS.BOSSBAR, secondsRemaining[0]);
                  activeBossBar.name(serializer.deserialize(bossBarText));
                  activeBossBar.progress(
                      Math.max(0.0f, (float) secondsRemaining[0] / totalAuthTimeSeconds));

                  secondsRemaining[0]--;
                },
                0,
                1000); // Run every second (1000 ms)
  }

  private void sendRegistrationPrompt() {
    Component message = serializer.deserialize(settingsFramework.STRINGS.REGISTER);
    Component title = serializer.deserialize(settingsFramework.STRINGS.REGISTER_TITLE);
    Component subtitle = serializer.deserialize(settingsFramework.STRINGS.REGISTER_SUBTITLE);

    player.sendMessage(message);
    if (!settingsFramework.STRINGS.REGISTER_TITLE.isEmpty()
        || !settingsFramework.STRINGS.REGISTER_SUBTITLE.isEmpty()) {
      player.showTitle(
          Title.title(title, subtitle, settingsFramework.CRACKED_TITLE_SETTINGS.toTimes()));
    }
  }

  private void sendLoginPrompt() {
    int attemptsLeft = settingsFramework.LOGIN_ATTEMPTS - loginAttempts;
    String loginMessageString = MessageFormat.format(settingsFramework.STRINGS.LOGIN, attemptsLeft);

    Component message = serializer.deserialize(loginMessageString);
    Component title = serializer.deserialize(settingsFramework.STRINGS.LOGIN_TITLE);
    Component subtitle =
        serializer.deserialize(
            MessageFormat.format(settingsFramework.STRINGS.LOGIN_SUBTITLE, attemptsLeft));

    player.sendMessage(message);
    if (!settingsFramework.STRINGS.LOGIN_TITLE.isEmpty()
        || !settingsFramework.STRINGS.LOGIN_SUBTITLE.isEmpty()) {
      player.showTitle(
          Title.title(title, subtitle, settingsFramework.CRACKED_TITLE_SETTINGS.toTimes()));
    }
  }

  /** Triggers the complete login sequence after authentication. */
  public void triggerSuccessfulLoginSequence() {
    Consumer<TaskEvent> eventConsumer =
        (event) -> {
          if (event.getResult() == TaskEvent.Result.CANCEL) {
            if (limboPlayer != null) limboPlayer.disconnect();
            player.disconnect(event.getReason());
            return;
          }
          if (event.getResult() != TaskEvent.Result.BYPASS) {
            cleanup();
            this.plugin.getCacheManager().cacheAuthUser(player);
            this.playerSessionService.removeAuthenticatingPlayer(player.getUsername());
            showSuccessMessages();

            RegisteredPlayer rp =
                this.playerSessionService.getRegisteredPlayer(player.getUsername());
            // Ensure LimboPlayer is available for the event
            if (limboPlayer != null && rp != null) {
              this.plugin
                  .getServer()
                  .getEventManager()
                  .fireAndForget(new PostAuthorizationEvent(taskEvent -> {}, limboPlayer, rp, ""));
            } else {
              this.logger.warn(
                  "LimboPlayer or RegisteredPlayer was null when trying to fire PostAuthorizationEvent for {}",
                  player.getUsername());
            }

            this.plugin.getAuthenticationService().updateLoginData(player);
            this.plugin.getLimboFactory().passLoginLimbo(player);
          }
        };

    RegisteredPlayer rp = this.playerSessionService.getRegisteredPlayer(player.getUsername());
    PreAuthorizationEvent preEvent =
        new PreAuthorizationEvent(eventConsumer, TaskEvent.Result.NORMAL, player, rp);
    this.plugin.getServer().getEventManager().fire(preEvent).thenAcceptAsync(eventConsumer);
  }

  private void showSuccessMessages() {
    Component message = serializer.deserialize(settingsFramework.STRINGS.LOGIN_SUCCESSFUL);
    Component title = serializer.deserialize(settingsFramework.STRINGS.LOGIN_SUCCESSFUL_TITLE);
    Component subtitle =
        serializer.deserialize(settingsFramework.STRINGS.LOGIN_SUCCESSFUL_SUBTITLE);

    player.sendMessage(message);
    if (!settingsFramework.STRINGS.LOGIN_SUCCESSFUL_TITLE.isEmpty()
        || !settingsFramework.STRINGS.LOGIN_SUCCESSFUL_SUBTITLE.isEmpty()) {
      player.showTitle(
          Title.title(title, subtitle, settingsFramework.CRACKED_TITLE_SETTINGS.toTimes()));
    }
  }

  @Override
  public void onDisconnect() {
    cleanup();
    this.playerSessionService.removeAuthenticatingPlayer(player.getUsername());
    this.logger.debug(
        "Player {} disconnected from authentication Limbo (AuthSessionHandler.onDisconnect)",
        player.getUsername());
  }

  private void cleanup() {
    if (timeoutTask != null
        && timeoutTask.status() != TaskStatus.CANCELLED
        && timeoutTask.status() != TaskStatus.FINISHED) {
      timeoutTask.cancel();
    }
    if (bossBarUpdateScheduleTask != null
        && bossBarUpdateScheduleTask.status() != TaskStatus.CANCELLED
        && bossBarUpdateScheduleTask.status() != TaskStatus.FINISHED) {
      bossBarUpdateScheduleTask.cancel();
    }
    if (activeBossBar != null) {
      player.hideBossBar(activeBossBar);
      activeBossBar = null;
    }
    if (settingsFramework.CRACKED_TITLE_SETTINGS.CLEAR_AFTER_LOGIN) {
      player.clearTitle();
    }
  }

  /**
   * Returns the underlying Player instance.
   *
   * @return The Player instance being authenticated
   */
  public Player getPlayer() {
    return player;
  }

  /**
   * Returns the associated LimboPlayer instance.
   *
   * @return The LimboPlayer instance, or null if not spawned
   */
  public LimboPlayer getLimboPlayer() {
    return limboPlayer;
  }

  /**
   * Checks if the player has been authenticated.
   *
   * @return true if authenticated, false otherwise
   */
  public boolean isAuthenticated() {
    return passwordAuthenticated;
  }

  /**
   * Sets the authentication status.
   *
   * @param authenticated true if authenticated
   */
  public void setAuthenticated(boolean authenticated) {
    this.passwordAuthenticated = authenticated;
  }

  /**
   * Returns the current number of failed login attempts.
   *
   * @return The number of failed login attempts
   */
  public int getLoginAttempts() {
    return loginAttempts;
  }

  /** Increments the login attempt counter. */
  public void incrementLoginAttempts() {
    this.loginAttempts++;
  }

  /**
   * Checks if the authentication session has expired.
   *
   * @return true if expired, false otherwise
   */
  public boolean isSessionExpired() {
    if (timeoutTask == null) return false;
    return timeoutTask.status() == TaskStatus.FINISHED && !passwordAuthenticated;
  }
}

```

`src/main/java/net/elytrium/limboauth/listener/AuthListener.java`:

```java
package net.elytrium.limboauth.listener;

import com.velocitypowered.api.event.PostOrder;
import com.velocitypowered.api.event.Subscribe;
import com.velocitypowered.api.event.connection.DisconnectEvent;
import com.velocitypowered.api.event.connection.PostLoginEvent;
import com.velocitypowered.api.event.player.GameProfileRequestEvent;
import com.velocitypowered.api.proxy.InboundConnection;
import com.velocitypowered.api.proxy.Player;
import com.velocitypowered.api.util.GameProfile;
import com.velocitypowered.api.util.UuidUtils;
import com.velocitypowered.proxy.connection.MinecraftConnection;
import com.velocitypowered.proxy.connection.client.InitialInboundConnection;
import com.velocitypowered.proxy.connection.client.LoginInboundConnection;
import java.lang.invoke.MethodHandle;
import java.lang.invoke.MethodHandles;
import java.util.Locale;
import java.util.UUID;
import net.elytrium.commons.utils.reflection.ReflectionException;
import net.elytrium.limboapi.api.event.LoginLimboRegisterEvent;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.service.*;
import net.kyori.adventure.text.Component;
import org.slf4j.Logger;

/**
 * Listener for authentication-related events during player login. Enforces offline/online mode
 * rules and handles login in Limbo.
 */
public class AuthListener {

  private static final MethodHandle DELEGATE_FIELD;

  static {
    try {
      DELEGATE_FIELD =
          MethodHandles.privateLookupIn(LoginInboundConnection.class, MethodHandles.lookup())
              .findGetter(LoginInboundConnection.class, "delegate", InitialInboundConnection.class);
    } catch (NoSuchFieldException | IllegalAccessException e) {
      throw new ReflectionException(e);
    }
  }

  private final LimboAuth plugin;
  private final Logger logger;
  private final AuthenticationService authenticationService;
  private final PlayerSessionService playerSessionService;
  private final ConfigManager configManager;
  private final DatabaseService databaseService;
  private final CacheManager cacheManager;
  private final Component errorOccurredMessage;

  /**
   * Constructs the AuthListener.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param authenticationService Service for authentication logic.
   * @param playerSessionService Service for managing player sessions.
   * @param configManager Service for accessing configuration.
   * @param databaseService Service for database interactions.
   * @param cacheManager Service for managing caches.
   */
  public AuthListener(
      LimboAuth plugin,
      AuthenticationService authenticationService,
      PlayerSessionService playerSessionService,
      ConfigManager configManager,
      DatabaseService databaseService,
      CacheManager cacheManager) {
    this.plugin = plugin;
    this.logger = this.plugin.getLogger();
    this.authenticationService = authenticationService;
    this.playerSessionService = playerSessionService;
    this.configManager = configManager;
    this.databaseService = databaseService;
    this.cacheManager = cacheManager;
    this.errorOccurredMessage =
        this.configManager
            .getSerializer()
            .deserialize(configManager.getSettings().MAIN.STRINGS.ERROR_OCCURRED);
  }

  private MinecraftConnection getMinecraftConnection(InboundConnection inbound) {
    try {
      LoginInboundConnection inboundConnection = (LoginInboundConnection) inbound;
      InitialInboundConnection initialInbound =
          (InitialInboundConnection) DELEGATE_FIELD.invokeExact(inboundConnection);
      return initialInbound.getConnection();
    } catch (Throwable t) {
      this.logger.error(
          "Failed to get MinecraftConnection from InboundConnection for {}:",
          inbound.getRemoteAddress(),
          t);
      return null;
    }
  }

  /**
   * Handles PreLoginEvent. Determines if a connecting player should be forced into online or
   * offline mode based on premium status.
   *
   * @param event The PreLoginEvent.
   */
  @Subscribe(order = PostOrder.LATE)
  public void onPreLogin(com.velocitypowered.api.event.connection.PreLoginEvent event) {
    if (!event.getResult().isAllowed()) {
      return;
    }

    Settings currentSettings = this.configManager.getSettings();
    String username = event.getUsername();
    String usernameLower = username.toLowerCase(Locale.ROOT);

    try {
      if (cacheManager.isForcedOfflinePreviously(username)) {
        this.logger.debug(
            "Player {} was forced offline previously, respecting current offline connection.",
            username);
        return;
      }

      boolean determinedPremium = this.authenticationService.isPremium(username);

      if (determinedPremium) {
        event.setResult(
            com.velocitypowered.api.event.connection.PreLoginEvent.PreLoginComponentResult
                .forceOnlineMode());
        this.logger.debug("Player {} determined as premium, forcing online mode.", username);

        if (!currentSettings.MAIN.ONLINE_MODE_NEED_AUTH_STRICT) {
          LimboAuth.CachedPremiumUser premiumUserCacheEntry =
              this.cacheManager.getPremiumCacheEntry(usernameLower);
          boolean isTruePremiumInCache =
              premiumUserCacheEntry != null && premiumUserCacheEntry.isForcePremium();

          if (!isTruePremiumInCache
              && this.authenticationService.isPremiumInternal(usernameLower).getState()
                  == LimboAuth.PremiumState.UNKNOWN) {
            MinecraftConnection mc = getMinecraftConnection(event.getConnection());
            if (mc != null && !mc.isClosed()) {
              this.cacheManager.addPendingLogin(username);
              mc.getChannel()
                  .closeFuture()
                  .addListener(
                      future -> {
                        if (cacheManager.removePendingLogin(username)) {
                          this.logger.info(
                              "Player {} failed Mojang's online-mode check post-PreLogin; marking as non-premium.",
                              username);
                          this.cacheManager.setPremiumCacheEntry(usernameLower, false);
                        }
                      });
            }
          }
        }
      } else {
        this.logger.debug(
            "Player {} not premium, proceeding with default (likely offline) mode.", username);
      }
    } catch (Throwable throwable) {
      this.logger.error("Error during PreLoginEvent for {}: ", username, throwable);
      event.setResult(
          com.velocitypowered.api.event.connection.PreLoginEvent.PreLoginComponentResult.denied(
              this.errorOccurredMessage));
    }
  }

  /**
   * Schedules any queued post-login tasks for the player.
   *
   * @param event The PostLoginEvent.
   */
  @Subscribe
  public void onPostLogin(PostLoginEvent event) {
    Runnable postLoginTask =
        this.playerSessionService.getPostLoginTask(event.getPlayer().getUniqueId());
    if (postLoginTask != null) {
      this.plugin
          .getTaskSchedulingService()
          .scheduleDelayedTask(
              postLoginTask,
              this.configManager.getSettings().MAIN.PREMIUM_AND_FLOODGATE_MESSAGES_DELAY);
    }
  }

  /**
   * Handles the LoginLimboRegisterEvent after player passes auth. Updates cache and notifies Limbo
   * to allow the player through or initiate authentication.
   *
   * @param event The LoginLimboRegisterEvent from LimboAPI.
   */
  @Subscribe
  public void onLoginLimboRegister(LoginLimboRegisterEvent event) {
    Player player = event.getPlayer();
    String usernameLower = player.getUsername().toLowerCase(Locale.ROOT);
    GameProfile profile = player.getGameProfile();
    boolean isOnlineModePlayer = profile != null && !profile.getProperties().isEmpty();

    if (isOnlineModePlayer) {
      this.cacheManager.setForcedPremiumCacheLowercased(usernameLower, true);
      this.cacheManager.removePendingLogin(player.getUsername());
    }

    if (authenticationService.needsAuthentication(player)) {
      event.addOnJoinCallback(() -> this.authenticationService.handlePlayerAuthentication(player));
    } else {
      this.logger.debug(
          "Player {} session valid or auto-bypassing. Updating login data and passing Limbo.",
          player.getUsername());
      try {
        this.authenticationService.updateLoginData(player);
        this.plugin.getLimboFactory().passLoginLimbo(player);
      } catch (Exception e) {
        this.logger.error(
            "Error trying to directly pass player {} with valid session: {}",
            player.getUsername(),
            e.getMessage(),
            e);
        player.disconnect(errorOccurredMessage);
      }
    }
  }

  /**
   * Handles GameProfileRequestEvent. Updates the GameProfile with offline/online prefixes and saved
   * UUIDs according to plugin settings. This method also uses {@link
   * GameProfileRequestEvent#isOnlineMode()} to determine the connection's mode.
   *
   * @param event The GameProfileRequestEvent.
   */
  @Subscribe(order = PostOrder.FIRST)
  public void onGameProfileRequest(GameProfileRequestEvent event) {
    Settings currentSettings = this.configManager.getSettings();
    GameProfile originalProfile = event.getGameProfile();
    String username = originalProfile.getName();
    String usernameLower = username.toLowerCase(Locale.ROOT);
    GameProfile finalProfile = originalProfile;

    boolean isOnlineModeConnection = event.isOnlineMode(); // Velocity 3.4.0+ API

    if (currentSettings.MAIN.SAVE_UUID
        && (authenticationService.getFloodgateApiHolder() == null
            || !authenticationService.isFloodgatePlayer(originalProfile.getId()))) {

      RegisteredPlayer rpByAnyUUID = this.databaseService.findPlayerByUUID(originalProfile.getId());
      if (rpByAnyUUID != null
          && rpByAnyUUID.getUuid() != null
          && !rpByAnyUUID.getUuid().isEmpty()) {
        try {
          finalProfile = finalProfile.withId(UUID.fromString(rpByAnyUUID.getUuid()));
        } catch (IllegalArgumentException e) {
          this.logger.warn(
              "Invalid stored UUID for {} (found by current UUID {}): {}. Using original.",
              username,
              originalProfile.getId(),
              rpByAnyUUID.getUuid());
        }
      } else {
        RegisteredPlayer rpByName =
            this.databaseService.findPlayerByLowercaseNickname(usernameLower);
        if (rpByName != null) {
          boolean updated = false;
          if (rpByName.getUuid() == null || rpByName.getUuid().isEmpty()) {
            rpByName.setUuid(originalProfile.getId().toString());
            updated = true;
          }
          if (isOnlineModeConnection
              && (rpByName.getPremiumUuid() == null
                  || !rpByName.getPremiumUuid().equals(originalProfile.getId().toString()))) {
            rpByName.setPremiumUuid(originalProfile.getId().toString());
            updated = true;
          }
          if (updated) {
            this.databaseService.updatePlayer(rpByName);
          }
          if (rpByName.getUuid() != null && !rpByName.getUuid().isEmpty()) {
            try {
              finalProfile = finalProfile.withId(UUID.fromString(rpByName.getUuid()));
            } catch (IllegalArgumentException e) {
              this.logger.warn(
                  "Invalid stored UUID from name-match for {}: {}. Using original.",
                  username,
                  rpByName.getUuid());
            }
          }
        }
      }
    }

    if (isOnlineModeConnection) {
      RegisteredPlayer playerToUpdate =
          this.databaseService.findPlayerByLowercaseNickname(usernameLower);
      boolean changed = false;
      if (playerToUpdate != null) {
        if (!playerToUpdate.getHash().isEmpty()) {
          this.logger.info(
              "Player {} ({}) logged in with an online-mode account. Clearing password hash.",
              username,
              originalProfile.getId());
          playerToUpdate.setHash("");
          changed = true;
        }
        String currentPremiumUUID = originalProfile.getId().toString();
        if (playerToUpdate.getPremiumUuid() == null
            || !playerToUpdate.getPremiumUuid().equals(currentPremiumUUID)) {
          playerToUpdate.setPremiumUuid(currentPremiumUUID);
          changed = true;
        }
        if (currentSettings.MAIN.SAVE_UUID
            && (playerToUpdate.getUuid() == null
                || playerToUpdate.getUuid().isEmpty()
                || !playerToUpdate.getUuid().equals(currentPremiumUUID))) {
          playerToUpdate.setUuid(currentPremiumUUID);
          changed = true;
        }
        if (changed) {
          this.databaseService.updatePlayer(playerToUpdate);
        }
      }
    }

    if (currentSettings.MAIN.FORCE_OFFLINE_UUID) {
      finalProfile =
          finalProfile.withId(UuidUtils.generateOfflinePlayerUuid(finalProfile.getName()));
    }

    String nameForPrefixing = username;
    String newName = finalProfile.getName();

    if (!isOnlineModeConnection && !currentSettings.MAIN.OFFLINE_MODE_PREFIX.isEmpty()) {
      if (!nameForPrefixing.startsWith(currentSettings.MAIN.OFFLINE_MODE_PREFIX)) {
        newName = currentSettings.MAIN.OFFLINE_MODE_PREFIX + nameForPrefixing;
      }
    } else if (isOnlineModeConnection && !currentSettings.MAIN.ONLINE_MODE_PREFIX.isEmpty()) {
      if (!nameForPrefixing.startsWith(currentSettings.MAIN.ONLINE_MODE_PREFIX)) {
        newName = currentSettings.MAIN.ONLINE_MODE_PREFIX + nameForPrefixing;
      }
    }

    if (!newName.equals(finalProfile.getName())) {
      finalProfile = finalProfile.withName(newName);
    }

    if (!finalProfile.equals(originalProfile)) {
      event.setGameProfile(finalProfile);
    }
  }

  /**
   * Cleans up player session state on disconnect.
   *
   * @param event The DisconnectEvent.
   */
  @Subscribe
  public void onDisconnect(DisconnectEvent event) {
    try {
      Player player = event.getPlayer();
      String username = player.getUsername();
      this.playerSessionService.removeAuthenticatingPlayer(username);
      this.cacheManager.removePendingLogin(username);
      this.cacheManager.unsetForcedOfflinePreviously(username);
      this.logger.debug("Cleaned up session states for disconnected player: {}", username);
    } catch (Exception e) {
      this.logger.error(
          "Error during disconnect cleanup for {}", event.getPlayer().getUsername(), e);
    }
  }
}

```

`src/main/java/net/elytrium/limboauth/listener/BackendEndpointsListener.java`:

```java
// File: LimboAuth/src/main/java/net/elytrium/limboauth/listener/BackendEndpointsListener.java
package net.elytrium.limboauth.listener;

import com.google.common.io.ByteArrayDataInput;
import com.google.common.io.ByteArrayDataOutput;
import com.google.common.io.ByteStreams;
import com.velocitypowered.api.event.Subscribe;
import com.velocitypowered.api.event.connection.PluginMessageEvent;
import com.velocitypowered.api.proxy.ServerConnection;
import com.velocitypowered.api.proxy.messages.ChannelIdentifier;
import com.velocitypowered.api.proxy.messages.MinecraftChannelIdentifier;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.function.Function;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.backend.Endpoint;
import net.elytrium.limboauth.backend.type.LongDatabaseEndpoint;
import net.elytrium.limboauth.backend.type.StringDatabaseEndpoint;
import net.elytrium.limboauth.backend.type.StringEndpoint;
import net.elytrium.limboauth.backend.type.UnknownEndpoint;
import net.elytrium.limboauth.model.RegisteredPlayer;
import org.slf4j.Logger;

/**
 * Listens for LimboAuth backend API plugin messages and dispatches to the configured endpoint
 * factories.
 */
public class BackendEndpointsListener {

  /** Channel identifier for backend API communication. */
  public static final ChannelIdentifier API_CHANNEL =
      MinecraftChannelIdentifier.create("limboauth", "api"); // Changed from backend_api to api

  private static final Map<String, Function<LimboAuth, Function<String, Endpoint>>>
      ENDPOINT_FACTORIES;

  static {
    Map<String, Function<LimboAuth, Function<String, Endpoint>>> factories = new HashMap<>();

    factories.put(
        "available_endpoints",
        plugin -> // 'plugin' to instancja LimboAuth
        (usernameForEndpoint) ->
                new StringEndpoint(
                    plugin, // Użycie poprawnego parametru 'plugin'
                    "available_endpoints",
                    usernameForEndpoint,
                    // Corrected: Use the 'plugin' parameter from the lambda
                    String.join(",", this.plugin.getConfigManager().getEnabledBackendEndpoints())));
    factories.put(
        "premium_state",
        plugin -> // 'plugin' to instancja LimboAuth
        (usernameForEndpoint) ->
                new StringEndpoint(
                    plugin, // Użycie poprawnego parametru 'plugin'
                    "premium_state",
                    usernameForEndpoint,
                    plugin // Użycie poprawnego parametru 'plugin'
                        .getAuthenticationService()
                        .isPremiumInternal(usernameForEndpoint)
                        .getState()
                        .name()));
    factories.put(
        "hash",
        plugin ->
            (usernameForEndpoint) ->
                new StringDatabaseEndpoint(
                    plugin, "hash", usernameForEndpoint, RegisteredPlayer::getHash));
    factories.put(
        "totp_token",
        plugin ->
            (usernameForEndpoint) ->
                new StringDatabaseEndpoint(
                    plugin, "totp_token", usernameForEndpoint, RegisteredPlayer::getTotpToken));
    factories.put(
        "reg_date",
        plugin ->
            (usernameForEndpoint) ->
                new LongDatabaseEndpoint(
                    plugin, "reg_date", usernameForEndpoint, RegisteredPlayer::getRegDate));
    factories.put(
        "login_date",
        plugin ->
            (usernameForEndpoint) ->
                new LongDatabaseEndpoint(
                    plugin, "login_date", usernameForEndpoint, RegisteredPlayer::getLoginDate));
    factories.put(
        "token_issued_at",
        plugin ->
            (usernameForEndpoint) ->
                new LongDatabaseEndpoint(
                    plugin,
                    "token_issued_at",
                    usernameForEndpoint,
                    RegisteredPlayer::getTokenIssuedAt));
    factories.put(
        "uuid",
        plugin ->
            (usernameForEndpoint) ->
                new StringDatabaseEndpoint(
                    plugin, "uuid", usernameForEndpoint, RegisteredPlayer::getUuid));
    factories.put(
        "premium_uuid",
        plugin ->
            (usernameForEndpoint) ->
                new StringDatabaseEndpoint(
                    plugin, "premium_uuid", usernameForEndpoint, RegisteredPlayer::getPremiumUuid));
    factories.put(
        "ip",
        plugin ->
            (usernameForEndpoint) ->
                new StringDatabaseEndpoint(
                    plugin, "ip", usernameForEndpoint, RegisteredPlayer::getIP));
    factories.put(
        "login_ip",
        plugin ->
            (usernameForEndpoint) ->
                new StringDatabaseEndpoint(
                    plugin, "login_ip", usernameForEndpoint, RegisteredPlayer::getLoginIp));

    ENDPOINT_FACTORIES = Collections.unmodifiableMap(factories);
  }

  private final LimboAuth plugin;
  private final Logger logger;

  /**
   * Constructs the BackendEndpointsListener.
   *
   * @param plugin The main LimboAuth plugin instance.
   */
  /** Default constructor. */
  public BackendEndpointsListener(LimboAuth plugin) {
    this.plugin = plugin;
    this.logger = this.plugin.getLogger();
  }

  /**
   * Handles incoming plugin messages on the LimboAuth backend API channel. Parses the request,
   * authenticates it using a token, and dispatches to the appropriate {@link Endpoint} factory
   * based on the requested type. The response is then sent back to the requester.
   *
   * @param event The PluginMessageEvent.
   */
  @Subscribe
  @SuppressWarnings("UnstableApiUsage") // For ByteStreams
  public void onPluginMessage(PluginMessageEvent event) {
    if (!API_CHANNEL.equals(event.getIdentifier())) {
      return;
    }

    if (!(event.getSource() instanceof ServerConnection)) {
      this.logger.warn(
          "Received backend API message from non-server source: {}", event.getSource());
      return;
    }
    ServerConnection serverConnection = (ServerConnection) event.getSource();

    event.setResult(PluginMessageEvent.ForwardResult.handled());

    ByteArrayDataInput input = ByteStreams.newDataInput(event.getData());
    ByteArrayDataOutput output = ByteStreams.newDataOutput();

    try {
      String requestType = input.readUTF();
      int version = input.readInt();
      String token = input.readUTF();
      String username = input.readUTF();

      if (version != 1) {
        this.logger.warn(
            "Received backend API request with unsupported version {} from {}",
            version,
            serverConnection.getServerInfo().getName());
        new UnknownEndpoint(plugin, requestType).write(output);
      } else if (!plugin.getConfigManager().getSettings().MAIN.BACKEND_API.TOKEN.equals(token)) {
        this.logger.warn(
            "Received backend API request with invalid token from {}",
            serverConnection.getServerInfo().getName());
        output.writeUTF(requestType);
        output.writeInt(-3); // Invalid token error code
      } else {
        this.logger.debug(
            "Received valid backend API request for type '{}', user '{}' from {}",
            requestType,
            username,
            serverConnection.getServerInfo().getName());
        Function<LimboAuth, Function<String, Endpoint>> endpointCreatorFactory =
            ENDPOINT_FACTORIES.get(requestType);
        Endpoint endpoint;
        if (endpointCreatorFactory != null) {
          Function<String, Endpoint> endpointCreator = endpointCreatorFactory.apply(plugin);
          endpoint = endpointCreator.apply(username);
          // No need to call endpoint.readContents(input) if all data is passed via constructor or
          // setUsername
        } else {
          this.logger.warn("Unknown backend API endpoint type requested: {}", requestType);
          endpoint = new UnknownEndpoint(plugin, requestType);
        }
        endpoint.write(output);
      }
    } catch (Exception e) {
      this.logger.error(
          "Error processing backend API plugin message from {}",
          serverConnection.getServerInfo().getName(),
          e);
      output.writeUTF("error_processing");
      output.writeInt(-99);
    }

    // Send the response back using Velocity's public API
    serverConnection.sendPluginMessage(API_CHANNEL, output.toByteArray());
    this.logger.debug(
        "Sent backend API response to {}", serverConnection.getServerInfo().getName());
  }
}

```

`src/main/java/net/elytrium/limboauth/migration/MigrationHash.java`:

```java
package net.elytrium.limboauth.migration;

import com.google.common.hash.Hashing;
import de.mkammerer.argon2.Argon2;
import de.mkammerer.argon2.Argon2Factory;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import org.apache.commons.codec.binary.Hex;
import org.checkerframework.checker.nullness.qual.MonotonicNonNull;

/**
 * Enum representing various password hashing algorithms used for migrating player data from other
 * authentication plugins to LimboAuth's BCrypt. Each enum constant provides a verifier to check a
 * given password against an old hash format.
 */
@SuppressWarnings("unused")
public enum MigrationHash {

  /** AuthMe's default SHA256: $SHA$salt$hash = SHA256(SHA256(password) + salt) */
  AUTHME(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // $SHA$salt$hash
        return args.length == 4
            && args[3].equals(getDigest(getDigest(password, "SHA-256") + args[2], "SHA-256"));
      }),
  /** AuthMe variant without leading $: SHA$salt$hash = SHA256(SHA256(password) + salt) */
  AUTHME_NP(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // SHA$salt$hash
        return args.length == 3
            && args[2].equals(getDigest(getDigest(password, "SHA-256") + args[1], "SHA-256"));
      }),
  /** Argon2 hashing algorithm. Uses a dedicated verifier. */
  ARGON2(new Argon2Verifier()),
  /** DBA/JPremium SHA512: SHA$salt$hash = SHA512(SHA512(password) + salt) */
  SHA512_DBA(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // SHA$salt$hash
        return args.length == 3
            && args[2].equals(getDigest(getDigest(password, "SHA-512") + args[1], "SHA-512"));
      }),
  /** SHA512 with salt, no prefix $: SHA$salt$hash = SHA512(password + salt) */
  SHA512_NP(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // SHA$salt$hash
        return args.length == 3 && args[2].equals(getDigest(password + args[1], "SHA-512"));
      }),
  /** SHA512 with salt and prefix $: $SHA$salt$hash = SHA512(password + salt) */
  SHA512_P(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // $SHA$salt$hash
        return args.length == 4 && args[3].equals(getDigest(password + args[2], "SHA-512"));
      }),
  /** SHA256 with salt, no prefix $: SHA$salt$hash = SHA256(password + salt) */
  SHA256_NP(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // SHA$salt$hash
        return args.length == 3 && args[2].equals(getDigest(password + args[1], "SHA-256"));
      }),
  /** SHA256 with salt and prefix $: $SHA$salt$hash = SHA256(password + salt) */
  SHA256_P(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // $SHA$salt$hash
        return args.length == 4 && args[3].equals(getDigest(password + args[2], "SHA-256"));
      }),
  /** Basic MD5 hash. */
  MD5((hash, password) -> hash.equals(getDigest(password, "MD5"))),
  /** Moon SHA256: $SHA$hash = SHA256(SHA256(password)) (no salt in hash string) */
  MOON_SHA256(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // $SHA$hash
        return args.length == 3
            && args[2].equals(getDigest(getDigest(password, "SHA-256"), "SHA-256"));
      }),
  /** NexAuth SHA256: $SHA$hash = SHA256(password) (no salt in hash string) */
  SHA256_NO_SALT(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // $SHA$hash
        return args.length == 3 && args[2].equals(getDigest(password, "SHA-256"));
      }),
  /** NexAuth SHA512: $SHA$hash = SHA512(password) (no salt in hash string) */
  SHA512_NO_SALT(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // $SHA$hash
        return args.length == 3 && args[2].equals(getDigest(password, "SHA-512"));
      }),
  /** nLogin variant: $SHA$hash$salt = SHA512(password + salt) */
  SHA512_P_REVERSED_HASH(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // $SHA$hash$salt
        return args.length == 4 && args[2].equals(getDigest(password + args[3], "SHA-512"));
      }),
  /** nLogin default: $SHA$hash$salt = SHA512(SHA512(password) + salt) */
  SHA512_NLOGIN(
      (hash, password) -> {
        String[] args = hash.split("\\$"); // $SHA$hash$salt
        return args.length == 4
            && args[2].equals(getDigest(getDigest(password, "SHA-512") + args[3], "SHA-512"));
      }),
  /** Basic CRC32C hash. */
  @SuppressWarnings("UnstableApiUsage")
  CRC32C(
      (hash, password) ->
          hash.equals(Hashing.crc32c().hashString(password, StandardCharsets.UTF_8).toString())),
  /** Plaintext password comparison (no hashing). */
  PLAINTEXT(String::equals);

  private final MigrationHashVerifier verifier;

  /**
   * Constructs a MigrationHash enum constant.
   *
   * @param verifier The {@link MigrationHashVerifier} used to check passwords against this hash
   *     type.
   */
  MigrationHash(MigrationHashVerifier verifier) {
    this.verifier = verifier;
  }

  /**
   * Checks if the given plaintext password matches the provided hash string, according to the
   * specific algorithm of this enum constant.
   *
   * @param hash The stored password hash from the old system.
   * @param password The plaintext password to verify.
   * @return {@code true} if the password matches the hash, {@code false} otherwise.
   */
  public boolean checkPassword(String hash, String password) {
    return this.verifier.checkPassword(hash, password);
  }

  private static String getDigest(String string, String algorithm) {
    try {
      MessageDigest messageDigest = MessageDigest.getInstance(algorithm);
      messageDigest.update(string.getBytes(StandardCharsets.UTF_8));
      byte[] array = messageDigest.digest();
      return Hex.encodeHexString(array);
    } catch (NoSuchAlgorithmException e) {
      throw new IllegalArgumentException(e);
    }
  }

  /** Verifier for Argon2 hashes. */
  private static class Argon2Verifier implements MigrationHashVerifier {

    @MonotonicNonNull private Argon2 argon2;

    @Override
    public boolean checkPassword(String hash, String password) {
      if (this.argon2 == null) {
        this.argon2 = Argon2Factory.create();
      }
      // Argon2 library expects password as char[] or byte[]
      return this.argon2.verify(hash, password.getBytes(StandardCharsets.UTF_8));
    }
  }
}

```

`src/main/java/net/elytrium/limboauth/migration/MigrationHashVerifier.java`:

```java
package net.elytrium.limboauth.migration;

/**
 * Functional interface for verifying a password against a given hash string. This is used by the
 * {@link MigrationHash} enum to delegate password checking for different hashing algorithms.
 */
@FunctionalInterface
public interface MigrationHashVerifier {

  /**
   * Checks if the provided plaintext password matches the given hash.
   *
   * @param hash The stored password hash.
   * @param password The plaintext password to verify.
   * @return {@code true} if the password matches the hash, {@code false} otherwise.
   */
  boolean checkPassword(String hash, String password);
}

```

`src/main/java/net/elytrium/limboauth/model/RegisteredPlayer.java`:

```java
package net.elytrium.limboauth.model;

import at.favre.lib.crypto.bcrypt.BCrypt;
import com.j256.ormlite.field.DatabaseField;
import com.j256.ormlite.table.DatabaseTable;
import com.velocitypowered.api.proxy.Player;
import java.net.InetSocketAddress;
import java.util.Locale;
import java.util.UUID;
import net.elytrium.limboauth.Settings;

/**
 * Represents a player registered with LimboAuth, mapped to a database table. This class contains
 * all persistent data for a player, such as their nickname, password hash, IP addresses, UUIDs, and
 * timestamps.
 */
@DatabaseTable(tableName = "AUTH")
public class RegisteredPlayer {

  /** Database field name for player nickname. */
  /** Database field name for player nickname. */
  public static final String NICKNAME_FIELD = "NICKNAME";

  /** Database field name for lowercase nickname. */
  /** Database field name for lowercase nickname. */
  public static final String LOWERCASE_NICKNAME_FIELD = "LOWERCASENICKNAME";

  /** Database field name for password hash. */
  /** Database field name for password hash. */
  public static final String HASH_FIELD = "HASH";

  /** Database field name for registration IP. */
  /** Database field name for registration IP. */
  public static final String IP_FIELD = "IP";

  /** Database field name for last login IP. */
  /** Database field name for last login IP. */
  public static final String LOGIN_IP_FIELD = "LOGINIP";

  /** Database field name for TOTP token. */
  /** Database field name for TOTP token. */
  public static final String TOTP_TOKEN_FIELD = "TOTPTOKEN";

  /** Database field name for registration date. */
  /** Database field name for registration date. */
  public static final String REG_DATE_FIELD = "REGDATE";

  /** Database field name for last login date. */
  /** Database field name for last login date. */
  public static final String LOGIN_DATE_FIELD = "LOGINDATE";

  /** Database field name for player UUID. */
  /** Database field name for player UUID. */
  public static final String UUID_FIELD = "UUID";

  /** Database field name for premium UUID. */
  /** Database field name for premium UUID. */
  public static final String PREMIUM_UUID_FIELD = "PREMIUMUUID";

  /** Database field name for token issued time. */
  /** Database field name for token issued time. */
  public static final String TOKEN_ISSUED_AT_FIELD = "ISSUEDTIME";

  private static final BCrypt.Hasher HASHER = BCrypt.withDefaults();

  @DatabaseField(canBeNull = false, columnName = NICKNAME_FIELD)
  private String nickname;

  @DatabaseField(id = true, columnName = LOWERCASE_NICKNAME_FIELD)
  private String lowercaseNickname;

  @DatabaseField(canBeNull = false, columnName = HASH_FIELD)
  private String hash = "";

  @DatabaseField(columnName = IP_FIELD, index = true)
  private String ip;

  @DatabaseField(columnName = TOTP_TOKEN_FIELD)
  private String totpToken = "";

  @DatabaseField(columnName = REG_DATE_FIELD)
  private Long regDate = System.currentTimeMillis();

  @DatabaseField(columnName = UUID_FIELD)
  private String uuid = "";

  @DatabaseField(columnName = RegisteredPlayer.PREMIUM_UUID_FIELD, index = true)
  private String premiumUuid = "";

  @DatabaseField(columnName = LOGIN_IP_FIELD)
  private String loginIp;

  @DatabaseField(columnName = LOGIN_DATE_FIELD)
  private Long loginDate = System.currentTimeMillis();

  @DatabaseField(columnName = TOKEN_ISSUED_AT_FIELD)
  private Long tokenIssuedAt = System.currentTimeMillis();

  /**
   * Deprecated constructor for RegisteredPlayer. Use other constructors for creating new instances.
   *
   * @param nickname Player's nickname.
   * @param lowercaseNickname Player's nickname in lowercase (primary key).
   * @param hash Hashed password.
   * @param ip Registration IP address.
   * @param totpToken TOTP secret token.
   * @param regDate Registration timestamp.
   * @param uuid Player's UUID.
   * @param premiumUuid Player's premium (online-mode) UUID.
   * @param loginIp Last login IP address.
   * @param loginDate Last login timestamp.
   */
  @Deprecated
  public RegisteredPlayer(
      String nickname,
      String lowercaseNickname,
      String hash,
      String ip,
      String totpToken,
      Long regDate,
      String uuid,
      String premiumUuid,
      String loginIp,
      Long loginDate) {
    this.nickname = nickname;
    this.lowercaseNickname = lowercaseNickname;
    this.hash = hash;
    this.ip = ip;
    this.totpToken = totpToken;
    this.regDate = regDate;
    this.uuid = uuid;
    this.premiumUuid = premiumUuid;
    this.loginIp = loginIp;
    this.loginDate = loginDate;
  }

  /**
   * Constructs a RegisteredPlayer instance from a Velocity {@link Player} object.
   *
   * @param player The Velocity Player.
   */
  /** Default constructor. */
  public RegisteredPlayer(Player player) {
    this(player.getUsername(), player.getUniqueId(), player.getRemoteAddress());
  }

  /**
   * Constructs a RegisteredPlayer instance with nickname, UUID, and IP address.
   *
   * @param nickname The player's nickname.
   * @param uuid The player's UUID.
   * @param ip The player's IP address.
   */
  /** Default constructor. */
  public RegisteredPlayer(String nickname, UUID uuid, InetSocketAddress ip) {
    this(nickname, uuid.toString(), ip.getAddress().getHostAddress());
  }

  /**
   * Constructs a RegisteredPlayer instance with nickname, UUID string, and IP string.
   *
   * @param nickname The player's nickname.
   * @param uuid The player's UUID as a string.
   * @param ip The player's IP address as a string.
   */
  /** Default constructor. */
  public RegisteredPlayer(String nickname, String uuid, String ip) {
    this.nickname = nickname;
    this.lowercaseNickname = nickname.toLowerCase(Locale.ROOT);
    this.uuid = uuid;
    this.ip = ip;
    this.loginIp = ip;
  }

  /** Default constructor for ORMLite. */
  public RegisteredPlayer() {}

  /**
   * Generates a BCrypt hash for the given password using the configured cost factor.
   *
   * @param password The plaintext password.
   * @return The BCrypt hashed password string.
   */
  public static String genHash(String password) {
    return HASHER.hashToString(Settings.IMP.MAIN.BCRYPT_COST, password.toCharArray());
  }

  /**
   * Sets the player's nickname and updates the lowercase nickname.
   *
   * @param nickname The new nickname.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setNickname(String nickname) {
    this.nickname = nickname;
    this.lowercaseNickname = nickname.toLowerCase(Locale.ROOT);
    return this;
  }

  /**
   * @return The player's nickname.
   */
  public String getNickname() {
    return this.nickname == null ? this.lowercaseNickname : this.nickname;
  }

  /**
   * @return The player's nickname in lowercase.
   */
  public String getLowercaseNickname() {
    return this.lowercaseNickname;
  }

  /**
   * Sets the player's password by hashing the given plaintext password. Also updates the token
   * issued timestamp.
   *
   * @param password The plaintext password.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setPassword(String password) {
    this.hash = genHash(password);
    this.tokenIssuedAt = System.currentTimeMillis();
    return this;
  }

  /**
   * Sets the player's password hash directly. Also updates the token issued timestamp.
   *
   * @param hash The pre-computed password hash.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setHash(String hash) {
    this.hash = hash;
    this.tokenIssuedAt = System.currentTimeMillis();
    return this;
  }

  /**
   * @return The player's password hash, or an empty string if null.
   */
  public String getHash() {
    return this.hash == null ? "" : this.hash;
  }

  /**
   * Sets the player's registration IP address.
   *
   * @param ip The IP address.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setIP(String ip) {
    this.ip = ip;
    return this;
  }

  /**
   * @return The player's registration IP address, or an empty string if null.
   */
  public String getIP() {
    return this.ip == null ? "" : this.ip;
  }

  /**
   * Sets the player's TOTP secret token.
   *
   * @param totpToken The TOTP secret.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setTotpToken(String totpToken) {
    this.totpToken = totpToken;
    return this;
  }

  /**
   * @return The player's TOTP secret token, or an empty string if null.
   */
  public String getTotpToken() {
    return this.totpToken == null ? "" : this.totpToken;
  }

  /**
   * Sets the player's registration timestamp.
   *
   * @param regDate The registration timestamp.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setRegDate(Long regDate) {
    this.regDate = regDate;
    return this;
  }

  /**
   * @return The player's registration timestamp, or {@link Long#MIN_VALUE} if null.
   */
  public long getRegDate() {
    return this.regDate == null ? Long.MIN_VALUE : this.regDate;
  }

  /**
   * Sets the player's primary UUID (often offline mode UUID or last used).
   *
   * @param uuid The UUID string.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setUuid(String uuid) {
    this.uuid = uuid;
    return this;
  }

  /**
   * @return The player's primary UUID string, or an empty string if null.
   */
  public String getUuid() {
    return this.uuid == null ? "" : this.uuid;
  }

  /**
   * Sets the player's premium (online-mode) UUID.
   *
   * @param premiumUuid The premium UUID string.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setPremiumUuid(String premiumUuid) {
    this.premiumUuid = premiumUuid;
    return this;
  }

  /**
   * Sets the player's premium (online-mode) UUID.
   *
   * @param premiumUuid The premium UUID object.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setPremiumUuid(UUID premiumUuid) {
    this.premiumUuid = premiumUuid.toString();
    return this;
  }

  /**
   * @return The player's premium UUID string, or an empty string if null.
   */
  public String getPremiumUuid() {
    return this.premiumUuid == null ? "" : this.premiumUuid;
  }

  /**
   * @return The player's last login IP address, or an empty string if null.
   */
  public String getLoginIp() {
    return this.loginIp == null ? "" : this.loginIp;
  }

  /**
   * Sets the player's last login IP address.
   *
   * @param loginIp The last login IP.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setLoginIp(String loginIp) {
    this.loginIp = loginIp;
    return this;
  }

  /**
   * @return The player's last login timestamp, or {@link Long#MIN_VALUE} if null.
   */
  public long getLoginDate() {
    return this.loginDate == null ? Long.MIN_VALUE : this.loginDate;
  }

  /**
   * Sets the player's last login timestamp.
   *
   * @param loginDate The last login timestamp.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setLoginDate(Long loginDate) {
    this.loginDate = loginDate;
    return this;
  }

  /**
   * @return The timestamp when the current password hash or TOTP token was issued, or {@link
   *     Long#MIN_VALUE} if null.
   */
  public long getTokenIssuedAt() {
    return this.tokenIssuedAt == null ? Long.MIN_VALUE : this.tokenIssuedAt;
  }

  /**
   * Sets the timestamp for when the current password hash or TOTP token was issued.
   *
   * @param tokenIssuedAt The token issued timestamp.
   * @return This RegisteredPlayer instance for chaining.
   */
  public RegisteredPlayer setTokenIssuedAt(Long tokenIssuedAt) {
    this.tokenIssuedAt = tokenIssuedAt;
    return this;
  }
}

```

`src/main/java/net/elytrium/limboauth/model/SQLRuntimeException.java`:

```java
package net.elytrium.limboauth.model;

/**
 * A custom {@link RuntimeException} used to wrap SQLExceptions and other database-related errors
 * occurring within LimboAuth. This allows for more specific error handling and统一 (unified)
 * reporting of database issues.
 */
public class SQLRuntimeException extends RuntimeException {

  /**
   * Constructs a new SQLRuntimeException with a default message and the specified cause.
   *
   * @param cause The underlying cause of this exception.
   */
  /** Default constructor. */
  public SQLRuntimeException(Throwable cause) {
    this("An unexpected internal error was caught during the database SQL operations.", cause);
  }

  /**
   * Constructs a new SQLRuntimeException with the specified detail message and cause.
   *
   * @param message The detail message.
   * @param cause The underlying cause of this exception.
   */
  /** Default constructor. */
  public SQLRuntimeException(String message, Throwable cause) {
    super(message, cause);
  }
}

```

`src/main/java/net/elytrium/limboauth/service/AuthenticationService.java`:

```java
package net.elytrium.limboauth.service;

import at.favre.lib.crypto.bcrypt.BCrypt;
import com.google.common.primitives.Bytes;
import com.google.common.primitives.Longs;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.JsonParser;
import com.velocitypowered.api.event.EventManager;
import com.velocitypowered.api.network.ProtocolVersion;
import com.velocitypowered.api.proxy.Player;
import com.velocitypowered.api.proxy.ProxyServer;
import com.velocitypowered.api.proxy.messages.ChannelIdentifier;
import com.velocitypowered.api.proxy.messages.LegacyChannelIdentifier;
import com.velocitypowered.api.proxy.messages.MinecraftChannelIdentifier;
import com.velocitypowered.api.util.GameProfile;
import io.whitfin.siphash.SipHasher;
import java.net.URI;
import java.net.URLEncoder;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.Locale;
import java.util.UUID;
import java.util.function.Consumer;
import java.util.function.Function;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.event.PreAuthorizationEvent;
import net.elytrium.limboauth.event.PreEvent;
import net.elytrium.limboauth.event.PreRegisterEvent;
import net.elytrium.limboauth.event.TaskEvent;
import net.elytrium.limboauth.floodgate.FloodgateApiHolder;
import net.elytrium.limboauth.handler.AuthSessionHandler;
import net.elytrium.limboauth.migration.MigrationHash;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.model.SQLRuntimeException;
import org.slf4j.Logger;

/**
 * Service responsible for handling player authentication logic, including premium checks, password
 * verification, and interaction with Floodgate.
 */
public class AuthenticationService {

  private final Logger logger;
  private final DatabaseService databaseService;
  private final CacheManager cacheManager;
  private final ConfigManager configManager;
  private LimboServerFacade limboServerFacade;
  private PlayerSessionService playerSessionService;
  private final ProxyServer proxyServer;
  private final HttpClient httpClient = HttpClient.newHttpClient();
  private FloodgateApiHolder floodgateApi;

  private static final ChannelIdentifier MOD_CHANNEL =
      MinecraftChannelIdentifier.create("limboauth", "mod/541f59e4256a337ea252bc482a009d46");
  private static final ChannelIdentifier LEGACY_MOD_CHANNEL =
      new LegacyChannelIdentifier("LIMBOAUTH|MOD");
  private static final BCrypt.Verifyer HASH_VERIFIER = BCrypt.verifyer();

  /**
   * Constructs the AuthenticationService.
   *
   * @param proxyServer The ProxyServer instance.
   * @param logger The logger for this service.
   * @param databaseService Service for database interactions.
   * @param cacheManager Service for managing caches.
   * @param configManager Service for accessing configuration.
   * @param limboServerFacade Facade for interacting with the Limbo this.server.
   * @param playerSessionService Service for managing player sessions.
   */
  public AuthenticationService(
      ProxyServer proxyServer,
      Logger logger,
      DatabaseService databaseService,
      CacheManager cacheManager,
      ConfigManager configManager,
      LimboServerFacade limboServerFacade,
      PlayerSessionService playerSessionService) {
    this.proxyServer = proxyServer;
    this.logger = logger;
    this.databaseService = databaseService;
    this.cacheManager = cacheManager;
    this.configManager = configManager;
    this.limboServerFacade = limboServerFacade;
    this.playerSessionService = playerSessionService;
  }

  /**
   * Sets the LimboServerFacade. Used for dependency injection.
   *
   * @param limboServerFacade The LimboServerFacade instance.
   */
  public void setLimboServerFacade(LimboServerFacade limboServerFacade) {
    this.limboServerFacade = limboServerFacade;
  }

  /**
   * Sets the PlayerSessionService. Used for dependency injection.
   *
   * @param playerSessionService The PlayerSessionService instance.
   */
  public void setPlayerSessionService(PlayerSessionService playerSessionService) {
    this.playerSessionService = playerSessionService;
  }

  /**
   * Gets the Floodgate API holder.
   *
   * @return The FloodgateApiHolder, or null if Floodgate is not present/integrated.
   */
  public FloodgateApiHolder getFloodgateApiHolder() {
    return this.floodgateApi;
  }

  /**
   * Sets the Floodgate API holder.
   *
   * @param floodgateApi The FloodgateApiHolder instance.
   */
  public void setFloodgateApi(FloodgateApiHolder floodgateApi) {
    this.floodgateApi = floodgateApi;
    if (this.floodgateApi == null && !configManager.isFloodgateNeedAuth()) {
      this.logger.warn(
          "Floodgate integration is configured for auto-login, but FloodgateAPI is not available. Bedrock players might not auto-login.");
    }
  }

  /**
   * Checks if a player is a Floodgate (Bedrock) player.
   *
   * @param uuid The UUID of the player.
   * @return True if the player is a Floodgate player, false otherwise.
   */
  public boolean isFloodgatePlayer(UUID uuid) {
    return floodgateApi != null && floodgateApi.isFloodgatePlayer(uuid);
  }

  /**
   * Gets the length of the Floodgate player prefix.
   *
   * @return The length of the prefix, or 0 if Floodgate is not available.
   */
  public int getFloodgatePrefixLength() {
    return floodgateApi != null ? floodgateApi.getPrefixLength() : 0;
  }

  /**
   * Handles the main authentication flow for a connecting player. This includes checks for Bedrock
   * auto-login, brute-force attempts, nickname validation, and dispatching to either registration
   * or login procedures.
   *
   * @param player The player to authenticate.
   */
  public void handlePlayerAuthentication(Player player) {
    boolean isBedrockPlayer = isFloodgatePlayer(player.getUniqueId());
    boolean autoLoginBedrock = !configManager.isFloodgateNeedAuth() && isBedrockPlayer;

    if (cacheManager.isForcedOfflinePreviously(player.getUsername())
        && isPremium(player.getUsername())) {
      if (!autoLoginBedrock) {
        player.disconnect(configManager.reconnectKick);
        return;
      }
    }

    if (cacheManager.getBruteforceAttempts(player.getRemoteAddress().getAddress())
        >= this.configManager.getBruteforceMaxAttempts()) {
      player.disconnect(configManager.bruteforceAttemptKick);
      return;
    }

    String nickname = player.getUsername();
    String validationName = nickname;
    if (isBedrockPlayer
        && floodgateApi != null
        && nickname.startsWith(floodgateApi.getPlayerPrefix())) {
      validationName = nickname.substring(floodgateApi.getPrefixLength());
    }

    if (!configManager.getNicknameValidationPattern().matcher(validationName).matches()) {
      player.disconnect(configManager.nicknameInvalidKick);
      return;
    }

    RegisteredPlayer registeredPlayer =
        this.databaseService.findPlayerByLowercaseNickname(nickname.toLowerCase(Locale.ROOT));
    GameProfile gameProfile = player.getGameProfile();
    boolean onlineMode = gameProfile != null && !gameProfile.getProperties().isEmpty();

    TaskEvent.Result result = TaskEvent.Result.NORMAL;

    if (onlineMode || autoLoginBedrock) {
      if (registeredPlayer == null || registeredPlayer.getHash().isEmpty()) {
        RegisteredPlayer byUuid =
            this.databaseService.findPlayerByPremiumUUID(player.getUniqueId());

        if (registeredPlayer != null && byUuid == null && registeredPlayer.getHash().isEmpty()) {
          registeredPlayer.setPremiumUuid(player.getUniqueId());
          this.databaseService.updatePlayer(registeredPlayer);
          byUuid = registeredPlayer;
        }
        registeredPlayer = byUuid;

        if (registeredPlayer == null && this.configManager.savePremiumAccounts()) {
          registeredPlayer = new RegisteredPlayer(player).setPremiumUuid(player.getUniqueId());
          registeredPlayer.setHash("");
          this.databaseService.createPlayer(registeredPlayer);
        }

        if (registeredPlayer == null
            || (!registeredPlayer.getHash().isEmpty() && !configManager.isOnlineModeNeedAuth())) {
          final Player finalPlayer = player;
          final boolean finalOnlineMode = onlineMode;

          this.playerSessionService.addPostLoginTask(
              player.getUniqueId(),
              () -> {
                if (finalOnlineMode) {
                  if (configManager.loginPremium != null)
                    finalPlayer.sendMessage(configManager.loginPremium);
                  if (configManager.loginPremiumTitle != null)
                    finalPlayer.showTitle(configManager.loginPremiumTitle);
                } else {
                  if (configManager.loginFloodgate != null)
                    finalPlayer.sendMessage(configManager.loginFloodgate);
                  if (configManager.loginFloodgateTitle != null)
                    finalPlayer.showTitle(configManager.loginFloodgateTitle);
                }
              });
          result = TaskEvent.Result.BYPASS;
        }
      }
    }

    EventManager eventManager = proxyServer.getEventManager();
    if (result != TaskEvent.Result.BYPASS) {
      if (registeredPlayer == null) {
        if (configManager.isRegistrationsDisabled()) {
          player.disconnect(configManager.registrationsDisabledKick);
          return;
        }
        Consumer<TaskEvent> eventConsumer = (event) -> processPlayerDispatch(event, null);
        eventManager
            .fire(new PreRegisterEvent(eventConsumer, result, player))
            .thenAcceptAsync(eventConsumer);
      } else {
        Consumer<TaskEvent> eventConsumer =
            (event) ->
                processPlayerDispatch(event, ((PreAuthorizationEvent) event).getPlayerInfo());
        eventManager
            .fire(new PreAuthorizationEvent(eventConsumer, result, player, registeredPlayer))
            .thenAcceptAsync(eventConsumer);
      }
    } else {
      try {
        this.cacheManager.cacheAuthUser(player);
        updateLoginData(player);
      } finally {
        this.limboServerFacade.passLoginLimbo(player);
      }
    }
  }

  private void processPlayerDispatch(TaskEvent event, RegisteredPlayer registeredPlayer) {
    Player player = ((PreEvent) event).getPlayer();
    switch (event.getResult()) {
      case BYPASS:
        try {
          this.cacheManager.cacheAuthUser(player);
          updateLoginData(player);
        } finally {
          this.limboServerFacade.passLoginLimbo(player);
        }
        break;
      case CANCEL:
        player.disconnect(event.getReason());
        break;
      case WAIT:
        // Waiting for async event handlers, do nothing here.
        break;
      case NORMAL:
      default:
        AuthSessionHandler handler =
            this.playerSessionService.createAuthSessionHandler(player, registeredPlayer);
        this.limboServerFacade.spawnPlayerInLimbo(player, handler);
        break;
    }
  }

  /**
   * Updates login data for a player (IP, login date) and sends mod integration messages if enabled.
   *
   * @param player The player whose data is to be updated.
   */
  public void updateLoginData(Player player) {
    String lowercaseNickname = player.getUsername().toLowerCase(Locale.ROOT);
    RegisteredPlayer rp = this.databaseService.findPlayerByLowercaseNickname(lowercaseNickname);
    if (rp != null) {
      rp.setLoginIp(player.getRemoteAddress().getAddress().getHostAddress());
      rp.setLoginDate(System.currentTimeMillis());
      this.databaseService.updatePlayer(rp);

      if (configManager.isModEnabled()) {
        byte[] lowercaseNicknameSerialized = lowercaseNickname.getBytes(StandardCharsets.UTF_8);
        long issueTime = System.currentTimeMillis();
        long hash =
            SipHasher.init(configManager.getModVerifyKey())
                .update(lowercaseNicknameSerialized)
                .update(Longs.toByteArray(issueTime))
                .digest();
        player.sendPluginMessage(
            getChannelIdentifier(player),
            Bytes.concat(Longs.toByteArray(issueTime), Longs.toByteArray(hash)));
      }
    } else {
      this.logger.debug(
          "Attempted to update login data for player not found in DB (possibly a new premium player with save-premium-accounts: false): {}",
          lowercaseNickname);
    }
  }

  /**
   * Gets the appropriate plugin message channel identifier based on the player's protocol version.
   *
   * @param player The player.
   * @return The channel identifier for mod communication.
   */
  public ChannelIdentifier getChannelIdentifier(Player player) {
    return player.getProtocolVersion().compareTo(ProtocolVersion.MINECRAFT_1_13) >= 0
        ? MOD_CHANNEL
        : LEGACY_MOD_CHANNEL;
  }

  private boolean validateScheme(JsonElement jsonElement, List<String> scheme) {
    if (!scheme.isEmpty()) {
      if (!(jsonElement instanceof JsonObject)) {
        return false;
      }
      JsonObject object = (JsonObject) jsonElement;
      for (String field : scheme) {
        if (!object.has(field)) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * Checks if a username is premium by querying an external API (e.g., Mojang). Handles different
   * HTTP status codes and JSON response validation as configured.
   *
   * @param nickname The username to check.
   * @return A {@link LimboAuth.PremiumResponse} indicating the premium status and UUID if
   *     available.
   */
  public LimboAuth.PremiumResponse isPremiumExternal(String nickname) {
    try {
      HttpResponse<String> response =
          this.httpClient.send(
              HttpRequest.newBuilder()
                  .uri(
                      URI.create(
                          String.format(
                              this.configManager.getIsPremiumAuthUrl(),
                              URLEncoder.encode(nickname, StandardCharsets.UTF_8))))
                  .build(),
              HttpResponse.BodyHandlers.ofString());

      int statusCode = response.statusCode();

      if (configManager.getStatusCodeRateLimit().contains(statusCode)) {
        return new LimboAuth.PremiumResponse(LimboAuth.PremiumState.RATE_LIMIT);
      }

      String responseBody = response.body();
      if (responseBody == null || responseBody.trim().isEmpty()) {
        if (configManager.getStatusCodeUserNotExists().contains(statusCode)) {
          return new LimboAuth.PremiumResponse(LimboAuth.PremiumState.CRACKED);
        }
        this.logger.warn(
            "Premium check for {} resulted in status code {} with empty body.",
            nickname,
            statusCode);
        return new LimboAuth.PremiumResponse(LimboAuth.PremiumState.ERROR);
      }

      JsonElement jsonElement = JsonParser.parseString(responseBody);

      if (configManager.getStatusCodeUserExists().contains(statusCode)
          && this.validateScheme(
              jsonElement, this.configManager.getUserExistsJsonValidatorFields())) {
        return new LimboAuth.PremiumResponse(
            LimboAuth.PremiumState.PREMIUM_USERNAME,
            ((JsonObject) jsonElement).get(configManager.getJsonUuidField()).getAsString());
      }

      if (configManager.getStatusCodeUserNotExists().contains(statusCode)
          && this.validateScheme(
              jsonElement, this.configManager.getUserNotExistsJsonValidatorFields())) {
        return new LimboAuth.PremiumResponse(LimboAuth.PremiumState.CRACKED);
      }
      this.logger.warn(
          "Premium check for {} resulted in an unexpected status code {} or JSON scheme. Body: {}",
          nickname,
          statusCode,
          responseBody);
      return new LimboAuth.PremiumResponse(LimboAuth.PremiumState.ERROR);
    } catch (Throwable t) {
      this.logger.error("Unable to authenticate with Mojang for user {}.", nickname, t);
      return new LimboAuth.PremiumResponse(LimboAuth.PremiumState.ERROR);
    }
  }

  /**
   * Checks if a username is considered premium based on internal database records. A player is
   * premium internally if they are registered and have no password hash.
   *
   * @param nickname The username to check.
   * @return A {@link LimboAuth.PremiumResponse} indicating the premium status and stored premium
   *     UUID if applicable.
   */
  public LimboAuth.PremiumResponse isPremiumInternal(String nickname) {
    RegisteredPlayer player =
        this.databaseService.findPlayerByLowercaseNickname(nickname.toLowerCase(Locale.ROOT));
    if (player != null) {
      if (player.getHash().isEmpty()) {
        return new LimboAuth.PremiumResponse(
            LimboAuth.PremiumState.PREMIUM, player.getPremiumUuid());
      } else {
        return new LimboAuth.PremiumResponse(LimboAuth.PremiumState.CRACKED);
      }
    }
    return new LimboAuth.PremiumResponse(LimboAuth.PremiumState.UNKNOWN);
  }

  /**
   * Checks if a given UUID is associated with an internally marked premium account.
   *
   * @param uuid The premium UUID to check.
   * @return True if a player with this premium UUID exists and has no password hash, false
   *     otherwise.
   */
  public boolean isPremiumUuid(UUID uuid) {
    RegisteredPlayer player = this.databaseService.findPlayerByPremiumUUID(uuid);
    return player != null && player.getHash().isEmpty();
  }

  @SafeVarargs
  private boolean checkIsPremiumAndCache(
      String nickname, Function<String, LimboAuth.PremiumResponse>... functions) {
    String lowercaseNickname = nickname.toLowerCase(Locale.ROOT);
    LimboAuth.CachedPremiumUser cachedUser =
        this.cacheManager.getPremiumCacheEntry(lowercaseNickname);
    if (cachedUser != null) {
      return cachedUser.isPremium();
    }

    boolean premium = false;
    boolean unknown = false;
    boolean wasRateLimited = false;
    boolean wasError = false;
    UUID uuidFromExternal = null;

    for (Function<String, LimboAuth.PremiumResponse> function : functions) {
      LimboAuth.PremiumResponse check;
      try {
        check = function.apply(lowercaseNickname);
      } catch (Throwable t) {
        check = new LimboAuth.PremiumResponse(LimboAuth.PremiumState.ERROR);
        this.logger.error(
            "Unable to check player {} account state using one of the methods.",
            lowercaseNickname,
            t);
      }

      if (check.getUuid() != null) {
        uuidFromExternal = check.getUuid();
      }

      switch (check.getState()) {
        case CRACKED:
          this.cacheManager.setPremiumCacheEntry(lowercaseNickname, false);
          return false;
        case PREMIUM:
          this.cacheManager.setForcedPremiumCacheLowercased(lowercaseNickname, true);
          return true;
        case PREMIUM_USERNAME:
          premium = true;
          break;
        case UNKNOWN:
          unknown = true;
          break;
        case RATE_LIMIT:
          wasRateLimited = true;
          break;
        default:
        case ERROR:
          wasError = true;
          break;
      }
    }

    if (premium) {
      this.cacheManager.setPremiumCacheEntry(lowercaseNickname, true);
      return true;
    }

    if (unknown) {
      if (uuidFromExternal != null && isPremiumUuid(uuidFromExternal)) {
        this.cacheManager.setForcedPremiumCacheLowercased(lowercaseNickname, true);
        return true;
      }
      if (!configManager.isOnlineModeNeedAuth()) {
        this.cacheManager.setPremiumCacheEntry(lowercaseNickname, false);
        return false;
      }
    }

    if (wasRateLimited && !premium && !unknown) {
      boolean decision = this.configManager.onRateLimitPremium();
      this.cacheManager.setPremiumCacheEntry(lowercaseNickname, decision);
      return decision;
    }

    if (wasError && !premium && !unknown && !wasRateLimited) {
      boolean decision = this.configManager.onServerErrorPremium();
      this.cacheManager.setPremiumCacheEntry(lowercaseNickname, decision);
      return decision;
    }

    this.cacheManager.setPremiumCacheEntry(lowercaseNickname, false);
    return false;
  }

  /**
   * Determines if a player is premium, considering cache, internal checks, external checks, and
   * configuration for forced offline mode or fallback behaviors on API errors/rate limits.
   *
   * @param nickname The username to check.
   * @return True if the player is considered premium, false otherwise.
   */
  public boolean isPremium(String nickname) {
    if (configManager.getSettings().MAIN.FORCE_OFFLINE_MODE) {
      return false;
    }
    String lowercaseNickname = nickname.toLowerCase(Locale.ROOT);
    LimboAuth.CachedPremiumUser cached = this.cacheManager.getPremiumCacheEntry(lowercaseNickname);
    if (cached != null) {
      return cached.isPremium();
    }

    boolean result;
    if (configManager.getSettings().MAIN.CHECK_PREMIUM_PRIORITY_INTERNAL) {
      result = checkIsPremiumAndCache(nickname, this::isPremiumInternal, this::isPremiumExternal);
    } else {
      result = checkIsPremiumAndCache(nickname, this::isPremiumExternal, this::isPremiumInternal);
    }
    return result;
  }

  /**
   * Checks a given password against a player's stored hash. Handles BCrypt verification and
   * potential hash migration from older algorithms.
   *
   * @param password The plaintext password to check.
   * @param player The {@link RegisteredPlayer} whose hash is to be checked against.
   * @return True if the password matches the stored hash (or a migrated hash), false otherwise.
   * @throws SQLRuntimeException if updating the hash after migration fails.
   */
  public boolean checkPassword(String password, RegisteredPlayer player) {
    String hash = player.getHash();
    if (hash == null || hash.isEmpty()) {
      this.logger.warn(
          "Attempted to check password for player {} with empty hash.",
          player.getLowercaseNickname());
      return false;
    }

    boolean isCorrect =
        HASH_VERIFIER.verify(
                password.getBytes(StandardCharsets.UTF_8), hash.getBytes(StandardCharsets.UTF_8))
            .verified;

    if (!isCorrect && this.configManager.getSettings().MAIN.MIGRATION_HASH != null) {
      MigrationHash migrationHashType = this.configManager.getSettings().MAIN.MIGRATION_HASH;
      isCorrect = migrationHashType.checkPassword(hash, password);
      if (isCorrect) {
        this.logger.info(
            "Password for user {} successfully migrated from {} to BCrypt.",
            player.getLowercaseNickname(),
            migrationHashType);
        player.setPassword(password);
        try {
          this.databaseService.updatePlayer(player);
        } catch (SQLRuntimeException e) {
          this.logger.error(
              "Failed to update password hash after migration for user {}.",
              player.getLowercaseNickname(),
              e);
          throw e; // Re-throw to indicate failure to the caller
        }
      }
    }
    return isCorrect;
  }

  /**
   * Checks if a player needs authentication based on cache status (e.g., new session, IP change).
   *
   * @param player The player to check.
   * @return True if authentication is required, false otherwise.
   */
  public boolean needsAuthentication(Player player) {
    return this.cacheManager.needsAuth(player);
  }

  /**
   * Initiates the authentication process for a player by creating a session handler and spawning
   * them into the Limbo world.
   *
   * @param player The player to start authentication for.
   */
  public void startAuthenticationProcess(Player player) {
    RegisteredPlayer rp =
        this.databaseService.findPlayerByLowercaseNickname(
            player.getUsername().toLowerCase(Locale.ROOT));
    AuthSessionHandler handler = this.playerSessionService.createAuthSessionHandler(player, rp);
    this.limboServerFacade.spawnPlayerInLimbo(player, handler);
  }
}

```

`src/main/java/net/elytrium/limboauth/service/CacheManager.java`:

```java
package net.elytrium.limboauth.service;

import com.google.inject.Inject;
import com.velocitypowered.api.proxy.Player;
import java.net.InetAddress;
import java.util.Collections;
import java.util.HashSet;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import net.elytrium.limboauth.LimboAuth;
import org.slf4j.Logger;

/**
 * Manages various caches used by LimboAuth, including authenticated sessions, premium status,
 * brute-force attempts, and pending logins. Also handles scheduled cache purging.
 */
public class CacheManager {

  private final Logger logger;
  private final TaskSchedulingService taskSchedulingService;
  private ConfigManager configManager;

  private final Map<String, LimboAuth.CachedSessionUser> cachedAuthChecks =
      new ConcurrentHashMap<>();
  private final Map<String, LimboAuth.CachedPremiumUser> premiumCache = new ConcurrentHashMap<>();
  private final Map<InetAddress, LimboAuth.CachedBruteforceUser> bruteforceCache =
      new ConcurrentHashMap<>();
  private final Set<String> forcedOfflinePreviously = Collections.synchronizedSet(new HashSet<>());
  private final Set<String> pendingLogins = ConcurrentHashMap.newKeySet();

  private com.velocitypowered.api.scheduler.ScheduledTask purgeAuthCacheTask;
  private com.velocitypowered.api.scheduler.ScheduledTask purgePremiumCacheTask;
  private com.velocitypowered.api.scheduler.ScheduledTask purgeBruteforceCacheTask;

  /**
   * Constructs the CacheManager.
   *
   * @param logger The logger for this service.
   * @param taskSchedulingService Service for scheduling cache purge tasks.
   */
  @Inject
  /** Default constructor. */
  public CacheManager(Logger logger, TaskSchedulingService taskSchedulingService) {
    this.logger = logger;
    this.taskSchedulingService = taskSchedulingService;
  }

  /**
   * Initializes the CacheManager with the given ConfigManager and schedules purge tasks.
   *
   * @param configManager The configuration manager.
   */
  public void initialize(ConfigManager configManager) {
    this.configManager = configManager;
    setupPurgeTasks();
    this.logger.info("CacheManager initialized and purge tasks scheduled.");
  }

  /**
   * Reloads the CacheManager, re-applying configuration for purge tasks.
   *
   * @param newConfigManager The new configuration manager.
   */
  public void reload(ConfigManager newConfigManager) {
    this.configManager = newConfigManager;
    if (purgeAuthCacheTask != null) taskSchedulingService.cancelTask(purgeAuthCacheTask);
    if (purgePremiumCacheTask != null) taskSchedulingService.cancelTask(purgePremiumCacheTask);
    if (purgeBruteforceCacheTask != null)
      taskSchedulingService.cancelTask(purgeBruteforceCacheTask);
    setupPurgeTasks();
    this.logger.info("CacheManager reloaded and purge tasks rescheduled.");
  }

  private void setupPurgeTasks() {
    long purgeCacheMillis = this.configManager.getPurgeCacheMillis();
    if (purgeCacheMillis > 0) {
      purgeAuthCacheTask =
          taskSchedulingService.scheduleRepeatingTask(
              () -> checkCache(this.cachedAuthChecks, purgeCacheMillis, "auth session"),
              purgeCacheMillis,
              purgeCacheMillis);
    }

    long purgePremiumCacheMillis = this.configManager.getPurgePremiumCacheMillis();
    if (purgePremiumCacheMillis > 0) {
      purgePremiumCacheTask =
          taskSchedulingService.scheduleRepeatingTask(
              () -> checkCache(this.premiumCache, purgePremiumCacheMillis, "premium status"),
              purgePremiumCacheMillis,
              purgePremiumCacheMillis);
    }

    long purgeBruteforceCacheMillis = this.configManager.getPurgeBruteforceCacheMillis();
    if (purgeBruteforceCacheMillis > 0) {
      purgeBruteforceCacheTask =
          taskSchedulingService.scheduleRepeatingTask(
              () ->
                  checkCache(
                      this.bruteforceCache, purgeBruteforceCacheMillis, "bruteforce attempt"),
              purgeBruteforceCacheMillis,
              purgeBruteforceCacheMillis);
    }
  }

  private void checkCache(
      Map<?, ? extends LimboAuth.CachedUser> userMap, long time, String cacheName) {
    long currentTime = System.currentTimeMillis();
    int preSize = userMap.size();
    userMap.entrySet().removeIf(entry -> entry.getValue().getCheckTime() + time <= currentTime);
    int postSize = userMap.size();
    if (preSize > postSize) {
      this.logger.debug(
          "Purged {} {} cache entries. {} remaining.", preSize - postSize, cacheName, postSize);
    }
  }

  /**
   * Caches an authenticated user session.
   *
   * @param player The player whose session is to be cached.
   */
  public void cacheAuthUser(Player player) {
    String username = player.getUsername();
    String lowercaseUsername = username.toLowerCase(Locale.ROOT);
    cachedAuthChecks.put(
        lowercaseUsername,
        new LimboAuth.CachedSessionUser(
            System.currentTimeMillis(), player.getRemoteAddress().getAddress(), username));
    this.logger.debug("Cached auth session for user: {}", lowercaseUsername);
  }

  /**
   * Removes a user's authenticated session and premium status from the cache.
   *
   * @param username The username of the player whose cache entries are to be removed.
   */
  public void removeAuthUserFromCache(String username) {
    String lowercaseUsername = username.toLowerCase(Locale.ROOT);
    cachedAuthChecks.remove(lowercaseUsername);
    premiumCache.remove(lowercaseUsername);
    this.logger.debug("Removed auth session and premium cache for user: {}", lowercaseUsername);
  }

  /**
   * Checks if a player needs authentication based on their current session and cached data.
   * Authentication is needed if no session is cached, or if the IP address or username case
   * mismatch.
   *
   * @param player The player to check.
   * @return True if authentication is required, false otherwise.
   */
  public boolean needsAuth(Player player) {
    String username = player.getUsername();
    String lowercaseUsername = username.toLowerCase(Locale.ROOT);
    if (!cachedAuthChecks.containsKey(lowercaseUsername)) {
      return true;
    }
    LimboAuth.CachedSessionUser sessionUser = cachedAuthChecks.get(lowercaseUsername);
    boolean needsAuth =
        !sessionUser.getInetAddress().equals(player.getRemoteAddress().getAddress())
            || !sessionUser.getUsername().equals(username); // Case-sensitive username check
    if (needsAuth) {
      this.logger.debug(
          "Player {} needs auth. IP or username case mismatch. Cached: IP={}, User={}. Current: IP={}, User={}",
          username,
          sessionUser.getInetAddress(),
          sessionUser.getUsername(),
          player.getRemoteAddress().getAddress(),
          username);
    }
    return needsAuth;
  }

  /**
   * Retrieves a premium cache entry for a given nickname.
   *
   * @param nickname The nickname (case-insensitive).
   * @return The {@link LimboAuth.CachedPremiumUser} entry, or null if not found.
   */
  public LimboAuth.CachedPremiumUser getPremiumCacheEntry(String nickname) {
    return premiumCache.get(nickname.toLowerCase(Locale.ROOT));
  }

  /**
   * Sets a premium cache entry for a given nickname.
   *
   * @param nickname The nickname (case-insensitive).
   * @param isPremium True if the player is premium, false otherwise.
   */
  public void setPremiumCacheEntry(String nickname, boolean isPremium) {
    String lowercaseNickname = nickname.toLowerCase(Locale.ROOT);
    premiumCache.put(
        lowercaseNickname, new LimboAuth.CachedPremiumUser(System.currentTimeMillis(), isPremium));
    this.logger.debug("Set premium cache for {}: {}", lowercaseNickname, isPremium);
  }

  /**
   * Sets a premium cache entry for a lowercased nickname, marking it as "forced premium".
   *
   * @param lowercasedNickname The already lowercased nickname.
   * @param value True if the player is premium, false otherwise.
   * @return The created {@link LimboAuth.CachedPremiumUser} entry.
   */
  public LimboAuth.CachedPremiumUser setForcedPremiumCacheLowercased(
      String lowercasedNickname, boolean value) {
    LimboAuth.CachedPremiumUser premiumUser =
        new LimboAuth.CachedPremiumUser(System.currentTimeMillis(), value);
    premiumUser.setForcePremium(value);
    this.premiumCache.put(lowercasedNickname, premiumUser);
    this.logger.debug("Set forced premium cache for {}: {}", lowercasedNickname, value);
    return premiumUser;
  }

  /**
   * Increments the brute-force attempt counter for a given IP address.
   *
   * @param address The IP address.
   */
  public void incrementBruteforceAttempts(InetAddress address) {
    bruteforceCache
        .computeIfAbsent(
            address, k -> new LimboAuth.CachedBruteforceUser(System.currentTimeMillis()))
        .incrementAttempts();
    this.logger.debug(
        "Incremented bruteforce attempts for IP: {}. Total: {}",
        address,
        getBruteforceAttempts(address));
  }

  /**
   * Gets the number of brute-force attempts recorded for a given IP address.
   *
   * @param address The IP address.
   * @return The number of attempts, or 0 if none recorded.
   */
  public int getBruteforceAttempts(InetAddress address) {
    LimboAuth.CachedBruteforceUser user = bruteforceCache.get(address);
    return (user == null) ? 0 : user.getAttempts();
  }

  /**
   * Clears the brute-force attempt counter for a given IP address.
   *
   * @param address The IP address.
   */
  public void clearBruteforceAttempts(InetAddress address) {
    bruteforceCache.remove(address);
    this.logger.debug("Cleared bruteforce attempts for IP: {}", address);
  }

  /**
   * Marks a player (by nickname) as having previously connected in forced offline mode. This is
   * used in scenarios where strict online mode checks might be temporarily bypassed.
   *
   * @param nickname The player's nickname (case-insensitive).
   */
  public void saveForceOfflineMode(String nickname) {
    this.forcedOfflinePreviously.add(nickname.toLowerCase(Locale.ROOT));
  }

  /**
   * Removes the "forced offline previously" mark for a player.
   *
   * @param nickname The player's nickname (case-insensitive).
   */
  public void unsetForcedOfflinePreviously(String nickname) {
    this.forcedOfflinePreviously.remove(nickname.toLowerCase(Locale.ROOT));
  }

  /**
   * Checks if a player was marked as having previously connected in forced offline mode.
   *
   * @param nickname The player's nickname (case-insensitive).
   * @return True if the mark exists, false otherwise.
   */
  public boolean isForcedOfflinePreviously(String nickname) {
    return this.forcedOfflinePreviously.contains(nickname.toLowerCase(Locale.ROOT));
  }

  /**
   * Adds a username to the set of players whose login is pending (e.g., awaiting external premium
   * check).
   *
   * @param username The username (case-insensitive).
   */
  public void addPendingLogin(String username) {
    this.pendingLogins.add(username.toLowerCase(Locale.ROOT));
  }

  /**
   * Removes a username from the set of pending logins.
   *
   * @param username The username (case-insensitive).
   * @return True if the username was present and removed, false otherwise.
   */
  public boolean removePendingLogin(String username) {
    return this.pendingLogins.remove(username.toLowerCase(Locale.ROOT));
  }

  /**
   * Checks if a username is in the set of pending logins.
   *
   * @param username The username (case-insensitive).
   * @return True if the login is pending, false otherwise.
   */
  public boolean isPendingLogin(String username) {
    return this.pendingLogins.contains(username.toLowerCase(Locale.ROOT));
  }

  /** Clears all managed caches. */
  public void clearAllCaches() {
    cachedAuthChecks.clear();
    premiumCache.clear();
    bruteforceCache.clear();
    forcedOfflinePreviously.clear();
    pendingLogins.clear();
    this.logger.info("All caches have been cleared.");
  }
}

```

`src/main/java/net/elytrium/limboauth/service/CommandRegistry.java`:

```java
// File: LimboAuth/src/main/java/net/elytrium/limboauth/service/CommandRegistry.java
package net.elytrium.limboauth.service;

import com.velocitypowered.api.command.CommandManager;
import com.velocitypowered.api.command.SimpleCommand;
import com.velocitypowered.api.proxy.ProxyServer;
import java.util.ArrayList;
import java.util.List;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.command.*;
import org.slf4j.Logger;

/** Service responsible for registering and managing plugin commands. */
public class CommandRegistry {

  private final LimboAuth plugin;
  private final Logger logger;
  private final CommandManager commandManager;
  private final DatabaseService databaseService;
  private final AuthenticationService authenticationService;
  private final PlayerSessionService playerSessionService;
  private final ConfigManager configManager;
  private final CacheManager cacheManager;
  private final ProxyServer server;

  private final List<RegisteredCommandInfo> registeredCommands = new ArrayList<>();

  public CommandRegistry(
      LimboAuth plugin,
      Logger logger,
      CommandManager commandManager,
      DatabaseService databaseService,
      AuthenticationService authenticationService,
      PlayerSessionService playerSessionService,
      ConfigManager configManager,
      CacheManager cacheManager,
      ProxyServer server) {
    this.plugin = plugin;
    this.logger = logger;
    this.commandManager = commandManager;
    this.databaseService = databaseService;
    this.authenticationService = authenticationService;
    this.playerSessionService = playerSessionService;
    this.configManager = configManager;
    this.cacheManager = cacheManager;
    this.server = server;
  }

  /** Initializes and registers all commands. */
  public void initialize() {
    registerAllCommands();
  }

  public void registerAllCommands() {
    // Register main plugin command
    registerCommand("limboauth", new LimboAuthCommand(plugin, configManager));

    // Register user commands
    registerCommandWithAliases(
        this.configManager.getSettings().MAIN.REGISTER_COMMAND,
        new RegisterCommand(
            plugin, databaseService, authenticationService, cacheManager, configManager));
    registerCommandWithAliases(
        this.configManager.getSettings().MAIN.LOGIN_COMMAND,
        new LoginCommand(plugin, authenticationService, playerSessionService, configManager));
    registerCommandWithAliases(
        this.configManager.getSettings().MAIN.TOTP_COMMAND,
        new TotpCommand(plugin, databaseService, authenticationService, configManager));

    // Register utility commands
    registerCommand(
        "changepassword",
        new ChangePasswordCommand(
            plugin, databaseService, authenticationService, cacheManager, configManager));
    registerCommand(
        "destroysession", new DestroySessionCommand(plugin, cacheManager, configManager));
    registerCommand(
        "unregister",
        new UnregisterCommand(
            plugin, databaseService, authenticationService, cacheManager, configManager));
    registerCommand(
        "premium",
        new PremiumCommand(
            plugin, databaseService, authenticationService, cacheManager, configManager));

    // Register admin commands
    registerCommand(
        "forceregister", new ForceRegisterCommand(plugin, databaseService, configManager));
    registerCommand(
        "forcelogin", new ForceLoginCommand(plugin, playerSessionService, configManager));
    registerCommand(
        "forcechangepassword",
        new ForceChangePasswordCommand(
            plugin, server, configManager, databaseService, cacheManager));
    registerCommand(
        "forceunregister",
        new ForceUnregisterCommand(plugin, server, databaseService, cacheManager, configManager));

    this.logger.info("Registered {} commands successfully.", registeredCommands.size());
  }

  private void registerCommand(String baseAlias, SimpleCommand command) {
    commandManager.register(commandManager.metaBuilder(baseAlias).build(), command);
    registeredCommands.add(new RegisteredCommandInfo(baseAlias, List.of(baseAlias), command));
    this.logger.debug("Registered command: {}", baseAlias);
  }

  private void registerCommandWithAliases(List<String> aliases, SimpleCommand command) {
    if (aliases.isEmpty()) {
      this.logger.warn("Attempted to register command with empty aliases list");
      return;
    }

    String primaryAlias = aliases.get(0);
    String[] additionalAliases = aliases.subList(1, aliases.size()).toArray(new String[0]);

    commandManager.register(
        commandManager.metaBuilder(primaryAlias).aliases(additionalAliases).build(), command);

    registeredCommands.add(new RegisteredCommandInfo(primaryAlias, aliases, command));
    this.logger.debug("Registered command '{}' with aliases: {}", primaryAlias, aliases);
  }

  public void unregisterAllCommands() {
    for (RegisteredCommandInfo commandInfo :
        new ArrayList<>(registeredCommands)) { // Iterate over a copy
      commandManager.unregister(commandInfo.primaryAlias);
    }
    registeredCommands.clear();
    this.logger.info("Unregistered all commands.");
  }

  private static class RegisteredCommandInfo {
    public final String primaryAlias;
    public final List<String> allAliases;
    public final SimpleCommand command;

    public RegisteredCommandInfo(
        String primaryAlias, List<String> allAliases, SimpleCommand command) {
      this.primaryAlias = primaryAlias;
      this.allAliases = allAliases;
      this.command = command;
    }
  }
}

```

`src/main/java/net/elytrium/limboauth/service/ConfigManager.java`:

```java
package net.elytrium.limboauth.service;

import java.io.IOException;
import java.io.InputStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.regex.Pattern;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import net.elytrium.commons.kyori.serialization.Serializer;
import net.elytrium.commons.kyori.serialization.Serializers;
import net.elytrium.commons.utils.updates.UpdatesChecker;
import net.elytrium.limboauth.BuildConstants;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.event.TaskEvent;
import net.elytrium.limboauth.handler.AuthSessionHandler;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.title.Title;
import org.bstats.charts.SimplePie;
import org.bstats.charts.SingleLineChart;
import org.bstats.velocity.Metrics;
import org.slf4j.Logger;

/**
 * Manages the plugin's configuration (config.yml). Handles loading, reloading, and providing access
 * to settings, messages, and other configuration-dependent resources like unsafe password lists.
 */
public class ConfigManager {
  private final Logger logger;
  private Settings settings;
  private Serializer serializer;
  private Pattern nicknameValidationPattern;

  /** Set of unsafe passwords loaded from the configured file. */
  public Set<String> unsafePasswords = new HashSet<>();

  private Path dataDirectory;
  private Path configFile;

  /** Component for premium login message. */
  public Component loginPremium;

  /** Title for premium login. */
  public Title loginPremiumTitle;

  /** Component for Floodgate (Bedrock) login message. */
  public Component loginFloodgate;

  /** Title for Floodgate (Bedrock) login. */
  public Title loginFloodgateTitle;

  /** Component for kick message when registrations are disabled. */
  public Component registrationsDisabledKick;

  /** Component for kick message due to too many brute-force attempts. */
  public Component bruteforceAttemptKick;

  /** Component for kick message due to invalid nickname. */
  public Component nicknameInvalidKick;

  /** Component for kick message prompting reconnection. */
  public Component reconnectKick;

  /**
   * Constructs the ConfigManager.
   *
   * @param logger The logger for this service.
   */
  /** Default constructor. */
  public ConfigManager(Logger logger) {
    this.logger = logger;
    this.settings = Settings.IMP;
  }

  /**
   * Initializes the configuration by loading from the specified path. Sets up serializers,
   * validation patterns, unsafe passwords, and static messages.
   *
   * @param configPath Path to the config.yml file.
   * @throws RuntimeException if initialization fails.
   */
  public void initialize(Path configPath) {
    try {
      this.configFile = configPath;
      this.dataDirectory = configPath.getParent();
      Settings.IMP.reload(this.configFile.toFile(), Settings.IMP.PREFIX);
      this.settings = Settings.IMP;

      net.kyori.adventure.text.serializer.ComponentSerializer<Component, Component, String>
          kyoriSerializer = this.settings.SERIALIZER.getSerializer();
      if (kyoriSerializer == null) {
        this.logger.warn(
            "The specified serializer could not be found, using default (LEGACY_AMPERSAND).");
        this.serializer =
            new Serializer(Objects.requireNonNull(Serializers.LEGACY_AMPERSAND.getSerializer()));
      } else {
        this.serializer = new Serializer(kyoriSerializer);
      }

      this.nicknameValidationPattern = Pattern.compile(settings.MAIN.ALLOWED_NICKNAME_REGEX);
      loadUnsafePasswords();
      loadPublicMessagesAndTitles();

      TaskEvent.reload(this.serializer);
      AuthSessionHandler.reload(this.serializer, this.settings, this.unsafePasswords);

      this.logger.info("Configuration initialized successfully");
    } catch (Exception e) {
      this.logger.error("Failed to initialize configuration", e);
      throw new RuntimeException("Configuration initialization failed", e);
    }
  }

  /**
   * Reloads the configuration from disk. Re-initializes serializers, validation patterns, unsafe
   * passwords, and static messages.
   *
   * @throws RuntimeException if reloading fails.
   */
  public void reload() {
    try {
      if (this.configFile == null) {
        this.logger.error("Config file path not set, cannot reload.");
        return;
      }
      settings.reload(this.configFile.toFile(), settings.PREFIX);

      net.kyori.adventure.text.serializer.ComponentSerializer<Component, Component, String>
          kyoriSerializer = this.settings.SERIALIZER.getSerializer();
      if (kyoriSerializer == null) {
        this.logger.warn(
            "The specified serializer could not be found, using default (LEGACY_AMPERSAND).");
        this.serializer =
            new Serializer(Objects.requireNonNull(Serializers.LEGACY_AMPERSAND.getSerializer()));
      } else {
        this.serializer = new Serializer(kyoriSerializer);
      }

      this.nicknameValidationPattern = Pattern.compile(settings.MAIN.ALLOWED_NICKNAME_REGEX);
      loadUnsafePasswords();
      loadPublicMessagesAndTitles();

      TaskEvent.reload(this.serializer);
      AuthSessionHandler.reload(this.serializer, this.settings, this.unsafePasswords);

      this.logger.info("Configuration reloaded successfully");
    } catch (Exception e) {
      this.logger.error("Failed to reload configuration", e);
      throw new RuntimeException("Configuration reload failed", e);
    }
  }

  private void loadUnsafePasswords() {
    this.unsafePasswords.clear();
    if (settings.MAIN.CHECK_PASSWORD_STRENGTH) {
      Path unsafePasswordsFile = dataDirectory.resolve(settings.MAIN.UNSAFE_PASSWORDS_FILE);
      if (!Files.exists(unsafePasswordsFile)) {
        this.logger.info(
            "Unsafe passwords file not found, creating from resources: {}", unsafePasswordsFile);
        try (InputStream in =
            getClass().getResourceAsStream("/" + settings.MAIN.UNSAFE_PASSWORDS_FILE)) {
          if (in == null) {
            this.logger.error("Default unsafe_passwords.txt not found in plugin resources!");
            return;
          }
          Files.createDirectories(unsafePasswordsFile.getParent());
          Files.copy(in, unsafePasswordsFile);
        } catch (IOException e) {
          this.logger.error("Failed to copy default unsafe passwords file.", e);
          return;
        }
      }

      if (Files.exists(unsafePasswordsFile)) {
        try (Stream<String> unsafePasswordsStream = Files.lines(unsafePasswordsFile)) {
          this.unsafePasswords.addAll(unsafePasswordsStream.collect(Collectors.toList()));
          this.logger.info("Loaded {} unsafe passwords.", this.unsafePasswords.size());
        } catch (IOException e) {
          this.logger.error("Failed to load unsafe passwords file: {}", unsafePasswordsFile, e);
          this.unsafePasswords.clear();
        }
      }
    }
  }

  private void loadPublicMessagesAndTitles() {
    this.loginPremium =
        settings.MAIN.STRINGS.LOGIN_PREMIUM.isEmpty()
            ? null
            : serializer.deserialize(settings.MAIN.STRINGS.LOGIN_PREMIUM);
    if (settings.MAIN.STRINGS.LOGIN_PREMIUM_TITLE.isEmpty()
        && settings.MAIN.STRINGS.LOGIN_PREMIUM_SUBTITLE.isEmpty()) {
      this.loginPremiumTitle = null;
    } else {
      this.loginPremiumTitle =
          Title.title(
              serializer.deserialize(settings.MAIN.STRINGS.LOGIN_PREMIUM_TITLE),
              serializer.deserialize(settings.MAIN.STRINGS.LOGIN_PREMIUM_SUBTITLE),
              settings.MAIN.PREMIUM_TITLE_SETTINGS.toTimes());
    }

    this.loginFloodgate =
        settings.MAIN.STRINGS.LOGIN_FLOODGATE.isEmpty()
            ? null
            : serializer.deserialize(settings.MAIN.STRINGS.LOGIN_FLOODGATE);
    if (settings.MAIN.STRINGS.LOGIN_FLOODGATE_TITLE.isEmpty()
        && settings.MAIN.STRINGS.LOGIN_FLOODGATE_SUBTITLE.isEmpty()) {
      this.loginFloodgateTitle = null;
    } else {
      this.loginFloodgateTitle =
          Title.title(
              serializer.deserialize(settings.MAIN.STRINGS.LOGIN_FLOODGATE_TITLE),
              serializer.deserialize(settings.MAIN.STRINGS.LOGIN_FLOODGATE_SUBTITLE),
              settings.MAIN.PREMIUM_TITLE_SETTINGS.toTimes());
    }
    this.bruteforceAttemptKick =
        serializer.deserialize(settings.MAIN.STRINGS.LOGIN_WRONG_PASSWORD_KICK);
    this.nicknameInvalidKick = serializer.deserialize(settings.MAIN.STRINGS.NICKNAME_INVALID_KICK);
    this.reconnectKick = serializer.deserialize(settings.MAIN.STRINGS.RECONNECT_KICK);
    this.registrationsDisabledKick =
        serializer.deserialize(settings.MAIN.STRINGS.REGISTRATIONS_DISABLED_KICK);
  }

  /**
   * @return The current {@link Settings} instance.
   */
  public Settings getSettings() {
    return settings;
  }

  /**
   * @return The current {@link Serializer} instance for messages.
   */
  public Serializer getSerializer() {
    return this.serializer;
  }

  /**
   * @return The compiled {@link Pattern} for nickname validation.
   */
  public Pattern getNicknameValidationPattern() {
    return nicknameValidationPattern;
  }

  /**
   * @return The plugin's data directory path.
   */
  public Path getDataDirectory() {
    return dataDirectory;
  }

  /**
   * @return The configured {@link Settings.MAIN.COMMAND_PERMISSION_STATE} for commands.
   */
  public Settings.MAIN.COMMAND_PERMISSION_STATE getCommandPermissionState() {
    return settings.MAIN.COMMAND_PERMISSION_STATE;
  }

  /**
   * @return True if the backend API is enabled, false otherwise.
   */
  public boolean isBackendApiEnabled() {
    return settings.MAIN.BACKEND_API.ENABLED;
  }

  /**
   * Adds custom metrics charts to bStats.
   *
   * @param metrics The bStats {@link Metrics} instance.
   * @param databaseService The {@link DatabaseService} for fetching player counts.
   */
  public void addMetricsCharts(Metrics metrics, DatabaseService databaseService) {
    metrics.addCustomChart(
        new SingleLineChart(
            "registered_players",
            () -> {
              try {
                // Corrected: Use the 'databaseService' parameter
                return (int) this.databaseService.getRegisteredPlayerCount();
              } catch (Exception e) { // NOSONAR - bStats should not crash the plugin
                this.logger.error("Failed to get registered player count for bStats", e);
                return 0;
              }
            }));

    metrics.addCustomChart(
        new SimplePie("database_type", () -> settings.DATABASE.STORAGE_TYPE.name()));

    metrics.addCustomChart(
        new SimplePie(
            "online_mode_need_auth", () -> String.valueOf(settings.MAIN.ONLINE_MODE_NEED_AUTH)));

    this.logger.debug("Added metrics charts successfully");
  }

  /**
   * Checks for plugin updates against the version specified at a remote URL.
   *
   * @return True if the current version is up-to-date or newer, false if an update is available.
   */
  public boolean checkUpdates() {
    this.logger.debug("Checking for updates...");
    return UpdatesChecker.checkVersionByURL(
        "https://raw.githubusercontent.com/Elytrium/LimboAuth/master/VERSION",
        BuildConstants.AUTH_VERSION);
  }

  /**
   * @return Milliseconds for general cache purging.
   */
  public long getPurgeCacheMillis() {
    return settings.MAIN.PURGE_CACHE_MILLIS;
  }

  /**
   * @return Milliseconds for premium cache purging.
   */
  public long getPurgePremiumCacheMillis() {
    return settings.MAIN.PURGE_PREMIUM_CACHE_MILLIS;
  }

  /**
   * @return Milliseconds for bruteforce cache purging.
   */
  public long getPurgeBruteforceCacheMillis() {
    return settings.MAIN.PURGE_BRUTEFORCE_CACHE_MILLIS;
  }

  /**
   * @return True if Floodgate players need authentication.
   */
  public boolean isFloodgateNeedAuth() {
    return settings.MAIN.FLOODGATE_NEED_AUTH;
  }

  /**
   * @return Maximum bruteforce attempts allowed.
   */
  public int getBruteforceMaxAttempts() {
    return settings.MAIN.BRUTEFORCE_MAX_ATTEMPTS;
  }

  /**
   * @return True if premium accounts should be saved in the database.
   */
  public boolean savePremiumAccounts() {
    return settings.MAIN.SAVE_PREMIUM_ACCOUNTS;
  }

  /**
   * @return True if online-mode players need authentication.
   */
  public boolean isOnlineModeNeedAuth() {
    return settings.MAIN.ONLINE_MODE_NEED_AUTH;
  }

  /**
   * @return True if new registrations are disabled.
   */
  public boolean isRegistrationsDisabled() {
    return settings.MAIN.DISABLE_REGISTRATIONS;
  }

  /**
   * @return True if client mod integration is enabled.
   */
  public boolean isModEnabled() {
    return settings.MAIN.MOD.ENABLED;
  }

  /**
   * @return The verification key for client mod communication.
   */
  public byte[] getModVerifyKey() {
    return settings.MAIN.MOD.VERIFY_KEY;
  }

  /**
   * @return The URL for external premium authentication checks.
   */
  public String getIsPremiumAuthUrl() {
    return settings.MAIN.ISPREMIUM_AUTH_URL;
  }

  /**
   * @return List of HTTP status codes indicating a rate limit from the premium check API.
   */
  public List<Integer> getStatusCodeRateLimit() {
    return settings.MAIN.STATUS_CODE_RATE_LIMIT;
  }

  /**
   * @return List of HTTP status codes indicating a user does not exist from the premium check API.
   */
  public List<Integer> getStatusCodeUserNotExists() {
    return settings.MAIN.STATUS_CODE_USER_NOT_EXISTS;
  }

  /**
   * @return List of HTTP status codes indicating a user exists from the premium check API.
   */
  public List<Integer> getStatusCodeUserExists() {
    return settings.MAIN.STATUS_CODE_USER_EXISTS;
  }

  /**
   * @return List of JSON fields to validate in the response when a user exists.
   */
  public List<String> getUserExistsJsonValidatorFields() {
    return settings.MAIN.USER_EXISTS_JSON_VALIDATOR_FIELDS;
  }

  /**
   * @return The JSON field name containing the UUID in the premium check response.
   */
  public String getJsonUuidField() {
    return settings.MAIN.JSON_UUID_FIELD;
  }

  /**
   * @return List of JSON fields to validate in the response when a user does not exist.
   */
  public List<String> getUserNotExistsJsonValidatorFields() {
    return settings.MAIN.USER_NOT_EXISTS_JSON_VALIDATOR_FIELDS;
  }

  /**
   * @return True if players should be treated as premium on API rate limit, false for cracked.
   */
  public boolean onRateLimitPremium() {
    return settings.MAIN.ON_RATE_LIMIT_PREMIUM;
  }

  /**
   * @return True if players should be treated as premium on API server error, false for cracked.
   */
  public boolean onServerErrorPremium() {
    return settings.MAIN.ON_SERVER_ERROR_PREMIUM;
  }

  /**
   * @return List of enabled backend API endpoint names.
   */
  public List<String> getEnabledBackendEndpoints() {
    return settings.MAIN.BACKEND_API.ENABLED_ENDPOINTS;
  }
}

```

`src/main/java/net/elytrium/limboauth/service/DatabaseService.java`:

```java
// File: LimboAuth/src/main/java/net/elytrium/limboauth/service/DatabaseService.java
package net.elytrium.limboauth.service;

import com.j256.ormlite.dao.Dao;
import com.j256.ormlite.dao.DaoManager;
import com.j256.ormlite.dao.GenericRawResults;
import com.j256.ormlite.db.DatabaseType;
import com.j256.ormlite.field.FieldType;
import com.j256.ormlite.stmt.QueryBuilder;
import com.j256.ormlite.support.ConnectionSource;
import com.j256.ormlite.table.TableInfo;
import com.j256.ormlite.table.TableUtils;
import java.io.IOException;
import java.net.URISyntaxException;
import java.nio.file.Path;
import java.sql.SQLException;
import java.util.Collections;
import java.util.HashSet;
import java.util.Locale;
import java.util.Set;
import java.util.UUID;
import java.util.stream.Collectors;
import net.elytrium.limboauth.Settings;
import net.elytrium.limboauth.dependencies.DatabaseLibrary;
import net.elytrium.limboauth.model.RegisteredPlayer;
import net.elytrium.limboauth.model.SQLRuntimeException;
import org.slf4j.Logger;

/**
 * Service responsible for all database interactions. It manages the connection source, Data Access
 * Objects (DAOs), and provides methods for CRUD operations on {@link RegisteredPlayer} entities.
 * Also handles database schema migration.
 */
public class DatabaseService {

  private final Logger logger;
  private ConnectionSource connectionSource;
  private Dao<RegisteredPlayer, String> playerDao;
  private Path dataDirectoryPath;
  private ConfigManager configManager;
  private boolean initialized = false;

  /**
   * Constructs the DatabaseService.
   *
   * @param logger The logger for this service.
   */
  /** Default constructor. */
  public DatabaseService(Logger logger) {
    this.logger = logger;
  }

  /**
   * Initializes the database connection, creates tables if they don't exist, and performs schema
   * migration.
   *
   * @param dataDirectoryPath The plugin's data directory path.
   * @param configManager The configuration manager for database settings.
   * @throws RuntimeException if database initialization fails.
   */
  public void initialize(Path dataDirectoryPath, ConfigManager configManager) {
    this.dataDirectoryPath = dataDirectoryPath;
    this.configManager = configManager;
    this.logger.info("Initializing DatabaseService...");

    Settings.DATABASE dbConfig = this.configManager.getSettings().DATABASE;
    DatabaseLibrary databaseLibrary = dbConfig.STORAGE_TYPE;

    try {
      this.connectionSource =
          databaseLibrary.connectToORM(
              this.dataDirectoryPath.toAbsolutePath(),
              dbConfig.HOSTNAME,
              dbConfig.DATABASE + dbConfig.CONNECTION_PARAMETERS,
              dbConfig.USER,
              dbConfig.PASSWORD);

      this.playerDao = DaoManager.createDao(this.connectionSource, RegisteredPlayer.class);

      if (TableUtils.createTableIfNotExists(this.connectionSource, RegisteredPlayer.class) == 1) {
        this.logger.info("Created RegisteredPlayer table in database.");
      } else {
        this.logger.debug("RegisteredPlayer table already exists.");
      }

      migrateDb();

      initialized = true;
      this.logger.info(
          "DatabaseService initialized successfully with type: {}. Registered players: {}",
          dbConfig.STORAGE_TYPE,
          getRegisteredPlayerCount());

    } catch (SQLException | IOException | URISyntaxException | ReflectiveOperationException e) {
      this.logger.error("Failed to initialize database connection", e);
      initialized = false;
      throw new RuntimeException("Database initialization failed", e);
    }
  }

  /**
   * Reloads the database service. If core database connection parameters have changed, it
   * re-initializes the connection. Otherwise, it just re-applies migrations.
   *
   * @param newConfigManager The new configuration manager.
   */
  public void reload(ConfigManager newConfigManager) {
    this.logger.info("Reloading DatabaseService...");
    Settings.DATABASE oldDbConfig = this.configManager.getSettings().DATABASE;
    Settings.DATABASE newDbConfig = newConfigManager.getSettings().DATABASE;

    boolean reinitializeRequired =
        !oldDbConfig.STORAGE_TYPE.equals(newDbConfig.STORAGE_TYPE)
            || !oldDbConfig.HOSTNAME.equals(newDbConfig.HOSTNAME)
            || !oldDbConfig.DATABASE.equals(newDbConfig.DATABASE)
            || !oldDbConfig.USER.equals(newDbConfig.USER)
            || !oldDbConfig.PASSWORD.equals(newDbConfig.PASSWORD);

    if (reinitializeRequired) {
      this.logger.warn(
          "Database configuration has changed significantly. Re-initializing the entire DatabaseService.");
      closeDataSource();
      initialize(this.dataDirectoryPath, newConfigManager);
    } else {
      this.configManager = newConfigManager;
      migrateDb();
      this.logger.info("DatabaseService configuration reloaded. Schema migration check performed.");
    }
  }

  private void migrateDb() {
    if (!isInitialized()) {
      this.logger.error("Cannot migrate database, DatabaseService is not initialized.");
      return;
    }
    this.logger.info("Starting database migration check...");
    TableInfo<RegisteredPlayer, String> tableInfo;
    try {
      // FIX APPLIED HERE: Use supported TableInfo constructor
      DatabaseType databaseType = this.connectionSource.getDatabaseType();
      tableInfo = new TableInfo<RegisteredPlayer, String>(databaseType, RegisteredPlayer.class);
    } catch (SQLException e) {
      this.logger.error("Failed to get TableInfo for RegisteredPlayer during migration.", e);
      throw new SQLRuntimeException("Failed to get TableInfo for migration.", e);
    }

    Set<String> currentFieldsInClass = new HashSet<>();
    for (FieldType fieldType : tableInfo.getFieldTypes()) {
      currentFieldsInClass.add(fieldType.getColumnName().toLowerCase(Locale.ROOT));
    }

    String tableName = tableInfo.getTableName();
    Settings settings = this.configManager.getSettings();
    String databaseName = settings.DATABASE.DATABASE;
    DatabaseLibrary databaseLibrary = settings.DATABASE.STORAGE_TYPE;
    String findSql;

    switch (databaseLibrary) {
      case SQLITE:
        findSql = "SELECT name FROM PRAGMA_TABLE_INFO('" + tableName + "')";
        break;
      case H2:
      case H2_LEGACY_V1:
        findSql =
            "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = SCHEMA() AND TABLE_NAME = '"
                + tableName.toUpperCase()
                + "'";
        break;
      case POSTGRESQL:
        findSql =
            "SELECT column_name FROM information_schema.columns WHERE table_catalog = ? AND table_schema = current_schema() AND table_name = ?";
        break;
      case MARIADB:
      case MYSQL:
        findSql =
            "SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_SCHEMA = ? AND TABLE_NAME = ?";
        break;
      default:
        this.logger.error("Unsupported database type for migration: {}", databaseLibrary);
        return;
    }
    this.logger.debug(
        "Executing migration column check for table '{}' with SQL (parameters will be bound if applicable): {}",
        tableName,
        findSql);

    try {
      try (GenericRawResults<String[]> queryResult =
          (databaseLibrary == DatabaseLibrary.POSTGRESQL
                  || databaseLibrary == DatabaseLibrary.MYSQL
                  || databaseLibrary == DatabaseLibrary.MARIADB)
              ? playerDao.queryRaw(findSql, databaseName, tableName)
              : playerDao.queryRaw(findSql)) {

        Set<String> columnsInDb = new HashSet<>();
        queryResult.forEach(result -> columnsInDb.add(result[0].toLowerCase(Locale.ROOT)));

        Set<FieldType> fieldsToAdd = new HashSet<>();
        for (FieldType fieldType : tableInfo.getFieldTypes()) {
          if (!columnsInDb.contains(fieldType.getColumnName().toLowerCase(Locale.ROOT))) {
            fieldsToAdd.add(fieldType);
          }
        }

        if (fieldsToAdd.isEmpty()) {
          this.logger.info(
              "No schema changes detected for table '{}'. Migration not needed.", tableName);
        } else {
          this.logger.info(
              "Schema changes detected for table '{}'. Applying migrations for columns: {}",
              tableName,
              fieldsToAdd.stream().map(FieldType::getColumnName).collect(Collectors.joining(", ")));

          DatabaseType dbType = this.playerDao.getConnectionSource().getDatabaseType();
          for (FieldType field : fieldsToAdd) {
            try {
              StringBuilder builder = new StringBuilder("ALTER TABLE ");
              dbType.appendEscapedEntityName(builder, tableName);
              builder.append(" ADD COLUMN ");
              dbType.appendColumnArg(
                  tableName,
                  builder,
                  field,
                  Collections.emptyList(),
                  Collections.emptyList(),
                  Collections.emptyList(),
                  Collections.emptyList());

              this.logger.info("Executing DDL for migration: {}", builder.toString());
              playerDao.executeRawNoArgs(builder.toString());
              this.logger.info(
                  "Successfully added column '{}' to table '{}'.",
                  field.getColumnName(),
                  tableName);
            } catch (SQLException e) {
              String sqlState = e.getSQLState();
              String errorMsgLower =
                  e.getMessage() != null ? e.getMessage().toLowerCase(Locale.ROOT) : "";
              if ((sqlState != null && (sqlState.equals("42S21") || sqlState.equals("42701")))
                  || errorMsgLower.contains("duplicate column name")
                  || errorMsgLower.contains("column already exists")
                  || (databaseLibrary == DatabaseLibrary.SQLITE
                      && errorMsgLower.contains("duplicate column name"))) {
                this.logger.warn(
                    "Column '{}' in table '{}' likely already exists (or another schema issue occurred). Skipping addition. Error: {}",
                    field.getColumnName(),
                    tableName,
                    e.getMessage());
              } else {
                this.logger.error(
                    "Failed to migrate column '{}' for table '{}': {}",
                    field.getColumnName(),
                    tableName,
                    e.getMessage(),
                    e);
              }
            }
          }
        }
      }
    } catch (SQLException e) {
      this.logger.error(
          "Failed to query existing columns or execute migration for table '{}': {}",
          tableName,
          e.getMessage(),
          e);
      throw new SQLRuntimeException(
          "Error during database migration query or execution for table " + tableName, e);
    } catch (Exception e) {
      this.logger.error(
          "Unexpected error during database migration resource handling for table '{}': {}",
          tableName,
          e.getMessage(),
          e);
      throw new SQLRuntimeException(
          "Unexpected error during database migration resource handling for table " + tableName, e);
    }
    this.logger.info("Database migration check completed for table '{}'.", tableName);
  }

  /**
   * Finds a player by their lowercase nickname.
   *
   * @param lowercaseNickname The lowercase nickname.
   * @return The {@link RegisteredPlayer} or null if not found.
   * @throws SQLRuntimeException if a database query error occurs.
   * @throws IllegalStateException if the service is not initialized.
   */
  public RegisteredPlayer findPlayerByLowercaseNickname(String lowercaseNickname) {
    if (!isInitialized()) throw new IllegalStateException("DatabaseService not initialized.");
    try {
      return playerDao.queryForId(lowercaseNickname.toLowerCase(Locale.ROOT));
    } catch (SQLException e) {
      this.logger.error("Error finding player by lowercase nickname: {}", lowercaseNickname, e);
      throw new SQLRuntimeException("Database query failed", e);
    }
  }

  /**
   * Finds a player by their nickname (case-insensitive).
   *
   * @param nickname The nickname.
   * @return The {@link RegisteredPlayer} or null if not found.
   */
  public RegisteredPlayer findPlayerByNickname(String nickname) {
    if (!isInitialized()) throw new IllegalStateException("DatabaseService not initialized.");
    return findPlayerByLowercaseNickname(nickname.toLowerCase(Locale.ROOT));
  }

  /**
   * Finds a player by their general UUID (can be online or offline mode UUID).
   *
   * @param uuid The UUID.
   * @return The {@link RegisteredPlayer} or null if not found.
   * @throws SQLRuntimeException if a database query error occurs.
   * @throws IllegalStateException if the service is not initialized.
   */
  public RegisteredPlayer findPlayerByUUID(UUID uuid) {
    if (!isInitialized()) throw new IllegalStateException("DatabaseService not initialized.");
    try {
      QueryBuilder<RegisteredPlayer, String> qb = playerDao.queryBuilder();
      qb.where().eq(RegisteredPlayer.UUID_FIELD, uuid.toString());
      return qb.queryForFirst();
    } catch (SQLException e) {
      this.logger.error("Error finding player by UUID '{}': {}", uuid, e.getMessage(), e);
      throw new SQLRuntimeException(e);
    }
  }

  /**
   * Finds a player by their premium (online-mode) UUID.
   *
   * @param premiumUuid The premium UUID.
   * @return The {@link RegisteredPlayer} or null if not found.
   * @throws SQLRuntimeException if a database query error occurs.
   * @throws IllegalStateException if the service is not initialized.
   */
  public RegisteredPlayer findPlayerByPremiumUUID(UUID premiumUuid) {
    if (!isInitialized()) throw new IllegalStateException("DatabaseService not initialized.");
    try {
      QueryBuilder<RegisteredPlayer, String> qb = playerDao.queryBuilder();
      qb.where().eq(RegisteredPlayer.PREMIUM_UUID_FIELD, premiumUuid.toString());
      return qb.queryForFirst();
    } catch (SQLException e) {
      this.logger.error(
          "Error finding player by premium UUID '{}': {}", premiumUuid, e.getMessage(), e);
      throw new SQLRuntimeException(e);
    }
  }

  /**
   * Creates a new player record in the database.
   *
   * @param player The {@link RegisteredPlayer} to create.
   * @throws SQLRuntimeException if the database operation fails.
   * @throws IllegalStateException if the service is not initialized.
   */
  public void createPlayer(RegisteredPlayer player) {
    if (!isInitialized()) throw new IllegalStateException("DatabaseService not initialized.");
    try {
      playerDao.create(player);
      this.logger.info("Created player record for: {}", player.getLowercaseNickname());
    } catch (SQLException e) {
      this.logger.error("Error creating player: {}", player.getLowercaseNickname(), e);
      throw new SQLRuntimeException("Failed to create player", e);
    }
  }

  /**
   * Updates an existing player record in the database.
   *
   * @param player The {@link RegisteredPlayer} to update.
   * @throws SQLRuntimeException if the database operation fails.
   * @throws IllegalStateException if the service is not initialized.
   */
  public void updatePlayer(RegisteredPlayer player) {
    if (!isInitialized()) throw new IllegalStateException("DatabaseService not initialized.");
    try {
      playerDao.update(player);
      this.logger.debug("Updated player record for: {}", player.getLowercaseNickname());
    } catch (SQLException e) {
      this.logger.error("Error updating player: {}", player.getLowercaseNickname(), e);
      throw new SQLRuntimeException("Failed to update player", e);
    }
  }

  /**
   * Deletes a player record from the database by their lowercase nickname.
   *
   * @param lowercaseNickname The lowercase nickname of the player to delete.
   * @throws SQLRuntimeException if the database operation fails.
   * @throws IllegalStateException if the service is not initialized.
   */
  public void deletePlayerByLowercaseNickname(String lowercaseNickname) {
    if (!isInitialized()) throw new IllegalStateException("DatabaseService not initialized.");
    try {
      int deleted = playerDao.deleteById(lowercaseNickname.toLowerCase(Locale.ROOT));
      if (deleted > 0) {
        this.logger.info("Deleted player record for: {}", lowercaseNickname);
      } else {
        this.logger.warn(
            "No player found to delete with lowercase nickname: {}", lowercaseNickname);
      }
    } catch (SQLException e) {
      this.logger.error("Error deleting player: {}", lowercaseNickname, e);
      throw new SQLRuntimeException("Failed to delete player", e);
    }
  }

  /**
   * Deletes a player record from the database by their nickname (case-insensitive).
   *
   * @param nickname The nickname of the player to delete.
   */
  public void deletePlayer(String nickname) {
    if (!isInitialized()) throw new IllegalStateException("DatabaseService not initialized.");
    deletePlayerByLowercaseNickname(nickname.toLowerCase(Locale.ROOT));
  }

  /**
   * Gets the total count of registered players in the database.
   *
   * @return The number of registered players, or 0 if an error occurs or not initialized.
   */
  public long getRegisteredPlayerCount() {
    if (!isInitialized() || playerDao == null) return 0;
    try {
      return playerDao.countOf();
    } catch (SQLException e) {
      this.logger.error("Error counting players", e);
      return 0;
    }
  }

  /**
   * Checks if the database service has been successfully initialized.
   *
   * @return True if initialized, false otherwise.
   */
  public boolean isInitialized() {
    return initialized;
  }

  /**
   * Gets the DAO for {@link RegisteredPlayer} entities.
   *
   * @return The player DAO.
   * @throws IllegalStateException if the service is not initialized.
   */
  public Dao<RegisteredPlayer, String> getPlayerDao() {
    if (!isInitialized()) throw new IllegalStateException("DatabaseService not initialized.");
    return playerDao;
  }

  /**
   * Gets the underlying ORMLite {@link ConnectionSource}.
   *
   * @return The connection source.
   * @throws IllegalStateException if the service is not initialized.
   */
  public ConnectionSource getConnectionSource() {
    if (!isInitialized()) throw new IllegalStateException("DatabaseService not initialized.");
    return connectionSource;
  }

  /** Closes the database connection source and marks the service as uninitialized. */
  public void closeDataSource() {
    if (connectionSource != null) {
      try {
        DaoManager.clearCache();
        connectionSource.close();
        this.logger.info("Database connection closed successfully.");
      } catch (Exception e) {
        this.logger.error("Error closing database connection", e);
      }
    }
    initialized = false;
  }
}

```

`src/main/java/net/elytrium/limboauth/service/LimboServerFacade.java`:

```java
// File: LimboAuth/src/main/java/net/elytrium/limboauth/service/LimboServerFacade.java
package net.elytrium.limboauth.service;

import com.velocitypowered.api.proxy.Player;
import com.velocitypowered.api.proxy.server.RegisteredServer;
import com.velocitypowered.api.proxy.server.ServerInfo;
import java.io.IOException;
import java.io.InputStream;
import java.net.InetSocketAddress;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardCopyOption;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.stream.Collectors;
import net.elytrium.limboapi.api.Limbo;
import net.elytrium.limboapi.api.LimboFactory;
import net.elytrium.limboapi.api.LimboSessionHandler;
import net.elytrium.limboapi.api.chunk.VirtualWorld;
import net.elytrium.limboapi.api.command.LimboCommandMeta;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.Settings;
import net.kyori.adventure.text.Component;
import org.slf4j.Logger;

/**
 * Facade for interacting with the LimboAPI to create and manage the authentication Limbo server and
 * world.
 */
public class LimboServerFacade {

  private final LimboAuth plugin;
  private final Logger logger;
  private final LimboFactory limboFactory;
  private final Path dataDirectory;
  private Limbo authServer;
  private VirtualWorld authWorld;
  private ConfigManager configManager;
  private ServerInfo authServerInfo;

  /**
   * Constructs the LimboServerFacade.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param logger The logger for this service.
   * @param limboFactory The LimboFactory for creating Limbo instances.
   * @param dataDirectory The plugin's data directory, used for world files.
   */
  public LimboServerFacade(
      LimboAuth plugin, Logger logger, LimboFactory limboFactory, Path dataDirectory) {
    this.plugin = plugin;
    this.logger = logger;
    this.limboFactory = limboFactory;
    this.dataDirectory = dataDirectory;
  }

  /**
   * Initializes the facade by creating the authentication Limbo this.server.
   *
   * @param configManager The configuration manager.
   * @throws RuntimeException if initialization fails.
   */
  public void initialize(ConfigManager configManager) {
    this.configManager = configManager;
    try {
      createAuthServer();
      if (this.authServerInfo != null) {
        this.logger.info(
            "LimboServerFacade initialized successfully, auth server: {}",
            this.authServerInfo.getName());
      } else {
        this.logger.error("Auth server info is null after creation during initialization!");
      }
    } catch (Exception e) {
      this.logger.error("Failed to initialize LimboServerFacade", e);
      throw new RuntimeException("LimboServerFacade initialization failed", e);
    }
  }

  /**
   * Reloads the facade by disposing of the old auth server and creating a new one based on the
   * (potentially updated) configuration.
   *
   * @param newConfigManager The new configuration manager.
   * @throws RuntimeException if reloading fails.
   */
  public void reload(ConfigManager newConfigManager) {
    this.configManager = newConfigManager;
    disposeAuthServer();
    try {
      createAuthServer();
      if (this.authServerInfo != null) {
        this.logger.info(
            "LimboServerFacade reloaded successfully, auth server: {}",
            this.authServerInfo.getName());
      } else {
        this.logger.error("Auth server info is null after creation during reload!");
      }
    } catch (Exception e) {
      this.logger.error("Failed to reload LimboServerFacade", e);
      throw new RuntimeException("LimboServerFacade reload failed", e);
    }
  }

  private void createAuthServer() {
    Settings settings = this.configManager.getSettings();

    this.authWorld =
        this.limboFactory.createVirtualWorld(
            settings.MAIN.DIMENSION,
            settings.MAIN.AUTH_COORDS.X,
            settings.MAIN.AUTH_COORDS.Y,
            settings.MAIN.AUTH_COORDS.Z,
            (float) settings.MAIN.AUTH_COORDS.YAW,
            (float) settings.MAIN.AUTH_COORDS.PITCH);

    if (settings.MAIN.LOAD_WORLD) {
      Path worldFilePath = this.dataDirectory.resolve(settings.MAIN.WORLD_FILE_PATH);
      if (!Files.exists(worldFilePath)) {
        this.logger.warn(
            "LimboAuth world file not found: {}. Attempting to copy from resources.",
            worldFilePath);
        try (InputStream defaultWorldStream =
            getClass().getResourceAsStream("/" + settings.MAIN.WORLD_FILE_PATH)) {
          if (defaultWorldStream != null) {
            Files.createDirectories(worldFilePath.getParent());
            Files.copy(defaultWorldStream, worldFilePath, StandardCopyOption.REPLACE_EXISTING);
            this.logger.info("Copied default world file to: {}", worldFilePath);
          } else {
            this.logger.warn(
                "Default world file not found in resources: {}", settings.MAIN.WORLD_FILE_PATH);
          }
        } catch (IOException e) {
          this.logger.error(
              "Failed to copy default world file for LimboAuth: {}",
              settings.MAIN.WORLD_FILE_PATH,
              e);
        }
      }

      if (Files.exists(worldFilePath)) {
        try {
          net.elytrium.limboapi.api.file.WorldFile worldFile =
              this.limboFactory.openWorldFile(settings.MAIN.WORLD_FILE_TYPE, worldFilePath);
          worldFile.toWorld(
              this.limboFactory,
              this.authWorld,
              settings.MAIN.WORLD_COORDS.X,
              settings.MAIN.WORLD_COORDS.Y,
              settings.MAIN.WORLD_COORDS.Z,
              settings.MAIN.WORLD_LIGHT_LEVEL);
          this.logger.info("Loaded world file: {}", settings.MAIN.WORLD_FILE_PATH);
        } catch (Exception e) {
          this.logger.error("Failed to load world file: {}", settings.MAIN.WORLD_FILE_PATH, e);
        }
      }
    }

    String limboServerName = settings.MAIN.LIMBO_SERVER_NAME;
    InetSocketAddress limboAddress = new InetSocketAddress("127.0.0.1", 0);

    this.authServer = this.limboFactory.createLimbo(this.authWorld);
    this.authServer.setName(limboServerName);
    this.authServer.setGameMode(settings.MAIN.GAME_MODE);
    this.authServer.setWorldTime(settings.MAIN.WORLD_TICKS);
    // Note: setLightLevel was removed as it's likely handled by VirtualWorld or world file.

    this.authServer.registerCommand(
        new LimboCommandMeta(filterLimboCommands(settings.MAIN.REGISTER_COMMAND)));
    this.authServer.registerCommand(
        new LimboCommandMeta(filterLimboCommands(settings.MAIN.LOGIN_COMMAND)));

    if (settings.MAIN.ENABLE_TOTP) {
      this.authServer.registerCommand(
          new LimboCommandMeta(filterLimboCommands(settings.MAIN.TOTP_COMMAND)));
    }

    Optional<RegisteredServer> registeredServerOpt =
        this.plugin.getServer().getServer(limboServerName);
    if (registeredServerOpt.isPresent()) {
      this.authServerInfo = registeredServerOpt.get().getServerInfo();
      this.logger.info(
          "Auth server '{}' registered and ServerInfo obtained from Velocity.",
          this.authServerInfo.getName());
    } else {
      this.logger.warn(
          "Could not find registered server '{}' in Velocity. Using placeholder ServerInfo.",
          limboServerName);
      // FIX APPLIED HERE: Use limboAddress as fallback for ServerInfo when getBoundAddress() is not
      // available
      this.authServerInfo = new ServerInfo(limboServerName, limboAddress);
    }

    if (this.authServerInfo != null) {
      this.logger.info(
          "Auth server (retrieved/confirmed) with name: {}", this.authServerInfo.getName());
    } else {
      this.logger.error(
          "Auth server's ServerInfo is critically null after creation/registration attempt!");
    }
  }

  private List<String> filterLimboCommands(List<String> commands) {
    return commands.stream()
        .filter(Objects::nonNull)
        .filter(command -> command.startsWith("/"))
        .map(command -> command.substring(1))
        .collect(Collectors.toList());
  }

  /**
   * Spawns a player into the authentication Limbo this.server.
   *
   * @param player The player to spawn.
   * @param sessionHandler The {@link LimboSessionHandler} for this player's Limbo session.
   */
  public void spawnPlayerInLimbo(Player player, LimboSessionHandler sessionHandler) {
    if (this.authServer == null) {
      this.logger.error("Cannot spawn player - auth server is not initialized");
      player.disconnect(
          Component.text("Authentication server is not available. Please try again later."));
      return;
    }
    try {
      this.authServer.spawnPlayer(player, sessionHandler);
      this.logger.debug("Spawned player {} in auth limbo", player.getUsername());
    } catch (Exception e) {
      this.logger.error("Failed to spawn player {} in auth limbo", player.getUsername(), e);
      player.disconnect(
          Component.text("Error joining authentication this.server. Please try again later."));
    }
  }

  /**
   * Passes a player through the Limbo login process, effectively allowing them to connect to their
   * target this.server.
   *
   * @param player The player to pass.
   */
  public void passLoginLimbo(Player player) {
    try {
      this.limboFactory.passLoginLimbo(player);
      this.logger.debug("Passed player {} through Limbo login.", player.getUsername());
    } catch (Exception e) {
      this.logger.error(
          "Exception while passing player {} through Limbo login: {}",
          player.getUsername(),
          e.getMessage(),
          e);
    }
  }

  /**
   * Gets the name of the authentication this.server.
   *
   * @return The server name.
   */
  public String getServerName() {
    if (this.authServerInfo == null) {
      return configManager != null
          ? this.configManager.getSettings().MAIN.LIMBO_SERVER_NAME
          : "LimboAuth_Default_Fallback";
    }
    return this.authServerInfo.getName();
  }

  /** Disposes of the current authentication Limbo server and world resources. */
  public void disposeAuthServer() {
    if (this.authServer != null) {
      try {
        String serverName =
            this.authServerInfo != null ? this.authServerInfo.getName() : "[unknown_pre_dispose]";
        this.authServer.dispose();
        this.logger.info("Auth server '{}' disposed successfully", serverName);
      } catch (Exception e) {
        this.logger.error("Error disposing auth server", e);
      } finally {
        this.authServer = null;
        this.authServerInfo = null;
      }
    }

    if (this.authWorld != null) {
      this.authWorld = null;
      this.logger.debug("Auth world reference cleared.");
    }
  }

  /**
   * @return The current {@link Limbo} instance for authentication.
   */
  public Limbo getAuthServer() {
    return authServer;
  }

  /**
   * @return The current {@link VirtualWorld} used for authentication.
   */
  public VirtualWorld getAuthWorld() {
    return authWorld;
  }

  /**
   * @return True if the Limbo server and its ServerInfo are initialized.
   */
  public boolean isInitialized() {
    return authServer != null && authServerInfo != null;
  }

  /**
   * @return The {@link ServerInfo} for the authentication Limbo this.server.
   */
  public ServerInfo getAuthServerInfo() {
    return authServerInfo;
  }
}

```

`src/main/java/net/elytrium/limboauth/service/PlayerSessionService.java`:

```java
// File: LimboAuth/src/main/java/net/elytrium/limboauth/service/PlayerSessionService.java
package net.elytrium.limboauth.service;

import com.google.inject.Inject;
import com.velocitypowered.api.proxy.Player;
import java.util.Locale;
import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;
import net.elytrium.limboauth.LimboAuth;
import net.elytrium.limboauth.handler.AuthSessionHandler;
import net.elytrium.limboauth.model.RegisteredPlayer;
import org.slf4j.Logger;

/**
 * Manages player authentication sessions, including tracking players currently in the
 * authentication process and their login attempts. It also handles post-login tasks.
 */
public class PlayerSessionService {

  private final Logger logger;
  private final Map<String, AuthSessionHandler> authenticatingPlayers = new ConcurrentHashMap<>();
  private final Map<UUID, Runnable> postLoginTasks = new ConcurrentHashMap<>();
  private final Map<String, Integer> playerLoginAttempts = new ConcurrentHashMap<>();

  private final DatabaseService databaseService;
  private final ConfigManager configManager;
  private final LimboAuth plugin;
  private AuthenticationService authenticationService;
  private final LimboServerFacade limboServerFacade;
  private final CacheManager cacheManager;

  /**
   * Constructs the PlayerSessionService. Dependencies are injected.
   *
   * @param plugin The main LimboAuth plugin instance.
   * @param logger The logger for this service.
   * @param databaseService Service for database interactions.
   * @param authenticationService Service for authentication logic (can be null initially).
   * @param limboServerFacade Facade for Limbo server interactions.
   * @param configManager Service for accessing configuration.
   * @param cacheManager Service for managing caches.
   */
  @Inject
  public PlayerSessionService(
      LimboAuth plugin,
      Logger logger,
      DatabaseService databaseService,
      AuthenticationService authenticationService,
      LimboServerFacade limboServerFacade,
      ConfigManager configManager,
      CacheManager cacheManager) {
    this.plugin = plugin;
    this.logger = logger;
    this.databaseService = databaseService;
    this.authenticationService = authenticationService;
    this.limboServerFacade = limboServerFacade;
    this.configManager = configManager;
    this.cacheManager = cacheManager;
  }

  /**
   * Initializes the PlayerSessionService. Currently logs an informational message.
   *
   * @param pluginInstance The main LimboAuth plugin instance.
   */
  public void initialize(LimboAuth pluginInstance) {
    this.logger.info("PlayerSessionService initialized.");
  }

  /**
   * Sets the {@link AuthenticationService} instance. This is used to resolve a potential circular
   * dependency during plugin initialization.
   *
   * @param authenticationService The AuthenticationService instance.
   */
  public void setAuthenticationService(AuthenticationService authenticationService) {
    this.authenticationService = authenticationService;
  }

  /**
   * Reloads the PlayerSessionService. Currently logs an informational message.
   * Configuration-dependent settings should be re-applied here if any.
   *
   * @param newConfigManager The new ConfigManager instance after a reload.
   */
  public void reload(ConfigManager newConfigManager) {
    this.logger.info("PlayerSessionService reloaded.");
  }

  /**
   * Creates an {@link AuthSessionHandler} for a player entering the authentication process.
   *
   * @param proxyPlayer The Velocity {@link Player} instance.
   * @param playerInfo The {@link RegisteredPlayer} data.
   * @return A new {@link AuthSessionHandler} instance.
   */
  public AuthSessionHandler createAuthSessionHandler(
      Player proxyPlayer, RegisteredPlayer playerInfo) {
    // Corrected constructor call for AuthSessionHandler
    AuthSessionHandler handler = new AuthSessionHandler(this.plugin, proxyPlayer, this);
    addAuthenticatingPlayer(proxyPlayer.getUsername(), handler);
    return handler;
  }

  /**
   * Adds a player and their {@link AuthSessionHandler} to the map of authenticating players.
   * Initializes their login attempts based on configuration.
   *
   * @param nickname The player's nickname.
   * @param handler The player's {@link AuthSessionHandler}.
   */
  public void addAuthenticatingPlayer(String nickname, AuthSessionHandler handler) {
    authenticatingPlayers.put(nickname.toLowerCase(Locale.ROOT), handler);
    playerLoginAttempts.put(
        nickname.toLowerCase(Locale.ROOT), this.configManager.getSettings().MAIN.LOGIN_ATTEMPTS);
    this.logger.debug(
        "Player {} added to authenticating players map with {} attempts.",
        nickname,
        this.configManager.getSettings().MAIN.LOGIN_ATTEMPTS);
  }

  /**
   * Removes a player from the map of authenticating players and clears their login attempt count.
   *
   * @param nickname The player's nickname.
   */
  public void removeAuthenticatingPlayer(String nickname) {
    authenticatingPlayers.remove(nickname.toLowerCase(Locale.ROOT));
    playerLoginAttempts.remove(nickname.toLowerCase(Locale.ROOT));
    this.logger.debug("Player {} removed from authenticating players map.", nickname);
  }

  /**
   * Retrieves the {@link AuthSessionHandler} for a player currently in authentication.
   *
   * @param nickname The player's nickname.
   * @return The {@link AuthSessionHandler}, or {@code null} if the player is not authenticating.
   */
  public AuthSessionHandler getAuthenticatingPlayer(String nickname) {
    return authenticatingPlayers.get(nickname.toLowerCase(Locale.ROOT));
  }

  /**
   * Gets a map of all players currently in the authentication process. The keys are lowercase
   * player nicknames, and values are their {@link AuthSessionHandler}s.
   *
   * @return A map of authenticating players. Consider returning an unmodifiable view if external
   *     modification is not desired.
   */
  public Map<String, AuthSessionHandler> getAuthenticatingPlayers() {
    return authenticatingPlayers;
  }

  /**
   * Adds a task to be executed after a player successfully logs in. The task is stored by player
   * UUID and will be removed after retrieval.
   *
   * @param playerId The UUID of the player.
   * @param task The {@link Runnable} task to execute.
   */
  public void addPostLoginTask(UUID playerId, Runnable task) {
    postLoginTasks.put(playerId, task);
    this.logger.debug("Post login task added for player UUID: {}", playerId);
  }

  /**
   * Retrieves and removes a post-login task for a player.
   *
   * @param playerId The UUID of the player.
   * @return The {@link Runnable} task, or {@code null} if no task was queued for this player.
   */
  public Runnable getPostLoginTask(UUID playerId) {
    return postLoginTasks.remove(playerId);
  }

  /**
   * Gets the number of remaining login attempts for a player.
   *
   * @param username The player's username.
   * @return The number of remaining attempts, or 0 if the player is not tracked or has no attempts
   *     left.
   */
  public int getRemainingLoginAttempts(String username) {
    return playerLoginAttempts.getOrDefault(username.toLowerCase(Locale.ROOT), 0);
  }

  /**
   * Decrements the number of login attempts for a player. The count will not go below zero.
   *
   * @param username The player's username.
   */
  public void decrementLoginAttempts(String username) {
    String lowerUser = username.toLowerCase(Locale.ROOT);
    playerLoginAttempts.computeIfPresent(lowerUser, (k, v) -> Math.max(0, v - 1));
    this.logger.debug(
        "Decremented login attempts for {}. Remaining: {}",
        username,
        getRemainingLoginAttempts(username));
  }

  /**
   * Resets the login attempts for a player to the configured maximum.
   *
   * @param username The player's username.
   */
  public void resetLoginAttempts(String username) {
    playerLoginAttempts.put(
        username.toLowerCase(Locale.ROOT), this.configManager.getSettings().MAIN.LOGIN_ATTEMPTS);
    this.logger.debug(
        "Reset login attempts for {} to {}.",
        username,
        this.configManager.getSettings().MAIN.LOGIN_ATTEMPTS);
  }

  /**
   * Checks if a player needs to register. This typically means they are not found in the database.
   *
   * @param username The player's username.
   * @return {@code true} if the player needs to register, {@code false} otherwise.
   */
  public boolean needsRegistration(String username) {
    return this.databaseService.findPlayerByLowercaseNickname(username.toLowerCase(Locale.ROOT))
        == null;
  }

  /**
   * Retrieves the RegisteredPlayer object for a given username.
   *
   * @param username The player's username.
   * @return The {@link RegisteredPlayer} object, or {@code null} if not found.
   */
  public RegisteredPlayer getRegisteredPlayer(String username) {
    return this.databaseService.findPlayerByLowercaseNickname(username.toLowerCase(Locale.ROOT));
  }
}

```

`src/main/java/net/elytrium/limboauth/service/TaskSchedulingService.java`:

```java
package net.elytrium.limboauth.service;

import com.google.inject.Inject;
import com.velocitypowered.api.plugin.PluginContainer;
import com.velocitypowered.api.scheduler.ScheduledTask;
import com.velocitypowered.api.scheduler.Scheduler;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.TimeUnit;
import net.elytrium.limboauth.LimboAuth;
import org.slf4j.Logger;

/**
 * Service for scheduling tasks using Velocity's scheduler. It provides methods for scheduling
 * repeating tasks, delayed tasks, and manages a list of scheduled tasks for cancellation.
 */
public class TaskSchedulingService {

  private final Scheduler scheduler;
  private final LimboAuth plugin;
  private final PluginContainer pluginContainer;
  private final Logger logger;
  private final List<ScheduledTask> scheduledTasks = new ArrayList<>();

  /**
   * Constructs the TaskSchedulingService. Dependencies are injected.
   *
   * @param plugin The main LimboAuth plugin instance, used to get the plugin container and
   *     scheduler.
   * @param logger The logger for this service.
   */
  @Inject
  /** Default constructor. */
  public TaskSchedulingService(LimboAuth plugin, Logger logger) {
    this.plugin = plugin;
    this.pluginContainer = this.plugin.getPluginContainer();
    this.scheduler =
        this.plugin.getServer().getScheduler(); // Pobierz Scheduler z instancji ProxyServer
    this.logger = logger;
  }

  /**
   * Schedules a task to run repeatedly.
   *
   * @param task The {@link Runnable} to execute.
   * @param delayMillis The initial delay in milliseconds before the first execution.
   * @param repeatMillis The interval in milliseconds between subsequent executions.
   * @return The {@link ScheduledTask} representing this scheduled task.
   */
  public ScheduledTask scheduleRepeatingTask(Runnable task, long delayMillis, long repeatMillis) {
    ScheduledTask scheduledTask =
        scheduler
            .buildTask(pluginContainer, task)
            .delay(delayMillis, TimeUnit.MILLISECONDS)
            .repeat(repeatMillis, TimeUnit.MILLISECONDS)
            .schedule();
    scheduledTasks.add(scheduledTask);
    this.logger.debug(
        "Scheduled repeating task with delay {}ms and repeat {}ms", delayMillis, repeatMillis);
    return scheduledTask;
  }

  /**
   * Schedules a task to run once after a specified delay.
   *
   * @param task The {@link Runnable} to execute.
   * @param delayMillis The delay in milliseconds before execution.
   * @return The {@link ScheduledTask} representing this scheduled task.
   */
  public ScheduledTask scheduleDelayedTask(Runnable task, long delayMillis) {
    ScheduledTask scheduledTask =
        scheduler
            .buildTask(pluginContainer, task)
            .delay(delayMillis, TimeUnit.MILLISECONDS)
            .schedule();
    // Does not add to scheduledTasks list as it's a one-off and usually not globally managed for
    // cancellation.
    this.logger.debug("Scheduled delayed task with delay {}ms", delayMillis);
    return scheduledTask;
  }

  /**
   * Schedules a task to run once after a specified delay with a given time unit. This task is
   * tracked for potential cancellation via {@link #cancelAllTasks()}.
   *
   * @param task The {@link Runnable} to execute.
   * @param delay The delay before execution.
   * @param unit The {@link TimeUnit} for the delay.
   * @return The {@link ScheduledTask} representing this scheduled task.
   */
  public ScheduledTask scheduleOnce(Runnable task, long delay, TimeUnit unit) {
    ScheduledTask scheduled =
        scheduler.buildTask(pluginContainer, task).delay(delay, unit).schedule();
    scheduledTasks.add(scheduled); // Track this task
    this.logger.debug("Scheduled one-time task with delay {} {}", delay, unit.toString());
    return scheduled;
  }

  /**
   * Cancels a specific scheduled task. If the task was tracked by this service, it will also be
   * removed from the internal list.
   *
   * @param task The {@link ScheduledTask} to cancel.
   */
  public void cancelTask(ScheduledTask task) {
    if (task != null) {
      task.cancel();
      scheduledTasks.remove(task);
      this.logger.debug("Cancelled a scheduled task.");
    }
  }

  /** Cancels all tasks that were scheduled through this service and are currently tracked. */
  public void cancelAllTasks() {
    for (ScheduledTask task :
        new ArrayList<>(
            scheduledTasks)) { // Iterate over a copy to avoid ConcurrentModificationException
      task.cancel();
    }
    scheduledTasks.clear();
    this.logger.info("All tracked scheduled tasks have been cancelled.");
  }

  /**
   * Placeholder method for rescheduling tasks. Currently, task rescheduling is handled by
   * individual services re-registering their tasks after a configuration reload.
   *
   * @param configManager The {@link ConfigManager} instance, potentially used to get new scheduling
   *     parameters.
   */
  public void rescheduleAllTasks(ConfigManager configManager) {
    // This method is not currently used for automatic re-scheduling of all tasks.
    // Services like CacheManager should re-register their purge tasks themselves upon reload.
    this.logger.info(
        "Task rescheduling logic is typically handled by individual services calling scheduling methods again upon reload.");
  }
}

```

`src/main/templates/net/elytrium/limboauth/BuildConstants.java`:

```java
/*
 * Copyright (C) 2021 - 2025 Elytrium
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

package net.elytrium.limboauth;

/**
 * Contains build-time constants for the LimboAuth this.plugin. The values in this class are
 * typically replaced by the build system (e.g., Gradle) before compilation.
 */
public class BuildConstants {

  /**
   * The version string of the LimboAuth this.plugin. This field is replaced by the build system
   * with the actual project version.
   */
  public static final String AUTH_VERSION = "${version}";
}

```